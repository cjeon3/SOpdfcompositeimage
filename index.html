<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sound Object Analyzer v9.0 - Enhanced Smoothing</title>
    <meta name="version" content="9.0.0">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            font-family: ui-sans-serif, system-ui, sans-serif;
            background-color: #f3f4f6;
        }
        
        .canvas-container {
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }
        
        .canvas-container:hover {
            transform: scale(1.02);
            transition: transform 0.2s;
        }
        
        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5rem;
        }
    </style>
</head>
<body>
    <div class="max-w-7xl mx-auto p-6">
        <!-- Header -->
        <div class="bg-gradient-to-r from-purple-600 to-pink-600 text-white p-6 rounded-xl shadow-xl mb-6">
            <h1 class="text-4xl font-bold mb-2">Sound Object Analyzer v9.0</h1>
            <p class="text-purple-100 text-lg">Enhanced Version - Radial Contours & Aggressive Outlier Filtering</p>
            <div class="mt-4 flex flex-wrap gap-2">
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">âœ“ Radial Contour Extraction</span>
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">âœ“ Proper Closed Shapes</span>
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">âœ“ Enhanced Outlier Filtering</span>
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">âœ“ Gaussian Smoothing</span>
            </div>
        </div>
        
        <!-- Instructions -->
        <div class="bg-purple-50 p-6 rounded-xl mb-6 border-2 border-purple-200">
            <h2 class="text-xl font-bold text-purple-900 mb-3">ðŸ“‹ Instructions</h2>
            <ol class="list-decimal list-inside space-y-2 text-purple-800">
                <li>Upload your <strong>participant_drawings.zip</strong> file containing all images</li>
                <li>The analyzer will extract red (in-phase) and blue (out-of-phase) shapes</li>
                <li>Composite images will be generated for each frequency (31-16000 Hz)</li>
                <li><strong>v9.0 Improvements:</strong> Radial contour sampling creates proper closed shapes (no more worms!), enhanced outlier removal for smoother averages</li>
                <li>Click any composite to download as PNG</li>
            </ol>
        </div>
        
        <!-- Upload Section -->
        <div class="bg-white p-6 rounded-xl shadow-lg mb-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Upload Images</h2>
            <input type="file" id="zipInput" accept=".zip" 
                   class="block w-full text-gray-700 border-2 border-gray-300 rounded-lg p-3 cursor-pointer hover:border-purple-500 transition">
        </div>
        
        <!-- Progress Section -->
        <div id="progress-container" class="bg-white p-6 rounded-xl shadow-lg mb-6 hidden">
            <h3 class="text-xl font-bold text-gray-800 mb-4">Processing...</h3>
            <div class="w-full bg-gray-200 rounded-full h-6">
                <div id="progress-bar" class="bg-gradient-to-r from-purple-500 to-pink-500 h-6 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
            <p id="progress-text" class="text-gray-600 mt-2"></p>
        </div>
        
        <!-- Visualization Section -->
        <div id="visualization-container" class="hidden">
            <h2 class="text-3xl font-bold text-gray-800 mb-4">Composite Visualizations</h2>
            <div id="visualization-grid" class="analysis-grid"></div>
        </div>
    </div>
    
    <script>
        // ============================================
        // CONSTANTS
        // ============================================
        
        const CANVAS_SIZE = 600;
        const GRID_RANGE = 6; // -6 to +6 units
        const SCALE = CANVAS_SIZE / (2 * GRID_RANGE); // pixels per unit
        const CENTER_X = CANVAS_SIZE / 2;
        const CENTER_Y = CANVAS_SIZE / 2;
        const HEAD_CIRCLE_RADIUS = 3; // units
        
        const FREQUENCIES = ['31', '62.5', '125', '250', '500', '1000', '2000', '4000', '8000', '16000'];
        
        // ============================================
        // RADIAL CONTOUR EXTRACTION - NO MORE WORMS!
        // ============================================
        
        function extractRadialContour(pixels) {
            if (pixels.length === 0) return [];
            
            // First, find the centroid of all pixels
            const centroid = {
                x: pixels.reduce((sum, p) => sum + p.x, 0) / pixels.length,
                y: pixels.reduce((sum, p) => sum + p.y, 0) / pixels.length
            };
            
            // Sample radially from centroid at many angles
            const numAngles = 360;
            const contourPoints = [];
            
            for (let i = 0; i < numAngles; i++) {
                const angle = (i / numAngles) * 2 * Math.PI;
                const direction = { x: Math.cos(angle), y: Math.sin(angle) };
                
                // Find the furthest pixel in this direction
                let maxDist = 0;
                let furthestPixel = null;
                
                pixels.forEach(pixel => {
                    const dx = pixel.x - centroid.x;
                    const dy = pixel.y - centroid.y;
                    
                    // Project onto direction vector
                    const projection = dx * direction.x + dy * direction.y;
                    
                    // Check if this pixel is roughly in this direction (within 5 degrees)
                    const pixelAngle = Math.atan2(dy, dx);
                    let angleDiff = Math.abs(pixelAngle - angle);
                    if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                    
                    if (angleDiff < Math.PI / 36 && projection > maxDist) { // Within ~5 degrees
                        maxDist = projection;
                        furthestPixel = pixel;
                    }
                });
                
                if (furthestPixel) {
                    contourPoints.push(furthestPixel);
                } else {
                    // Interpolate from neighbors if no pixel found
                    contourPoints.push({ x: centroid.x, y: centroid.y });
                }
            }
            
            // Smooth the contour with moving average
            return smoothContour(contourPoints, 5);
        }
        
        function smoothContour(contour, windowSize) {
            if (contour.length < windowSize) return contour;
            
            const smoothed = [];
            const halfWindow = Math.floor(windowSize / 2);
            
            for (let i = 0; i < contour.length; i++) {
                let sumX = 0, sumY = 0, count = 0;
                
                for (let j = -halfWindow; j <= halfWindow; j++) {
                    const idx = (i + j + contour.length) % contour.length;
                    sumX += contour[idx].x;
                    sumY += contour[idx].y;
                    count++;
                }
                
                smoothed.push({
                    x: sumX / count,
                    y: sumY / count
                });
            }
            
            return smoothed;
        }
        
        // ============================================
        // SHAPE EXTRACTION
        // ============================================
        
        function extractShapesFromImage(imageData, filename) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            
            const redPixels = [];
            const bluePixels = [];
            
            // Identify colored pixels
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    
                    // Skip white pixels
                    if (r > 240 && g > 240 && b > 240) continue;
                    
                    // Skip gray pixels (grid lines and reference circle)
                    if (Math.abs(r - g) < 30 && Math.abs(g - b) < 30) {
                        if (r < 100 && g < 100 && b < 100) continue; // Black circle
                        if (r > 140 && r < 200) continue; // Grid lines
                    }
                    
                    // Better color detection
                    if (b > r + 20 && b > g + 20) {
                        bluePixels.push({ x, y });
                    }
                    else if (r > b + 20 && r > g + 20) {
                        redPixels.push({ x, y });
                    }
                }
            }
            
            console.log(`${filename}: Found ${redPixels.length} red pixels, ${bluePixels.length} blue pixels`);
            
            const shapes = [];
            
            // Process red shape with radial sampling
            if (redPixels.length > 100) {
                const redContour = extractRadialContour(redPixels);
                if (redContour.length > 0) {
                    const redCentroid = calculateCentroid(redContour);
                    const area = calculateContourArea(redContour);
                    const radialProfile = calculateRadialProfile(redContour, redCentroid);
                    
                    shapes.push({
                        phase: 'red',
                        contour: redContour,
                        centroid: redCentroid,
                        area: area,
                        radialProfile: radialProfile
                    });
                }
            }
            
            // Process blue shape with radial sampling
            if (bluePixels.length > 100) {
                const blueContour = extractRadialContour(bluePixels);
                if (blueContour.length > 0) {
                    const blueCentroid = calculateCentroid(blueContour);
                    const area = calculateContourArea(blueContour);
                    const radialProfile = calculateRadialProfile(blueContour, blueCentroid);
                    
                    shapes.push({
                        phase: 'blue',
                        contour: blueContour,
                        centroid: blueCentroid,
                        area: area,
                        radialProfile: radialProfile
                    });
                }
            }
            
            return shapes;
        }
        
        function calculateCentroid(contour) {
            if (contour.length === 0) return { x: CENTER_X, y: CENTER_Y };
            
            const sumX = contour.reduce((sum, p) => sum + p.x, 0);
            const sumY = contour.reduce((sum, p) => sum + p.y, 0);
            
            return {
                x: sumX / contour.length,
                y: sumY / contour.length
            };
        }
        
        function calculateContourArea(contour) {
            if (contour.length < 3) return 0;
            
            // Shoelace formula
            let area = 0;
            for (let i = 0; i < contour.length; i++) {
                const j = (i + 1) % contour.length;
                area += contour[i].x * contour[j].y;
                area -= contour[j].x * contour[i].y;
            }
            
            return Math.abs(area / 2) / (SCALE * SCALE); // Convert to square units
        }
        
        function calculateRadialProfile(contour, centroid) {
            // Calculate variation in radial distance
            const radii = contour.map(p => {
                const dx = p.x - centroid.x;
                const dy = p.y - centroid.y;
                return Math.sqrt(dx * dx + dy * dy);
            });
            
            const meanRadius = radii.reduce((sum, r) => sum + r, 0) / radii.length;
            const variance = radii.reduce((sum, r) => sum + Math.pow(r - meanRadius, 2), 0) / radii.length;
            const stdDev = Math.sqrt(variance);
            
            return {
                mean: meanRadius,
                stdDev: stdDev,
                coefficientOfVariation: stdDev / meanRadius
            };
        }
        
        // ============================================
        // ENHANCED OUTLIER FILTERING
        // ============================================
        
        function filterOutliers(shapes) {
            if (shapes.length < 3) return shapes; // Need at least 3 for meaningful filtering
            
            console.log(`Filtering ${shapes.length} shapes...`);
            
            // Step 1: Remove shapes with extreme areas
            const areas = shapes.map(s => s.area);
            const medianArea = median(areas);
            const areaMAD = medianAbsoluteDeviation(areas);
            
            let filtered = shapes.filter(shape => {
                const areaDiff = Math.abs(shape.area - medianArea);
                return areaDiff < 3 * areaMAD; // Keep within 3 MAD
            });
            
            console.log(`After area filtering: ${filtered.length} shapes`);
            
            // Step 2: Remove shapes with irregular radial profiles
            const cvs = filtered.map(s => s.radialProfile.coefficientOfVariation);
            const medianCV = median(cvs);
            const cvMAD = medianAbsoluteDeviation(cvs);
            
            filtered = filtered.filter(shape => {
                const cvDiff = Math.abs(shape.radialProfile.coefficientOfVariation - medianCV);
                return cvDiff < 3 * cvMAD; // Keep within 3 MAD
            });
            
            console.log(`After radial profile filtering: ${filtered.length} shapes`);
            
            // Step 3: Remove shapes whose centroids are far from median
            const centroidXs = filtered.map(s => s.centroid.x);
            const centroidYs = filtered.map(s => s.centroid.y);
            const medianX = median(centroidXs);
            const medianY = median(centroidYs);
            
            const centroidDistances = filtered.map(s => {
                const dx = s.centroid.x - medianX;
                const dy = s.centroid.y - medianY;
                return Math.sqrt(dx * dx + dy * dy);
            });
            
            const medianDist = median(centroidDistances);
            const distMAD = medianAbsoluteDeviation(centroidDistances);
            
            filtered = filtered.filter((shape, idx) => {
                return centroidDistances[idx] < medianDist + 3 * distMAD;
            });
            
            console.log(`After centroid filtering: ${filtered.length} shapes`);
            
            return filtered;
        }
        
        function median(values) {
            if (values.length === 0) return 0;
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
        }
        
        function medianAbsoluteDeviation(values) {
            const med = median(values);
            const deviations = values.map(v => Math.abs(v - med));
            return median(deviations);
        }
        
        // ============================================
        // AVERAGING WITH SMOOTHING
        // ============================================
        
        function calculateAverageShape(shapes) {
            if (shapes.length === 0) return null;
            
            // Apply outlier filtering
            const filteredShapes = filterOutliers(shapes);
            
            if (filteredShapes.length === 0) return null;
            
            console.log(`Averaging ${filteredShapes.length} shapes (filtered from ${shapes.length})`);
            
            // Calculate average centroid
            const avgCentroid = {
                x: filteredShapes.reduce((sum, s) => sum + s.centroid.x, 0) / filteredShapes.length,
                y: filteredShapes.reduce((sum, s) => sum + s.centroid.y, 0) / filteredShapes.length
            };
            
            // Convert all contours to polar coordinates relative to average centroid
            const numBins = 360;
            const bins = new Array(numBins).fill(null).map(() => []);
            
            filteredShapes.forEach(shape => {
                shape.contour.forEach(point => {
                    const dx = point.x - avgCentroid.x;
                    const dy = point.y - avgCentroid.y;
                    const angle = Math.atan2(dy, dx);
                    const radius = Math.sqrt(dx * dx + dy * dy);
                    
                    let binIndex = Math.floor(((angle + Math.PI) / (2 * Math.PI)) * numBins);
                    binIndex = (binIndex + numBins) % numBins;
                    bins[binIndex].push(radius);
                });
            });
            
            // Create averaged contour with median instead of mean (more robust)
            const avgContour = [];
            for (let i = 0; i < numBins; i++) {
                const angle = (i / numBins) * 2 * Math.PI - Math.PI;
                
                let radius;
                if (bins[i].length > 0) {
                    radius = median(bins[i]); // Use median instead of mean
                } else {
                    // Interpolate from neighbors
                    let prevIdx = (i - 1 + numBins) % numBins;
                    let nextIdx = (i + 1) % numBins;
                    
                    while (bins[prevIdx].length === 0 && prevIdx !== i) {
                        prevIdx = (prevIdx - 1 + numBins) % numBins;
                    }
                    while (bins[nextIdx].length === 0 && nextIdx !== i) {
                        nextIdx = (nextIdx + 1) % numBins;
                    }
                    
                    if (bins[prevIdx].length > 0 && bins[nextIdx].length > 0) {
                        const prevRadius = median(bins[prevIdx]);
                        const nextRadius = median(bins[nextIdx]);
                        radius = (prevRadius + nextRadius) / 2;
                    } else {
                        continue;
                    }
                }
                
                avgContour.push({
                    x: avgCentroid.x + radius * Math.cos(angle),
                    y: avgCentroid.y + radius * Math.sin(angle)
                });
            }
            
            // Apply Gaussian smoothing to the averaged contour
            const smoothedContour = gaussianSmooth(avgContour, 2.0);
            
            // Calculate mean radius in units
            const radii = smoothedContour.map(p => {
                const dx = p.x - avgCentroid.x;
                const dy = p.y - avgCentroid.y;
                return Math.sqrt(dx * dx + dy * dy) / SCALE;
            });
            
            const meanRadius = radii.reduce((sum, r) => sum + r, 0) / radii.length;
            
            return {
                contour: smoothedContour,
                centroid: avgCentroid,
                meanRadius: meanRadius,
                n: filteredShapes.length,
                nTotal: shapes.length
            };
        }
        
        function gaussianSmooth(contour, sigma) {
            const smoothed = [];
            const kernelSize = Math.ceil(sigma * 3);
            
            for (let i = 0; i < contour.length; i++) {
                let sumX = 0, sumY = 0, weightSum = 0;
                
                for (let j = -kernelSize; j <= kernelSize; j++) {
                    const idx = (i + j + contour.length) % contour.length;
                    const weight = Math.exp(-(j * j) / (2 * sigma * sigma));
                    
                    sumX += contour[idx].x * weight;
                    sumY += contour[idx].y * weight;
                    weightSum += weight;
                }
                
                smoothed.push({
                    x: sumX / weightSum,
                    y: sumY / weightSum
                });
            }
            
            return smoothed;
        }
        
        // ============================================
        // DRAWING FUNCTIONS
        // ============================================
        
        function drawCompositeVisualization(canvas, frequency, redShapes, blueShapes, redAvg, blueAvg) {
            const ctx = canvas.getContext('2d');
            
            // Clear with white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            drawGrid(ctx);
            
            // Draw reference head circle (radius = 3 units)
            drawHeadCircle(ctx);
            
            // Draw individual shapes in gray (unfilled contours)
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.3;
            
            // Draw red individual shapes
            redShapes.forEach(shape => {
                if (shape.contour && shape.contour.length > 2) {
                    ctx.beginPath();
                    ctx.moveTo(shape.contour[0].x, shape.contour[0].y);
                    
                    for (let i = 1; i < shape.contour.length; i++) {
                        ctx.lineTo(shape.contour[i].x, shape.contour[i].y);
                    }
                    
                    ctx.closePath();
                    ctx.stroke();
                }
            });
            
            // Draw blue individual shapes
            blueShapes.forEach(shape => {
                if (shape.contour && shape.contour.length > 2) {
                    ctx.beginPath();
                    ctx.moveTo(shape.contour[0].x, shape.contour[0].y);
                    
                    for (let i = 1; i < shape.contour.length; i++) {
                        ctx.lineTo(shape.contour[i].x, shape.contour[i].y);
                    }
                    
                    ctx.closePath();
                    ctx.stroke();
                }
            });
            
            ctx.globalAlpha = 1.0;
            
            // Draw averaged red shape (solid line)
            if (redAvg && redAvg.contour && redAvg.contour.length > 0) {
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                
                ctx.beginPath();
                ctx.moveTo(redAvg.contour[0].x, redAvg.contour[0].y);
                
                for (let i = 1; i < redAvg.contour.length; i++) {
                    ctx.lineTo(redAvg.contour[i].x, redAvg.contour[i].y);
                }
                
                ctx.closePath();
                ctx.stroke();
            }
            
            // Draw averaged blue shape (dashed line)
            if (blueAvg && blueAvg.contour && blueAvg.contour.length > 0) {
                ctx.strokeStyle = '#0000FF';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                
                ctx.beginPath();
                ctx.moveTo(blueAvg.contour[0].x, blueAvg.contour[0].y);
                
                for (let i = 1; i < blueAvg.contour.length; i++) {
                    ctx.lineTo(blueAvg.contour[i].x, blueAvg.contour[i].y);
                }
                
                ctx.closePath();
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Add frequency label
            ctx.fillStyle = 'black';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(frequency, canvas.width / 2, 40);
            
            // Add statistics
            const redN = redAvg ? `${redAvg.n}/${redAvg.nTotal}` : '0';
            const blueN = blueAvg ? `${blueAvg.n}/${blueAvg.nTotal}` : '0';
            const meanRadius = redAvg ? redAvg.meanRadius.toFixed(2) : 
                              (blueAvg ? blueAvg.meanRadius.toFixed(2) : '0.00');
            
            ctx.font = '14px Arial';
            ctx.fillText(`Red: ${redN} | Blue: ${blueN} | Mean r=${meanRadius}`, canvas.width / 2, canvas.height - 20);
        }
        
        function drawGrid(ctx) {
            const size = CANVAS_SIZE;
            const gridSize = size / (2 * GRID_RANGE);
            
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            
            // Grid lines
            for (let i = 0; i <= 2 * GRID_RANGE; i++) {
                const pos = i * gridSize;
                
                ctx.beginPath();
                ctx.moveTo(pos, 0);
                ctx.lineTo(pos, size);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, pos);
                ctx.lineTo(size, pos);
                ctx.stroke();
            }
            
            // Center axes
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(size / 2, 0);
            ctx.lineTo(size / 2, size);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(0, size / 2);
            ctx.lineTo(size, size / 2);
            ctx.stroke();
        }
        
        function drawHeadCircle(ctx) {
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            ctx.setLineDash([]);
            
            ctx.beginPath();
            ctx.arc(CENTER_X, CENTER_Y, HEAD_CIRCLE_RADIUS * SCALE, 0, 2 * Math.PI);
            ctx.stroke();
        }
        
        // ============================================
        // FILE PROCESSING
        // ============================================
        
        async function loadImagesFromZip(file) {
            const zip = await JSZip.loadAsync(file);
            const imageFiles = [];
            
            zip.forEach((relativePath, zipEntry) => {
                if (!zipEntry.dir && (relativePath.toLowerCase().endsWith('.png') || 
                                     relativePath.toLowerCase().endsWith('.jpg') ||
                                     relativePath.toLowerCase().endsWith('.jpeg'))) {
                    imageFiles.push({ path: relativePath, entry: zipEntry });
                }
            });
            
            const images = [];
            for (const file of imageFiles) {
                const blob = await file.entry.async('blob');
                const imageData = await loadImage(blob);
                images.push({ filename: file.path, imageData: imageData });
            }
            
            return images;
        }
        
        function loadImage(blob) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const url = URL.createObjectURL(blob);
                
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    URL.revokeObjectURL(url);
                    resolve(imageData);
                };
                
                img.onerror = reject;
                img.src = url;
            });
        }
        
        function updateProgress(percent, text) {
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            
            progressBar.style.width = percent + '%';
            progressText.textContent = text;
        }
        
        // ============================================
        // MAIN ANALYSIS
        // ============================================
        
        async function analyzeImages(zipFile) {
            try {
                document.getElementById('progress-container').classList.remove('hidden');
                updateProgress(10, 'Loading images from ZIP...');
                
                const images = await loadImagesFromZip(zipFile);
                console.log(`Loaded ${images.length} images`);
                
                updateProgress(30, 'Extracting shapes from images...');
                
                // Group shapes by frequency
                const shapesByFreq = {};
                FREQUENCIES.forEach(freq => {
                    shapesByFreq[freq] = { red: [], blue: [] };
                });
                
                images.forEach((img, idx) => {
                    const shapes = extractShapesFromImage(img.imageData, img.filename);
                    
                    // Determine frequency from filename
                    let freq = null;
                    for (const f of FREQUENCIES) {
                        if (img.filename.includes(f)) {
                            freq = f;
                            break;
                        }
                    }
                    
                    if (freq) {
                        shapes.forEach(shape => {
                            if (shape.phase === 'red') {
                                shapesByFreq[freq].red.push(shape);
                            } else if (shape.phase === 'blue') {
                                shapesByFreq[freq].blue.push(shape);
                            }
                        });
                    }
                    
                    const progress = 30 + (idx / images.length) * 40;
                    updateProgress(progress, `Processing image ${idx + 1}/${images.length}...`);
                });
                
                updateProgress(70, 'Creating composite visualizations...');
                
                // Create composites
                const vizGrid = document.getElementById('visualization-grid');
                vizGrid.innerHTML = '';
                
                FREQUENCIES.forEach((freq, idx) => {
                    const redShapes = shapesByFreq[freq].red;
                    const blueShapes = shapesByFreq[freq].blue;
                    
                    console.log(`\nFrequency ${freq}Hz: ${redShapes.length} red shapes, ${blueShapes.length} blue shapes`);
                    
                    const redAvg = redShapes.length > 0 ? calculateAverageShape(redShapes) : null;
                    const blueAvg = blueShapes.length > 0 ? calculateAverageShape(blueShapes) : null;
                    
                    // Create canvas
                    const canvas = document.createElement('canvas');
                    canvas.width = CANVAS_SIZE;
                    canvas.height = CANVAS_SIZE;
                    
                    drawCompositeVisualization(canvas, freq + ' Hz', redShapes, blueShapes, redAvg, blueAvg);
                    
                    // Create container
                    const container = document.createElement('div');
                    container.className = 'canvas-container p-4';
                    container.style.cursor = 'pointer';
                    
                    canvas.style.width = '100%';
                    canvas.style.height = 'auto';
                    
                    container.appendChild(canvas);
                    
                    // Add click to download
                    container.addEventListener('click', () => {
                        const link = document.createElement('a');
                        link.download = `composite_${freq}Hz.png`;
                        link.href = canvas.toDataURL();
                        link.click();
                    });
                    
                    vizGrid.appendChild(container);
                    
                    const progress = 70 + ((idx + 1) / FREQUENCIES.length) * 25;
                    updateProgress(progress, `Creating composite ${idx + 1}/${FREQUENCIES.length}...`);
                });
                
                updateProgress(100, 'Analysis complete!');
                
                // Show results
                document.getElementById('visualization-container').classList.remove('hidden');
                
                setTimeout(() => {
                    document.getElementById('progress-container').classList.add('hidden');
                }, 2000);
                
            } catch (error) {
                console.error('Analysis error:', error);
                alert(`Error: ${error.message}`);
            }
        }
        
        // ============================================
        // INITIALIZATION
        // ============================================
        
        document.getElementById('zipInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                await analyzeImages(file);
            }
        });
        
        console.log('Sound Object Analyzer v9.0 - Ready!');
        console.log('Improvements:');
        console.log('  âœ“ Radial contour extraction (no more worms!)');
        console.log('  âœ“ Enhanced outlier filtering (area, radial profile, centroid)');
        console.log('  âœ“ Gaussian smoothing for averaged contours');
        console.log('  âœ“ Median-based averaging (more robust)');
    </script>
</body>
</html>
