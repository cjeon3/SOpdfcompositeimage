<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sound Object Average Shape Analyzer - Ultra Optimized</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            font-family: ui-sans-serif, system-ui, sans-serif;
            background-color: #f3f4f6;
            zoom: 0.75;
            -moz-transform: scale(0.75);
            -moz-transform-origin: 0 0;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .canvas-container {
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        
        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
        }
        
        /* Mobile optimizations - Full screen width */
        @media (max-width: 768px) {
            body {
                zoom: 1;
                -moz-transform: scale(1);
                padding: 0.75rem;
                width: 100vw;
            }
            
            .analysis-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .max-w-7xl {
                max-width: 100%;
                width: 100%;
                padding: 0;
                margin: 0;
            }
            
            /* Make all containers full width on mobile */
            .bg-white, .bg-gradient-to-r {
                width: 100%;
                box-sizing: border-box;
            }
            
            /* Larger touch targets */
            button {
                min-height: 44px;
                touch-action: manipulation;
            }
            
            /* File input touch-friendly */
            input[type="file"] {
                font-size: 16px; /* Prevents zoom on iOS */
            }
        }
        
        /* Tablet optimizations - Full screen width */
        @media (min-width: 769px) and (max-width: 1024px) {
            body {
                zoom: 0.9;
                -moz-transform: scale(0.9);
                -moz-transform-origin: 0 0;
                width: 100vw;
                padding: 1rem;
            }
            
            .analysis-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .max-w-7xl {
                max-width: 100%;
                width: 100%;
            }
            
            button {
                min-height: 40px;
            }
        }
        
        /* Large desktop */
        @media (min-width: 1920px) {
            body {
                zoom: 0.8;
                -moz-transform: scale(0.8);
            }
        }
        
        .performance-metric {
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .batch-item {
            transition: all 0.3s ease;
        }
        
        .progress-bar-fill {
            transition: width 0.2s ease-out;
        }
        
        /* Prevent horizontal scroll */
        * {
            box-sizing: border-box;
        }
        
        html {
            overflow-x: hidden;
        }
    </style>
</head>
<body class="p-4 md:p-8">
    
    <div class="max-w-7xl mx-auto">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-2xl sm:text-3xl lg:text-4xl font-extrabold text-blue-800 mb-2">
                Sound Object Average Shape Analyzer
                <span class="inline-block ml-2 px-3 py-1 text-xs font-bold bg-gradient-to-r from-purple-500 to-pink-600 text-white rounded-full shadow-lg animate-pulse">‚ö° ULTRA OPTIMIZED</span>
            </h1>
            <p class="text-lg sm:text-xl font-semibold text-gray-600">UCI Hearing & Speech Lab</p>
            <p class="text-xs sm:text-sm text-gray-500 mt-2">Import participant drawings and generate averaged visualizations</p>
            <div class="mt-3 flex justify-center gap-2 text-xs flex-wrap px-2">
                <span class="px-2 sm:px-3 py-1 bg-purple-100 text-purple-700 rounded-full border border-purple-300">üöÄ Web Workers</span>
                <span class="px-2 sm:px-3 py-1 bg-blue-100 text-blue-700 rounded-full border border-blue-300">‚ö° Parallel Processing</span>
                <span class="px-2 sm:px-3 py-1 bg-green-100 text-green-700 rounded-full border border-green-300">üíæ Memory Optimized</span>
                <span class="px-2 sm:px-3 py-1 bg-amber-100 text-amber-700 rounded-full border border-amber-300">üìä Real-time Monitoring</span>
                <span class="px-2 sm:px-3 py-1 bg-indigo-100 text-indigo-700 rounded-full border border-indigo-300">üéØ Exact Calculations</span>
            </div>
        </header>
        
        <!-- Performance Dashboard -->
        <div id="performance-dashboard" class="hidden bg-gradient-to-r from-purple-50 to-pink-50 p-4 sm:p-6 rounded-xl shadow-lg mb-6 border-2 border-purple-200">
            <h2 class="text-lg sm:text-xl font-bold text-purple-800 mb-4 flex items-center gap-2">
                <svg class="w-5 h-5 sm:w-6 sm:h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                </svg>
                Real-Time Performance Metrics
            </h2>
            <div class="grid grid-cols-2 lg:grid-cols-5 gap-3 sm:gap-4">
                <div class="bg-white p-3 sm:p-4 rounded-lg shadow">
                    <div class="text-xs text-gray-500 font-semibold mb-1">Processing Speed</div>
                    <div id="speed-metric" class="text-xl sm:text-2xl font-bold text-purple-600 performance-metric">0 img/s</div>
                </div>
                <div class="bg-white p-3 sm:p-4 rounded-lg shadow">
                    <div class="text-xs text-gray-500 font-semibold mb-1">Time Elapsed</div>
                    <div id="elapsed-metric" class="text-xl sm:text-2xl font-bold text-indigo-600 performance-metric">0s</div>
                </div>
                <div class="bg-white p-3 sm:p-4 rounded-lg shadow">
                    <div class="text-xs text-gray-500 font-semibold mb-1">Time Remaining</div>
                    <div id="eta-metric" class="text-xl sm:text-2xl font-bold text-blue-600 performance-metric">--</div>
                </div>
                <div class="bg-white p-3 sm:p-4 rounded-lg shadow">
                    <div class="text-xs text-gray-500 font-semibold mb-1">Workers Active</div>
                    <div id="workers-metric" class="text-xl sm:text-2xl font-bold text-green-600 performance-metric">0</div>
                </div>
                <div class="bg-white p-3 sm:p-4 rounded-lg shadow" id="memory-container">
                    <div class="text-xs text-gray-500 font-semibold mb-1">Memory Used</div>
                    <div id="memory-metric" class="text-xl sm:text-2xl font-bold text-orange-600 performance-metric">-- MB</div>
                </div>
            </div>
        </div>
        
        <!-- Instructions -->
        <div class="bg-gradient-to-r from-blue-50 to-indigo-50 p-4 sm:p-6 rounded-xl shadow-lg mb-6 border border-blue-200">
            <h2 class="text-lg sm:text-xl font-bold text-blue-800 mb-4 flex items-center gap-2">
                <svg class="w-5 h-5 sm:w-6 sm:h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
                How to Use
            </h2>
            <ol class="list-decimal list-inside space-y-2 text-sm sm:text-base text-gray-700">
                <li><strong>Upload Files:</strong> Select PNG files OR ZIP files (even nested ZIPs!) from the Sound Object tool</li>
                <li><strong>Automatic Extraction:</strong> ZIP files are automatically unpacked to find all PNG images inside</li>
                <li><strong>Automatic Detection:</strong>
                    <ul class="list-disc list-inside ml-6 mt-1 space-y-1">
                        <li><strong>Participant ID & Frequency:</strong> Extracted from filename (e.g., "P-001_125Hz_90dB.png")</li>
                        <li><strong>Phase (Red/Blue):</strong> Detected by analyzing pixel colors in the image (red pixels = in-phase, blue pixels = out-of-phase)</li>
                    </ul>
                </li>
                <li><strong>Process Data:</strong> Click "Analyze & Generate Visualizations" - now with parallel processing!</li>
                <li><strong>View & Export:</strong> See averaged shapes with statistics, download publication-ready figures</li>
            </ol>
            <p class="mt-4 text-xs sm:text-sm text-blue-700 font-semibold">
                üìù Expected filename format: <code class="bg-white px-2 py-1 rounded">ParticipantID_FrequencyHz_dBdB.png</code> (e.g., P-001_125Hz_90dB.png)
            </p>
            <p class="mt-2 text-xs sm:text-sm text-amber-700 font-semibold bg-amber-50 p-3 rounded-lg border border-amber-200">
                üé® <strong>Phase Detection:</strong> Red and blue phases are automatically separated by analyzing pixel colors in each image. Each image can contain both red (in-phase) and blue (out-of-phase) drawings, which are processed independently.
            </p>
            <p class="mt-2 text-xs sm:text-sm text-green-700 font-semibold bg-green-50 p-3 rounded-lg border border-green-200">
                üì¶ <strong>ZIP Support:</strong> Upload one big ZIP file containing multiple participant folders (each as their own ZIP). The tool will automatically extract all nested ZIPs and find every PNG file!
            </p>
            <p class="mt-2 text-xs text-purple-700 font-semibold bg-purple-50 p-2 rounded">
                ‚ö° <strong>Ultra-Optimized Performance:</strong> This version uses Web Workers for parallel processing (3 images per CPU core), advanced memory management to minimize garbage collection, and real-time performance monitoring!
            </p>
            <p class="mt-2 text-xs text-green-700 font-semibold bg-green-50 p-2 rounded">
                ‚úÖ <strong>Perfect Consistency:</strong> This analyzer uses the EXACT coordinate system (1000√ó1000px canvas, ¬±10 unit grid), centroid calculation (uniform resampling), and area calculation (pixel-based with brush radius) as the original drawing tool.
            </p>
        </div>
        
        <!-- File Upload Section -->
        <div class="bg-white p-4 sm:p-6 rounded-xl shadow-lg mb-6 border border-gray-100">
            <h2 class="text-xl sm:text-2xl font-bold text-gray-800 mb-4 flex items-center gap-2">
                <svg class="w-6 h-6 sm:w-7 sm:h-7 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                </svg>
                Upload Participant Images
            </h2>
            
            <div class="mb-4">
                <label class="block text-xs sm:text-sm font-semibold text-gray-700 mb-2">
                    Select PNG files OR ZIP files containing PNGs (multiple files/folders allowed)
                </label>
                <input 
                    type="file" 
                    id="image-upload" 
                    accept="image/png,.zip,application/zip" 
                    multiple
                    class="block w-full text-xs sm:text-sm text-gray-700
                        file:mr-4 file:py-2 sm:file:py-3 file:px-4 sm:file:px-6
                        file:rounded-xl file:border-0
                        file:text-xs sm:file:text-sm file:font-bold
                        file:bg-gradient-to-r file:from-blue-500 file:to-indigo-600
                        file:text-white file:cursor-pointer
                        hover:file:from-blue-600 hover:file:to-indigo-700
                        border-2 border-gray-200 rounded-xl
                        hover:border-blue-300 transition-all p-2 sm:p-3 bg-gray-50"
                >
            </div>
            
            <div id="file-list" class="mt-4 text-xs sm:text-sm text-gray-600"></div>
            
            <div class="mt-6 flex flex-col sm:flex-row gap-3">
                <button 
                    id="analyze-btn" 
                    disabled
                    class="flex-1 px-4 sm:px-6 py-2 sm:py-3 rounded-xl font-bold text-sm sm:text-base text-white 
                        bg-gradient-to-r from-purple-500 to-pink-600 
                        hover:from-purple-600 hover:to-pink-700 
                        disabled:from-gray-300 disabled:to-gray-400 
                        disabled:cursor-not-allowed transition-all transform 
                        hover:scale-105 disabled:hover:scale-100 shadow-lg"
                >
                    üöÄ Analyze & Generate Visualizations
                </button>
                
                <button 
                    id="cancel-btn" 
                    class="hidden flex-1 px-4 sm:px-6 py-2 sm:py-3 rounded-xl font-bold text-sm sm:text-base text-white 
                        bg-gradient-to-r from-red-500 to-red-600 
                        hover:from-red-600 hover:to-red-700 
                        disabled:from-gray-400 disabled:to-gray-500 
                        disabled:cursor-not-allowed transition-all shadow-lg"
                >
                    ‚õî Cancel Processing
                </button>
            </div>
        </div>
        
        <!-- Progress Bar with Micro-Progress Tracking -->
        <div id="progress-container" class="hidden bg-white p-6 rounded-xl shadow-lg mb-6">
            <div class="mb-2 flex justify-between items-center">
                <h3 class="text-lg font-bold text-gray-800">Processing Progress</h3>
                <span id="progress-percentage" class="text-sm font-mono font-bold text-purple-600">0%</span>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-4 overflow-hidden shadow-inner">
                <div id="progress-bar" class="progress-bar-fill h-4 bg-gradient-to-r from-purple-500 to-pink-600 rounded-full transition-all shadow-lg" style="width: 0%"></div>
            </div>
            <p id="progress-text" class="mt-2 text-sm text-gray-600 font-semibold"></p>
            
            <!-- Micro-Progress for Current Batch -->
            <div id="batch-progress" class="mt-4 hidden">
                <div class="flex justify-between items-center mb-2">
                    <h4 class="text-sm font-bold text-gray-700">Current Batch Progress</h4>
                    <button 
                        id="toggle-batch-details" 
                        class="text-xs px-3 py-1 bg-blue-100 text-blue-700 rounded-full hover:bg-blue-200 transition-all"
                    >
                        Show Details
                    </button>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-3 overflow-hidden shadow-inner">
                    <div id="batch-progress-bar" class="progress-bar-fill h-3 bg-gradient-to-r from-blue-500 to-indigo-600 rounded-full" style="width: 0%"></div>
                </div>
                <div id="batch-details" class="mt-3 space-y-2 max-h-64 overflow-y-auto hidden"></div>
            </div>
        </div>
        
        <!-- Data Summary -->
        <div id="data-summary" class="hidden bg-white p-6 rounded-xl shadow-lg mb-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Analysis Summary</h2>
            <div id="summary-content" class="grid grid-cols-1 md:grid-cols-3 gap-4"></div>
        </div>
        
        <!-- Visualization Results -->
        <div id="visualization-container" class="hidden mb-6">
            <div class="bg-white p-6 rounded-xl shadow-lg mb-4">
                <h2 class="text-2xl font-bold text-gray-800 mb-2">Averaged Shape Visualizations</h2>
                <p class="text-sm text-gray-600 mb-4">Click on any figure to download as PNG</p>
            </div>
            <div id="visualization-grid" class="analysis-grid"></div>
        </div>
        
        <!-- Statistics Table -->
        <div id="statistics-container" class="hidden bg-white p-6 rounded-xl shadow-lg mb-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Statistical Summary</h2>
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gradient-to-r from-blue-50 to-indigo-50">
                        <tr>
                            <th class="px-4 py-3 text-left text-xs font-bold text-gray-700 uppercase tracking-wider">Frequency</th>
                            <th class="px-4 py-3 text-left text-xs font-bold text-gray-700 uppercase tracking-wider">Phase</th>
                            <th class="px-4 py-3 text-left text-xs font-bold text-gray-700 uppercase tracking-wider">N</th>
                            <th class="px-4 py-3 text-left text-xs font-bold text-gray-700 uppercase tracking-wider">Mean Radius</th>
                            <th class="px-4 py-3 text-left text-xs font-bold text-gray-700 uppercase tracking-wider">SD Radius</th>
                            <th class="px-4 py-3 text-left text-xs font-bold text-gray-700 uppercase tracking-wider">Mean Area</th>
                            <th class="px-4 py-3 text-left text-xs font-bold text-gray-700 uppercase tracking-wider">SD Area</th>
                        </tr>
                    </thead>
                    <tbody id="statistics-body" class="bg-white divide-y divide-gray-200"></tbody>
                </table>
            </div>
        </div>
        
        <!-- Footer -->
        <footer class="text-center text-sm text-gray-500 mt-8 pb-4">
            <p class="font-semibold">UCI Hearing & Speech Lab - Sound Object Average Shape Analyzer v2.0 (Ultra Optimized)</p>
            <p class="mt-1">Parallel Web Worker Processing ‚Ä¢ Advanced Memory Management ‚Ä¢ Real-time Monitoring</p>
        </footer>
    </div>
    
    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        
        const CANVAS_SIZE = 1000;
        const UNIT_RANGE = 10;
        const SCALE_FACTOR = CANVAS_SIZE / (2 * UNIT_RANGE);
        const BACKGROUND_CIRCLE_RADIUS_UNITS = 3;
        const FREQUENCIES = [31, 62.5, 125, 250, 500, 1000, 2000, 4000, 8000, 12000, 16000];
        
        // Detect CPU cores for optimal parallelization
        const CPU_CORES = navigator.hardwareConcurrency || 4;
        const IMAGES_PER_WORKER = 3; // Process 3 images per worker
        const MAX_PARALLEL_WORKERS = CPU_CORES;
        
        let participantData = {};
        let processingCancelled = false;
        let activeWorkers = new Set();
        let workerPool = [];
        
        // Performance tracking
        let processingStats = {
            startTime: 0,
            totalImages: 0,
            processedImages: 0,
            workersActive: 0
        };
        
        // Memory management - Canvas pool with better reuse
        const canvasPool = [];
        const MAX_POOL_SIZE = Math.min(20, MAX_PARALLEL_WORKERS * 2); // 2 canvases per worker
        
        function getCanvas() {
            if (canvasPool.length > 0) {
                return canvasPool.pop();
            }
            const canvas = document.createElement('canvas');
            canvas.width = CANVAS_SIZE;
            canvas.height = CANVAS_SIZE;
            return canvas;
        }
        
        function releaseCanvas(canvas) {
            if (canvasPool.length < MAX_POOL_SIZE) {
                // Clear canvas for reuse
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                canvasPool.push(canvas);
            }
        }
        
        // Memory-efficient ImageData reuse
        let imageDataPool = [];
        const MAX_IMAGEDATA_POOL = MAX_PARALLEL_WORKERS * 2;
        
        function getImageData(ctx) {
            if (imageDataPool.length > 0) {
                return imageDataPool.pop();
            }
            return ctx.createImageData(CANVAS_SIZE, CANVAS_SIZE);
        }
        
        function releaseImageData(imageData) {
            if (imageDataPool.length < MAX_IMAGEDATA_POOL) {
                imageDataPool.push(imageData);
            }
        }
        
        // ============================================
        // WEB WORKER CODE (Inline) - FIXED REGEX
        // ============================================
        
        const workerCode = `
            const CANVAS_SIZE = 1000;
            const UNIT_RANGE = 10;
            const SCALE_FACTOR = CANVAS_SIZE / (2 * UNIT_RANGE);
            
            function canvasToUnit(canvasX, canvasY) {
                const centerX = CANVAS_SIZE / 2;
                const centerY = CANVAS_SIZE / 2;
                return {
                    x: (canvasX - centerX) / SCALE_FACTOR,
                    y: (centerY - canvasY) / SCALE_FACTOR
                };
            }
            
            function unitToCanvas(unitX, unitY, canvasSize = CANVAS_SIZE) {
                const center = canvasSize / 2;
                const scale = canvasSize / (2 * UNIT_RANGE);
                return {
                    x: center + (unitX * scale),
                    y: center - (unitY * scale)
                };
            }
            
            function calculateGeometricCentroid(pixels) {
                if (pixels.length === 0) return { x: 0, y: 0 };
                
                const points = pixels.map(p => canvasToUnit(p.x, p.y));
                
                const totalPathLength = (points.length - 1) * 1.0;
                const numSamples = Math.max(100, Math.floor(totalPathLength * 10));
                const sampledPoints = [];
                
                for (let i = 0; i < numSamples; i++) {
                    const t = i / numSamples;
                    const exactIndex = t * (points.length - 1);
                    const lowerIndex = Math.floor(exactIndex);
                    const upperIndex = Math.min(lowerIndex + 1, points.length - 1);
                    const localT = exactIndex - lowerIndex;
                    
                    const p1 = points[lowerIndex];
                    const p2 = points[upperIndex];
                    
                    sampledPoints.push({
                        x: p1.x + (p2.x - p1.x) * localT,
                        y: p1.y + (p2.y - p1.y) * localT
                    });
                }
                
                let sumX = 0, sumY = 0;
                for (const p of sampledPoints) {
                    sumX += p.x;
                    sumY += p.y;
                }
                
                return {
                    x: sumX / sampledPoints.length,
                    y: sumY / sampledPoints.length
                };
            }
            
            function isShapeClosed(points, threshold = 0.5) {
                if (points.length < 3) return false;
                const first = points[0];
                const last = points[points.length - 1];
                const dx = last.x - first.x;
                const dy = last.y - first.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < threshold;
            }
            
            function distanceToSegment(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                
                if (lenSq !== 0) param = dot / lenSq;
                
                let xx, yy;
                
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }
                
                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            function fillContourGaps(bins, avgRadius) {
                // Fill gaps in angular bins by interpolating from neighboring bins
                // This helps with incomplete shapes due to red/blue overlap
                const maxGapSize = 20; // Maximum gap size to fill (in bins)
                
                for (let i = 0; i < bins.length; i++) {
                    if (bins[i].maxRadius > 0) continue; // Already has data
                    
                    // Find previous and next non-empty bins
                    let prevIdx = -1, nextIdx = -1;
                    let gapSize = 0;
                    
                    // Search backward
                    for (let j = 1; j <= maxGapSize; j++) {
                        const idx = (i - j + bins.length) % bins.length;
                        if (bins[idx].maxRadius > 0) {
                            prevIdx = idx;
                            break;
                        }
                    }
                    
                    // Search forward
                    for (let j = 1; j <= maxGapSize; j++) {
                        const idx = (i + j) % bins.length;
                        if (bins[idx].maxRadius > 0) {
                            nextIdx = idx;
                            gapSize = j;
                            break;
                        }
                    }
                    
                    // If we found both neighbors, interpolate
                    if (prevIdx !== -1 && nextIdx !== -1 && gapSize <= maxGapSize) {
                        const prevRadius = bins[prevIdx].maxRadius;
                        const nextRadius = bins[nextIdx].maxRadius;
                        
                        // Use smooth interpolation (cubic for natural curves)
                        const totalGap = gapSize + 1;
                        let distFromPrev = 1;
                        for (let k = prevIdx + 1; k !== nextIdx; k = (k + 1) % bins.length) {
                            if (bins[k].maxRadius === 0) {
                                const t = distFromPrev / totalGap;
                                // Cubic interpolation for smoother curves
                                const smoothT = t * t * (3 - 2 * t);
                                const interpRadius = prevRadius + (nextRadius - prevRadius) * smoothT;
                                
                                const angle = (k / bins.length) * 2 * Math.PI - Math.PI;
                                bins[k].maxRadius = interpRadius;
                                bins[k].point = {
                                    x: interpRadius * Math.cos(angle),
                                    y: interpRadius * Math.sin(angle)
                                };
                            }
                            distFromPrev++;
                        }
                    } else if (prevIdx !== -1 || nextIdx !== -1) {
                        // If only one neighbor, use average radius
                        const refRadius = prevIdx !== -1 ? bins[prevIdx].maxRadius : bins[nextIdx].maxRadius;
                        const interpRadius = avgRadius > 0 ? avgRadius : refRadius;
                        
                        const angle = (i / bins.length) * 2 * Math.PI - Math.PI;
                        bins[i].maxRadius = interpRadius;
                        bins[i].point = {
                            x: interpRadius * Math.cos(angle),
                            y: interpRadius * Math.sin(angle)
                        };
                    }
                }
                
                return bins;
            }
            
            function isPointInPolygon(x, y, polygon) {
                let inside = false;
                for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                    const xi = polygon[i].x, yi = polygon[i].y;
                    const xj = polygon[j].x, yj = polygon[j].y;
                    
                    const intersect = ((yi > y) !== (yj > y)) &&
                        (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }
            
            function calculatePixelBasedArea(unitPoints, brushSize = 5, resolution = null) {
                if (unitPoints.length === 0) return 0;
                
                const isClosed = isShapeClosed(unitPoints);
                const fullBrushRadius = brushSize / SCALE_FACTOR / 2;
                const brushRadius = fullBrushRadius;
                
                if (resolution === null) {
                    if (brushRadius < 0.05) {
                        resolution = 0.05;
                    } else if (brushRadius < 0.1) {
                        resolution = 0.075;
                    } else {
                        resolution = 0.1;
                    }
                }
                
                let minX = unitPoints[0].x, maxX = unitPoints[0].x;
                let minY = unitPoints[0].y, maxY = unitPoints[0].y;
                
                for (const p of unitPoints) {
                    minX = Math.min(minX, p.x);
                    maxX = Math.max(maxX, p.x);
                    minY = Math.min(minY, p.y);
                    maxY = Math.max(maxY, p.y);
                }
                
                minX -= brushRadius;
                maxX += brushRadius;
                minY -= brushRadius;
                maxY += brushRadius;
                
                let paintedCells = 0;
                
                for (let x = minX; x <= maxX; x += resolution) {
                    for (let y = minY; y <= maxY; y += resolution) {
                        let isPainted = false;
                        
                        if (isClosed) {
                            if (isPointInPolygon(x, y, unitPoints)) {
                                isPainted = true;
                            } else {
                                for (let i = 0; i < unitPoints.length - 1; i++) {
                                    const p1 = unitPoints[i];
                                    const p2 = unitPoints[i + 1];
                                    const dist = distanceToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                                    if (dist <= brushRadius) {
                                        isPainted = true;
                                        break;
                                    }
                                }
                            }
                        } else {
                            for (let i = 0; i < unitPoints.length - 1; i++) {
                                const p1 = unitPoints[i];
                                const p2 = unitPoints[i + 1];
                                const dist = distanceToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                                if (dist <= brushRadius) {
                                    isPainted = true;
                                    break;
                                }
                            }
                        }
                        
                        if (isPainted) {
                            paintedCells++;
                        }
                    }
                }
                
                const cellArea = resolution * resolution;
                const totalArea = paintedCells * cellArea;
                
                let adjustedArea = totalArea;
                
                if (isClosed) {
                    let perimeter = 0;
                    for (let i = 0; i < unitPoints.length; i++) {
                        const p1 = unitPoints[i];
                        const p2 = unitPoints[(i + 1) % unitPoints.length];
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        perimeter += Math.sqrt(dx * dx + dy * dy);
                    }
                    
                    const outlineArea = perimeter * (brushRadius * 2) * 0.50;
                    adjustedArea = Math.max(0, totalArea - outlineArea);
                }
                
                return adjustedArea;
            }
            
            function extractContours(imageData) {
                const width = imageData.width;
                const height = imageData.height;
                const data = imageData.data;
                
                // Quick bounds detection
                let minX = width, maxX = 0, minY = height, maxY = 0;
                let hasContent = false;
                
                for (let y = 0; y < height; y += 10) {
                    for (let x = 0; x < width; x += 10) {
                        const idx = (y * width + x) * 4;
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        const a = data[idx + 3];
                        
                        if (a > 128 && !(r > 240 && g > 240 && b > 240)) {
                            minX = Math.min(minX, x);
                            maxX = Math.max(maxX, x);
                            minY = Math.min(minY, y);
                            maxY = Math.max(maxY, y);
                            hasContent = true;
                        }
                    }
                }
                
                if (!hasContent) return null;
                
                minX = Math.max(0, minX - 20);
                maxX = Math.min(width, maxX + 20);
                minY = Math.max(0, minY - 20);
                maxY = Math.min(height, maxY + 20);
                
                const redPixels = [];
                const bluePixels = [];
                const whiteThreshold = 240;
                const grayMin = 140;
                const grayMax = 200;
                const grayColorDiff = 20;
                const alphaThreshold = 128;
                
                // Enhanced color separation thresholds
                const RED_THRESHOLD = 30;  // r must be at least 30 more than b
                const BLUE_THRESHOLD = 30; // b must be at least 30 more than r
                
                for (let y = minY; y < maxY; y++) {
                    for (let x = minX; x < maxX; x++) {
                        const idx = (y * width + x) * 4;
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        const a = data[idx + 3];
                        
                        if (a <= alphaThreshold) continue;
                        if (r > whiteThreshold && g > whiteThreshold && b > whiteThreshold) continue;
                        
                        if (r >= grayMin && r <= grayMax) {
                            const rgDiff = Math.abs(r - g);
                            if (rgDiff < grayColorDiff) {
                                const gbDiff = Math.abs(g - b);
                                if (gbDiff < grayColorDiff) continue;
                            }
                        }
                        
                        // Enhanced red/blue separation with stronger thresholds
                        const rbDiff = r - b;
                        
                        if (rbDiff > RED_THRESHOLD) {
                            // Clearly red pixel
                            redPixels.push({ x, y, r, g, b });
                        } else if (rbDiff < -BLUE_THRESHOLD) {
                            // Clearly blue pixel
                            bluePixels.push({ x, y, r, g, b });
                        } else {
                            // Ambiguous - use secondary criteria
                            // Check saturation and hue to make better decision
                            const maxChannel = Math.max(r, g, b);
                            const minChannel = Math.min(r, g, b);
                            const saturation = maxChannel > 0 ? (maxChannel - minChannel) / maxChannel : 0;
                            
                            if (saturation > 0.3) {
                                // High saturation - use stronger color indicator
                                if (r > b && r > g * 0.8) {
                                    redPixels.push({ x, y, r, g, b });
                                } else if (b > r && b > g * 0.8) {
                                    bluePixels.push({ x, y, r, g, b });
                                }
                            }
                        }
                    }
                }
                
                // Process each color separately
                const results = [];
                
                if (redPixels.length > 0) {
                    const centroid = calculateGeometricCentroid(redPixels);
                    const unitPoints = redPixels.map(p => canvasToUnit(p.x, p.y));
                    const estimatedBrushSize = 5;
                    const area = calculatePixelBasedArea(unitPoints, estimatedBrushSize);
                    
                    const numBins = 180;
                    const bins = Array(numBins).fill(null).map(() => ({ maxRadius: 0, point: null }));
                    
                    unitPoints.forEach(point => {
                        const dx = point.x - centroid.x;
                        const dy = point.y - centroid.y;
                        const angle = Math.atan2(dy, dx);
                        const radius = Math.sqrt(dx * dx + dy * dy);
                        
                        let binIndex = Math.floor(((angle + Math.PI) / (2 * Math.PI)) * numBins);
                        binIndex = (binIndex + numBins) % numBins;
                        
                        if (radius > bins[binIndex].maxRadius) {
                            bins[binIndex].maxRadius = radius;
                            // Store point RELATIVE to centroid
                            bins[binIndex].point = { x: dx, y: dy };
                        }
                    });
                    
                    // Calculate initial average radius for gap filling
                    const radii = bins.filter(bin => bin.maxRadius > 0).map(bin => bin.maxRadius);
                    const avgRadius = radii.length > 0 ? radii.reduce((sum, r) => sum + r, 0) / radii.length : 0;
                    
                    // NOTE: Gap filling temporarily disabled - was causing worker crashes
                    // fillContourGaps(bins, avgRadius);
                    
                    const contour = bins
                        .filter(bin => bin.point !== null)
                        .map(bin => bin.point);
                    
                    results.push({
                        phase: 'red',
                        centroid,
                        contour,
                        avgRadius,
                        area,
                        allPoints: unitPoints
                    });
                }
                
                if (bluePixels.length > 0) {
                    const centroid = calculateGeometricCentroid(bluePixels);
                    const unitPoints = bluePixels.map(p => canvasToUnit(p.x, p.y));
                    const estimatedBrushSize = 5;
                    const area = calculatePixelBasedArea(unitPoints, estimatedBrushSize);
                    
                    const numBins = 180;
                    const bins = Array(numBins).fill(null).map(() => ({ maxRadius: 0, point: null }));
                    
                    unitPoints.forEach(point => {
                        const dx = point.x - centroid.x;
                        const dy = point.y - centroid.y;
                        const angle = Math.atan2(dy, dx);
                        const radius = Math.sqrt(dx * dx + dy * dy);
                        
                        let binIndex = Math.floor(((angle + Math.PI) / (2 * Math.PI)) * numBins);
                        binIndex = (binIndex + numBins) % numBins;
                        
                        if (radius > bins[binIndex].maxRadius) {
                            bins[binIndex].maxRadius = radius;
                            // Store point RELATIVE to centroid
                            bins[binIndex].point = { x: dx, y: dy };
                        }
                    });
                    
                    // Calculate initial average radius for gap filling
                    const radii = bins.filter(bin => bin.maxRadius > 0).map(bin => bin.maxRadius);
                    const avgRadius = radii.length > 0 ? radii.reduce((sum, r) => sum + r, 0) / radii.length : 0;
                    
                    // NOTE: Gap filling temporarily disabled - was causing worker crashes
                    // fillContourGaps(bins, avgRadius);
                    
                    const contour = bins
                        .filter(bin => bin.point !== null)
                        .map(bin => bin.point);
                    
                    results.push({
                        phase: 'blue',
                        centroid,
                        contour,
                        avgRadius,
                        area,
                        allPoints: unitPoints
                    });
                }
                
                return results.length > 0 ? results : null;
            }
            
            // Worker message handler with better error handling
            self.onmessage = function(e) {
                try {
                    const { imageData, filename } = e.data;
                    
                    // Validate inputs
                    if (!imageData || !filename) {
                        self.postMessage({ 
                            error: 'Missing imageData or filename', 
                            filename: filename || 'unknown' 
                        });
                        return;
                    }
                    
                    // Parse filename - FIXED REGEX WITHOUT DOUBLE ESCAPING
                    const parts = filename.replace('.png', '').split('_');
                    if (parts.length < 2) {
                        self.postMessage({ 
                            error: 'Invalid filename format', 
                            filename 
                        });
                        return;
                    }
                    
                    const participant = parts[0];
                    // FIXED: Use single backslashes since this is in a string
                    const freqMatch = parts[1].match(/(\\d+\\.?\\d*)Hz/);
                    
                    if (!freqMatch) {
                        self.postMessage({ 
                            error: 'No frequency found in filename', 
                            filename 
                        });
                        return;
                    }
                    
                    const frequency = parseFloat(freqMatch[1]);
                    
                    // Validate frequency
                    if (isNaN(frequency) || frequency <= 0) {
                        self.postMessage({ 
                            error: 'Invalid frequency value', 
                            filename 
                        });
                        return;
                    }
                    
                    // Process image - now returns array of shapes (red and blue)
                    const shapes = extractContours(imageData);
                    
                    if (!shapes || shapes.length === 0) {
                        self.postMessage({ 
                            error: 'No contours found in image', 
                            filename 
                        });
                        return;
                    }
                    
                    // Send result back - now includes multiple shapes
                    self.postMessage({
                        success: true,
                        results: shapes.map(shape => ({
                            participant,
                            frequency,
                            filename,
                            ...shape
                        }))
                    });
                    
                } catch (err) {
                    // Catch any unexpected errors
                    self.postMessage({ 
                        error: err.message || 'Unknown error in worker', 
                        filename: e.data ? e.data.filename : 'unknown',
                        stack: err.stack
                    });
                }
            };
            
            // Handle worker-level errors
            self.onerror = function(err) {
                self.postMessage({ 
                    error: 'Worker error: ' + (err.message || 'Unknown error'),
                    filename: 'unknown'
                });
            };
        `;
        
        // Create blob URL for worker
        const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
        const workerBlobUrl = URL.createObjectURL(workerBlob);
        
        // ============================================
        // WORKER POOL MANAGEMENT
        // ============================================
        
        function createWorker() {
            const worker = new Worker(workerBlobUrl);
            activeWorkers.add(worker);
            updateWorkersMetric();
            return worker;
        }
        
        function terminateWorker(worker) {
            worker.terminate();
            activeWorkers.delete(worker);
            updateWorkersMetric();
        }
        
        function updateWorkersMetric() {
            const metric = document.getElementById('workers-metric');
            if (metric) {
                metric.textContent = activeWorkers.size;
            }
        }
        
        // ============================================
        // PERFORMANCE MONITORING
        // ============================================
        
        function updatePerformanceMetrics() {
            const elapsed = (Date.now() - processingStats.startTime) / 1000;
            const processed = processingStats.processedImages;
            const total = processingStats.totalImages;
            const remaining = total - processed;
            
            // Speed (images per second)
            const speed = processed / elapsed;
            const speedMetric = document.getElementById('speed-metric');
            if (speedMetric && !isNaN(speed) && isFinite(speed)) {
                speedMetric.textContent = `${speed.toFixed(1)} img/s`;
            }
            
            // Elapsed time
            const elapsedMetric = document.getElementById('elapsed-metric');
            if (elapsedMetric && !isNaN(elapsed) && isFinite(elapsed)) {
                if (elapsed < 60) {
                    elapsedMetric.textContent = `${elapsed.toFixed(1)}s`;
                } else {
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = Math.floor(elapsed % 60);
                    elapsedMetric.textContent = `${minutes}m ${seconds}s`;
                }
            }
            
            // ETA (estimated time remaining)
            const eta = remaining / speed;
            const etaMetric = document.getElementById('eta-metric');
            if (etaMetric && !isNaN(eta) && isFinite(eta)) {
                if (eta < 60) {
                    etaMetric.textContent = `${Math.ceil(eta)}s`;
                } else {
                    const minutes = Math.floor(eta / 60);
                    const seconds = Math.ceil(eta % 60);
                    etaMetric.textContent = `${minutes}m ${seconds}s`;
                }
            }
            
            // Memory usage (if available)
            if (performance.memory) {
                const memoryMetric = document.getElementById('memory-metric');
                const usedMB = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1);
                if (memoryMetric) {
                    memoryMetric.textContent = `${usedMB} MB`;
                }
            }
        }
        
        // ============================================
        // COORDINATE SYSTEM FUNCTIONS (EXACT from original)
        // ============================================
        
        function canvasToUnit(canvasX, canvasY) {
            const centerX = CANVAS_SIZE / 2;
            const centerY = CANVAS_SIZE / 2;
            return {
                x: (canvasX - centerX) / SCALE_FACTOR,
                y: (centerY - canvasY) / SCALE_FACTOR
            };
        }
        
        function unitToCanvas(unitX, unitY, canvasSize = CANVAS_SIZE) {
            const center = canvasSize / 2;
            const scale = canvasSize / (2 * UNIT_RANGE);
            return {
                x: center + (unitX * scale),
                y: center - (unitY * scale)
            };
        }
        
        // ============================================
        // UI UPDATE FUNCTIONS
        // ============================================
        
        function updateProgress(percentage, message) {
            const container = document.getElementById('progress-container');
            const bar = document.getElementById('progress-bar');
            const text = document.getElementById('progress-text');
            const percentageText = document.getElementById('progress-percentage');
            
            container.classList.remove('hidden');
            bar.style.width = `${percentage}%`;
            text.textContent = message;
            percentageText.textContent = `${Math.round(percentage)}%`;
            
            // Update performance metrics if processing
            if (processingStats.startTime > 0 && processingStats.processedImages > 0) {
                updatePerformanceMetrics();
            }
        }
        
        function showError(message) {
            const container = document.getElementById('progress-container');
            const bar = document.getElementById('progress-bar');
            const text = document.getElementById('progress-text');
            
            container.classList.remove('hidden');
            bar.style.width = '100%';
            bar.className = 'h-4 bg-gradient-to-r from-red-500 to-red-600 rounded-full transition-all';
            text.textContent = `‚ùå Error: ${message}`;
        }
        
        let currentBatchFiles = [];
        let batchItemStates = [];
        
        function initBatch(filenames) {
            currentBatchFiles = filenames;
            batchItemStates = filenames.map(name => ({ name, status: 'pending', progress: 0 }));
            
            const batchProgress = document.getElementById('batch-progress');
            batchProgress.classList.remove('hidden');
            
            updateBatchDisplay();
        }
        
        function updateBatchItem(index, status, progress) {
            if (index < batchItemStates.length) {
                batchItemStates[index].status = status;
                batchItemStates[index].progress = progress;
                updateBatchDisplay();
            }
        }
        
        function updateBatchDisplay() {
            const batchBar = document.getElementById('batch-progress-bar');
            const totalProgress = batchItemStates.reduce((sum, item) => sum + item.progress, 0);
            const avgProgress = totalProgress / batchItemStates.length;
            batchBar.style.width = `${avgProgress}%`;
            
            const details = document.getElementById('batch-details');
            if (!details.classList.contains('hidden')) {
                details.innerHTML = batchItemStates.map((item, i) => {
                    const statusColors = {
                        'pending': 'bg-gray-100 border-gray-300',
                        'processing': 'bg-blue-50 border-blue-400',
                        'completed': 'bg-green-50 border-green-400',
                        'error': 'bg-red-50 border-red-400'
                    };
                    const statusIcons = {
                        'pending': '‚è≥',
                        'processing': '‚ö°',
                        'completed': '‚úÖ',
                        'error': '‚ùå'
                    };
                    
                    return `
                        <div class="batch-item p-2 rounded border-2 ${statusColors[item.status]}">
                            <div class="flex items-center justify-between">
                                <span class="text-xs font-mono truncate flex-1">${statusIcons[item.status]} ${item.name}</span>
                                <span class="text-xs font-bold ml-2">${item.progress}%</span>
                            </div>
                            <div class="w-full bg-gray-300 rounded-full h-1 mt-1">
                                <div class="h-1 bg-blue-600 rounded-full" style="width: ${item.progress}%"></div>
                            </div>
                        </div>
                    `;
                }).join('');
            }
        }
        
        // Toggle batch details visibility
        document.getElementById('toggle-batch-details').addEventListener('click', function() {
            const details = document.getElementById('batch-details');
            if (details.classList.contains('hidden')) {
                details.classList.remove('hidden');
                this.textContent = 'Hide Details';
            } else {
                details.classList.add('hidden');
                this.textContent = 'Show Details';
            }
        });
        
        // ============================================
        // FILE EXTRACTION (ZIP SUPPORT)
        // ============================================
        
        async function extractPNGsFromZip(zipFile, zipName) {
            const zip = new JSZip();
            const zipData = await zipFile.arrayBuffer();
            const loadedZip = await zip.loadAsync(zipData);
            
            const pngFiles = [];
            
            for (const [filename, file] of Object.entries(loadedZip.files)) {
                if (file.dir) continue;
                
                const lowerName = filename.toLowerCase();
                
                if (lowerName.endsWith('.png')) {
                    const blob = await file.async('blob');
                    const pngFile = new File([blob], filename.split('/').pop(), { type: 'image/png' });
                    pngFiles.push({
                        name: pngFile.name,
                        blob: pngFile,
                        fullPath: `${zipName}/${filename}`
                    });
                }
                else if (lowerName.endsWith('.zip')) {
                    try {
                        const blob = await file.async('blob');
                        const nestedZipFile = new File([blob], filename.split('/').pop(), { type: 'application/zip' });
                        const nestedPNGs = await extractPNGsFromZip(nestedZipFile, `${zipName}/${filename}`);
                        pngFiles.push(...nestedPNGs);
                    } catch (err) {
                        console.error(`Error extracting nested ZIP ${filename}:`, err);
                    }
                }
            }
            
            return pngFiles;
        }
        
        async function processAllFiles(files) {
            const allPNGs = [];
            
            for (const file of files) {
                const lowerName = file.name.toLowerCase();
                
                if (lowerName.endsWith('.png')) {
                    allPNGs.push({
                        name: file.name,
                        blob: file,
                        fullPath: file.name
                    });
                }
                else if (lowerName.endsWith('.zip')) {
                    try {
                        const extractedPNGs = await extractPNGsFromZip(file, file.name);
                        allPNGs.push(...extractedPNGs);
                    } catch (err) {
                        console.error(`Error extracting ${file.name}:`, err);
                    }
                }
            }
            
            return allPNGs;
        }
        
        // ============================================
        // PARALLEL IMAGE PROCESSING WITH WEB WORKERS
        // ============================================
        
        async function processImageWithWorker(file) {
            return new Promise((resolve, reject) => {
                if (processingCancelled) {
                    reject(new Error('Processing cancelled'));
                    return;
                }
                
                const img = new Image();
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    img.onload = () => {
                        if (processingCancelled) {
                            reject(new Error('Processing cancelled'));
                            return;
                        }
                        
                        // Use pooled canvas
                        const canvas = getCanvas();
                        const ctx = canvas.getContext('2d', { 
                            willReadFrequently: true,
                            alpha: false
                        });
                        
                        ctx.drawImage(img, 0, 0, CANVAS_SIZE, CANVAS_SIZE);
                        const imageData = ctx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                        
                        // Return canvas to pool immediately
                        releaseCanvas(canvas);
                        
                        // Create worker and process
                        const worker = createWorker();
                        
                        worker.onmessage = (e) => {
                            terminateWorker(worker);
                            
                            if (e.data.error) {
                                console.error('Worker error for', file.name, ':', e.data.error);
                                reject(new Error(e.data.error));
                            } else {
                                // Now returns array of shapes (red and blue)
                                resolve(e.data.results);
                            }
                        };
                        
                        worker.onerror = (err) => {
                            console.error('Worker crashed for', file.name, ':', err);
                            terminateWorker(worker);
                            reject(new Error('Worker crashed: ' + (err.message || 'Unknown error')));
                        };
                        
                        // Send to worker
                        try {
                            worker.postMessage({
                                imageData: imageData,
                                filename: file.name
                            }, [imageData.data.buffer]); // Transfer ownership for efficiency
                        } catch (err) {
                            console.error('Error posting message to worker:', err);
                            terminateWorker(worker);
                            reject(err);
                        }
                    };
                    
                    img.onerror = () => reject(new Error(`Failed to load image: ${file.name}`));
                    img.src = e.target.result;
                };
                
                reader.onerror = () => reject(new Error(`Failed to read file: ${file.name}`));
                reader.readAsDataURL(file.blob);
            });
        }
        
        // Process images in parallel batches
        async function processBatchParallel(files, batchSize) {
            const results = [];
            
            // Calculate optimal batch size based on cores
            const optimalBatchSize = MAX_PARALLEL_WORKERS * IMAGES_PER_WORKER;
            const actualBatchSize = Math.min(batchSize, optimalBatchSize);
            
            for (let i = 0; i < files.length; i += actualBatchSize) {
                if (processingCancelled) {
                    throw new Error('Processing cancelled by user');
                }
                
                const batch = files.slice(i, Math.min(i + actualBatchSize, files.length));
                
                // Initialize batch progress
                initBatch(batch.map(f => f.name));
                
                // Process entire batch in parallel
                const batchPromises = batch.map(async (file, batchIndex) => {
                    if (processingCancelled) {
                        updateBatchItem(batchIndex, 'error', 0);
                        return null;
                    }
                    
                    try {
                        updateBatchItem(batchIndex, 'processing', 30);
                        
                        const result = await processImageWithWorker(file);
                        
                        updateBatchItem(batchIndex, 'processing', 80);
                        
                        // Small delay to show progress
                        await new Promise(resolve => setTimeout(resolve, 10));
                        
                        updateBatchItem(batchIndex, 'completed', 100);
                        
                        return result;
                    } catch (err) {
                        const errorMsg = err && err.message ? err.message : (err ? String(err) : 'Unknown error');
                        console.warn(`Skipping ${file.name}:`, errorMsg);
                        updateBatchItem(batchIndex, 'error', 0);
                        return null;
                    }
                });
                
                // Wait for all in batch to complete
                const batchResults = await Promise.all(batchPromises);
                
                // Add successful results (filter out nulls from errors)
                results.push(...batchResults.filter(r => r !== null).flat());
                
                // Update global progress
                processingStats.processedImages = i + batch.length;
                const overallProgress = (processingStats.processedImages / processingStats.totalImages) * 100;
                updateProgress(overallProgress, `Processing batch ${Math.floor(i / actualBatchSize) + 1} of ${Math.ceil(files.length / actualBatchSize)}...`);
            }
            
            return results;
        }
        
        // ============================================
        // VISUALIZATION GENERATION
        // ============================================
        
        function drawVisualization(frequency, redData, blueData) {
            const canvas = document.createElement('canvas');
            const vizSize = 600;
            canvas.width = vizSize;
            canvas.height = vizSize;
            const ctx = canvas.getContext('2d');
            
            // White background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, vizSize, vizSize);
            
            const center = vizSize / 2;
            const scale = vizSize / (2 * UNIT_RANGE);
            
            // Draw background circle (3-unit radius)
            ctx.beginPath();
            ctx.arc(center, center, BACKGROUND_CIRCLE_RADIUS_UNITS * scale, 0, 2 * Math.PI);
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw axes
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, center);
            ctx.lineTo(vizSize, center);
            ctx.moveTo(center, 0);
            ctx.lineTo(center, vizSize);
            ctx.stroke();
            
            // Function to draw smooth averaged shape
            function drawShape(dataArray, color, isDashed = false) {
                if (dataArray.length === 0) return;
                
                // Use 360 angular bins for smooth averaging
                const numBins = 360;
                const bins = Array(numBins).fill(null).map(() => []);
                
                // Collect all radii from all participants into angular bins
                dataArray.forEach(d => {
                    // Each contour point is relative to that shape's centroid
                    d.contour.forEach(point => {
                        const angle = Math.atan2(point.y, point.x);
                        const radius = Math.sqrt(point.x * point.x + point.y * point.y);
                        
                        // Map angle [-œÄ, œÄ] to bin index [0, numBins)
                        let binIndex = Math.floor(((angle + Math.PI) / (2 * Math.PI)) * numBins);
                        binIndex = ((binIndex % numBins) + numBins) % numBins; // Handle wrap-around
                        
                        bins[binIndex].push(radius);
                    });
                });
                
                // Calculate average radius for each bin
                const avgRadii = bins.map(bin => {
                    if (bin.length === 0) return null;
                    return bin.reduce((sum, r) => sum + r, 0) / bin.length;
                });
                
                // Fill gaps by interpolating from neighboring bins
                for (let i = 0; i < avgRadii.length; i++) {
                    if (avgRadii[i] !== null) continue;
                    
                    // Find nearest non-null bins
                    let prevIdx = -1, nextIdx = -1;
                    const maxGap = 30;
                    
                    for (let j = 1; j <= maxGap; j++) {
                        const prevI = (i - j + avgRadii.length) % avgRadii.length;
                        if (avgRadii[prevI] !== null) {
                            prevIdx = prevI;
                            break;
                        }
                    }
                    
                    for (let j = 1; j <= maxGap; j++) {
                        const nextI = (i + j) % avgRadii.length;
                        if (avgRadii[nextI] !== null) {
                            nextIdx = nextI;
                            break;
                        }
                    }
                    
                    // Interpolate if we found both neighbors
                    if (prevIdx !== -1 && nextIdx !== -1) {
                        const prevR = avgRadii[prevIdx];
                        const nextR = avgRadii[nextIdx];
                        
                        // Calculate distance from prev (handling wrap-around)
                        let distFromPrev = (i - prevIdx + avgRadii.length) % avgRadii.length;
                        let totalDist = (nextIdx - prevIdx + avgRadii.length) % avgRadii.length;
                        
                        if (totalDist === 0) totalDist = 1;
                        
                        const t = distFromPrev / totalDist;
                        avgRadii[i] = prevR + (nextR - prevR) * t;
                    } else if (prevIdx !== -1) {
                        avgRadii[i] = avgRadii[prevIdx];
                    } else if (nextIdx !== -1) {
                        avgRadii[i] = avgRadii[nextIdx];
                    }
                }
                
                // Convert bins to drawing points
                const points = [];
                for (let i = 0; i < avgRadii.length; i++) {
                    if (avgRadii[i] !== null) {
                        const angle = (i / numBins) * 2 * Math.PI - Math.PI;
                        points.push({
                            x: center + avgRadii[i] * Math.cos(angle) * scale,
                            y: center - avgRadii[i] * Math.sin(angle) * scale
                        });
                    }
                }
                
                if (points.length === 0) return;
                
                // Draw filled shape
                ctx.fillStyle = color + '33'; // More transparent
                ctx.beginPath();
                points.forEach((p, i) => {
                    if (i === 0) {
                        ctx.moveTo(p.x, p.y);
                    } else {
                        ctx.lineTo(p.x, p.y);
                    }
                });
                ctx.closePath();
                ctx.fill();
                
                // Draw outline
                ctx.strokeStyle = color;
                ctx.lineWidth = 2.5;
                if (isDashed) {
                    ctx.setLineDash([8, 5]);
                } else {
                    ctx.setLineDash([]);
                }
                ctx.stroke();
                ctx.setLineDash([]); // Reset
                
                // Draw individual participant shapes as thin gray lines
                ctx.strokeStyle = '#cccccc';
                ctx.lineWidth = 0.8;
                ctx.globalAlpha = 0.3;
                
                dataArray.forEach(d => {
                    if (d.contour.length === 0) return;
                    
                    ctx.beginPath();
                    d.contour.forEach((point, i) => {
                        const x = center + point.x * scale;
                        const y = center - point.y * scale;
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    ctx.closePath();
                    ctx.stroke();
                });
                
                ctx.globalAlpha = 1.0;
            }
            
            // Draw blue shape first (so red is on top)
            if (blueData.length > 0) {
                drawShape(blueData, '#0000ff', true); // Dashed for blue
            }
            
            // Draw red shape
            if (redData.length > 0) {
                drawShape(redData, '#ff0000', false); // Solid for red
            }
            
            // Add title
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`${frequency} Hz`, center, 40);
            
            return canvas;
        }
        
        // ============================================
        // MAIN ANALYSIS FUNCTION
        // ============================================
        
        async function analyzeData(inputFiles) {
            try {
                processingCancelled = false;
                processingStats = {
                    startTime: Date.now(),
                    totalImages: 0,
                    processedImages: 0,
                    workersActive: 0
                };
                
                // Show/hide buttons
                const cancelBtn = document.getElementById('cancel-btn');
                const analyzeBtn = document.getElementById('analyze-btn');
                cancelBtn.classList.remove('hidden');
                analyzeBtn.classList.add('hidden');
                
                // Show performance dashboard
                document.getElementById('performance-dashboard').classList.remove('hidden');
                
                // Process all files (extract ZIPs)
                updateProgress(0, 'Extracting files from ZIPs...');
                const allPNGs = await processAllFiles(inputFiles);
                
                if (allPNGs.length === 0) {
                    throw new Error('No PNG files found in selected files');
                }
                
                processingStats.totalImages = allPNGs.length;
                
                updateProgress(5, `Found ${allPNGs.length} PNG files. Starting parallel processing...`);
                
                // Process all images in parallel batches
                const processedData = await processBatchParallel(allPNGs, 1000);
                
                if (processingCancelled) {
                    throw new Error('Processing cancelled by user');
                }
                
                updateProgress(90, 'Organizing data by frequency...');
                
                // Initialize data structure
                participantData = {};
                FREQUENCIES.forEach(freq => {
                    participantData[freq] = { red: [], blue: [] };
                });
                
                // Organize processed data
                processedData.forEach(result => {
                    const freq = result.frequency;
                    const phase = result.phase;
                    
                    if (participantData[freq]) {
                        participantData[freq][phase].push(result);
                    }
                });
                
                updateProgress(95, 'Generating visualizations...');
                
                // Generate visualizations
                const vizGrid = document.getElementById('visualization-grid');
                vizGrid.innerHTML = '';
                
                FREQUENCIES.forEach(freq => {
                    const redData = participantData[freq].red;
                    const blueData = participantData[freq].blue;
                    
                    if (redData.length === 0 && blueData.length === 0) return;
                    
                    const vizCanvas = drawVisualization(freq, redData, blueData);
                    
                    const container = document.createElement('div');
                    container.className = 'canvas-container p-4 cursor-pointer hover:shadow-xl transition-shadow';
                    container.appendChild(vizCanvas);
                    
                    const info = document.createElement('div');
                    info.className = 'mt-2 text-center text-sm';
                    info.innerHTML = `
                        <p class="font-bold text-gray-800">${freq} Hz</p>
                        <p class="text-xs text-gray-600">
                            <span class="text-red-600">Red: ${redData.length}</span> | 
                            <span class="text-blue-600">Blue: ${blueData.length}</span>
                        </p>
                        <p class="text-xs text-gray-500 mt-1">Click to download</p>
                    `;
                    container.appendChild(info);
                    
                    container.addEventListener('click', () => {
                        const link = document.createElement('a');
                        link.download = `sound_object_avg_${freq}Hz.png`;
                        link.href = vizCanvas.toDataURL();
                        link.click();
                    });
                    
                    vizGrid.appendChild(container);
                });
                
                // Generate statistics
                const statsBody = document.getElementById('statistics-body');
                statsBody.innerHTML = '';
                
                FREQUENCIES.forEach(freq => {
                    const redData = participantData[freq].red;
                    const blueData = participantData[freq].blue;
                    
                    if (redData.length === 0 && blueData.length === 0) return;
                    
                    // Calculate statistics for red
                    if (redData.length > 0) {
                        const redRadii = redData.map(d => d.avgRadius);
                        const redAreas = redData.map(d => d.area);
                        
                        const redAvg = {
                            n: redData.length,
                            meanRadius: redRadii.reduce((sum, r) => sum + r, 0) / redRadii.length,
                            sdRadius: Math.sqrt(redRadii.map(r => Math.pow(r - (redRadii.reduce((sum, r) => sum + r, 0) / redRadii.length), 2)).reduce((sum, v) => sum + v, 0) / redRadii.length),
                            meanArea: redAreas.reduce((sum, a) => sum + a, 0) / redAreas.length,
                            sdArea: Math.sqrt(redAreas.map(a => Math.pow(a - (redAreas.reduce((sum, a) => sum + a, 0) / redAreas.length), 2)).reduce((sum, v) => sum + v, 0) / redAreas.length)
                        };
                        
                        const row = document.createElement('tr');
                        row.className = 'hover:bg-gray-50';
                        row.innerHTML = `
                            <td class="px-4 py-3 text-sm font-semibold">${freq} Hz</td>
                            <td class="px-4 py-3 text-sm"><span class="inline-block w-3 h-3 rounded-full bg-red-500 mr-2"></span>Red (In-Phase)</td>
                            <td class="px-4 py-3 text-sm">${redAvg.n}</td>
                            <td class="px-4 py-3 text-sm font-mono">${redAvg.meanRadius.toFixed(3)}</td>
                            <td class="px-4 py-3 text-sm font-mono">${redAvg.sdRadius.toFixed(3)}</td>
                            <td class="px-4 py-3 text-sm font-mono">${redAvg.meanArea.toFixed(3)}</td>
                            <td class="px-4 py-3 text-sm font-mono">${redAvg.sdArea.toFixed(3)}</td>
                        `;
                        statsBody.appendChild(row);
                    }
                    
                    // Calculate statistics for blue
                    if (blueData.length > 0) {
                        const blueRadii = blueData.map(d => d.avgRadius);
                        const blueAreas = blueData.map(d => d.area);
                        
                        const blueAvg = {
                            n: blueData.length,
                            meanRadius: blueRadii.reduce((sum, r) => sum + r, 0) / blueRadii.length,
                            sdRadius: Math.sqrt(blueRadii.map(r => Math.pow(r - (blueRadii.reduce((sum, r) => sum + r, 0) / blueRadii.length), 2)).reduce((sum, v) => sum + v, 0) / blueRadii.length),
                            meanArea: blueAreas.reduce((sum, a) => sum + a, 0) / blueAreas.length,
                            sdArea: Math.sqrt(blueAreas.map(a => Math.pow(a - (blueAreas.reduce((sum, a) => sum + a, 0) / blueAreas.length), 2)).reduce((sum, v) => sum + v, 0) / blueAreas.length)
                        };
                        
                        const row = document.createElement('tr');
                        row.className = 'hover:bg-gray-50';
                        row.innerHTML = `
                            <td class="px-4 py-3 text-sm font-semibold">${freq} Hz</td>
                            <td class="px-4 py-3 text-sm"><span class="inline-block w-3 h-3 rounded-full bg-blue-500 mr-2"></span>Blue (Out-of-Phase)</td>
                            <td class="px-4 py-3 text-sm">${blueAvg.n}</td>
                            <td class="px-4 py-3 text-sm font-mono">${blueAvg.meanRadius.toFixed(3)}</td>
                            <td class="px-4 py-3 text-sm font-mono">${blueAvg.sdRadius.toFixed(3)}</td>
                            <td class="px-4 py-3 text-sm font-mono">${blueAvg.meanArea.toFixed(3)}</td>
                            <td class="px-4 py-3 text-sm font-mono">${blueAvg.sdArea.toFixed(3)}</td>
                        `;
                        statsBody.appendChild(row);
                    }
                });
                
                const summaryContent = document.getElementById('summary-content');
                summaryContent.innerHTML = '';
                
                const totalParticipants = new Set();
                const totalImages = processedData.length;
                let frequenciesWithData = 0;
                
                FREQUENCIES.forEach(freq => {
                    const redData = participantData[freq].red;
                    const blueData = participantData[freq].blue;
                    
                    if (redData.length > 0 || blueData.length > 0) {
                        frequenciesWithData++;
                    }
                    
                    redData.forEach(d => totalParticipants.add(d.participant));
                    blueData.forEach(d => totalParticipants.add(d.participant));
                });
                
                // Calculate processing time
                const processingTime = ((Date.now() - processingStats.startTime) / 1000).toFixed(1);
                const avgSpeed = (totalImages / processingTime).toFixed(1);
                
                summaryContent.innerHTML = `
                    <div class="bg-blue-50 p-4 rounded-lg border-2 border-blue-200">
                        <div class="text-3xl font-bold text-blue-700">${totalParticipants.size}</div>
                        <div class="text-sm text-gray-600 font-semibold">Unique Participants</div>
                    </div>
                    <div class="bg-emerald-50 p-4 rounded-lg border-2 border-emerald-200">
                        <div class="text-3xl font-bold text-emerald-700">${totalImages}</div>
                        <div class="text-sm text-gray-600 font-semibold">Total Images Processed</div>
                    </div>
                    <div class="bg-purple-50 p-4 rounded-lg border-2 border-purple-200">
                        <div class="text-3xl font-bold text-purple-700">${frequenciesWithData}</div>
                        <div class="text-sm text-gray-600 font-semibold">Frequencies with Data</div>
                    </div>
                    <div class="bg-amber-50 p-4 rounded-lg border-2 border-amber-200 col-span-1 md:col-span-3">
                        <div class="text-2xl font-bold text-amber-700">‚ö° ${processingTime}s total ‚Ä¢ ${avgSpeed} img/s average ‚Ä¢ ${MAX_PARALLEL_WORKERS} workers</div>
                        <div class="text-sm text-gray-600 font-semibold">Processing Performance</div>
                    </div>
                `;
                
                updateProgress(100, `Complete! Processed ${totalImages} images in ${processingTime}s`);
                
                document.getElementById('data-summary').classList.remove('hidden');
                document.getElementById('visualization-container').classList.remove('hidden');
                document.getElementById('statistics-container').classList.remove('hidden');
                
                setTimeout(() => {
                    updateProgress(0, '');
                    document.getElementById('performance-dashboard').classList.add('hidden');
                }, 3000);
                
            } catch (err) {
                if (err.message === 'Processing cancelled by user') {
                    const progressContainer = document.getElementById('progress-container');
                    progressContainer.classList.remove('hidden');
                    updateProgress(0, '‚ùå Processing cancelled by user');
                    
                    setTimeout(() => {
                        progressContainer.classList.add('hidden');
                        document.getElementById('performance-dashboard').classList.add('hidden');
                    }, 2000);
                } else {
                    showError(err.message);
                    console.error('Analysis error:', err);
                }
            } finally {
                // Cleanup all active workers
                activeWorkers.forEach(worker => worker.terminate());
                activeWorkers.clear();
                updateWorkersMetric();
                
                const cancelBtn = document.getElementById('cancel-btn');
                const analyzeBtn = document.getElementById('analyze-btn');
                
                cancelBtn.disabled = false;
                cancelBtn.innerHTML = '‚õî Cancel Processing';
                cancelBtn.classList.remove('from-gray-400', 'to-gray-500', 'cursor-not-allowed');
                cancelBtn.classList.add('from-red-500', 'to-red-600', 'hover:from-red-600', 'hover:to-red-700');
                
                cancelBtn.classList.add('hidden');
                analyzeBtn.classList.remove('hidden');
                
                const files = document.getElementById('image-upload').files;
                if (files && files.length > 0) {
                    analyzeBtn.disabled = false;
                }
            }
        }
        
        // ============================================
        // EVENT LISTENERS
        // ============================================
        
        document.getElementById('image-upload').addEventListener('change', function(e) {
            const files = Array.from(e.target.files);
            const fileList = document.getElementById('file-list');
            const analyzeBtn = document.getElementById('analyze-btn');
            
            if (files.length > 0) {
                const pngCount = files.filter(f => f.name.toLowerCase().endsWith('.png')).length;
                const zipCount = files.filter(f => f.name.toLowerCase().endsWith('.zip')).length;
                
                fileList.innerHTML = `
                    <div class="p-4 bg-blue-50 rounded-lg border-2 border-blue-200">
                        <p class="font-semibold text-blue-800">
                            ‚úÖ ${files.length} file(s) selected
                            ${pngCount > 0 ? `(${pngCount} PNG${pngCount > 1 ? 's' : ''})` : ''}
                            ${zipCount > 0 ? `(${zipCount} ZIP${zipCount > 1 ? 's' : ''})` : ''}
                        </p>
                        <p class="text-sm text-blue-600 mt-1">Click "Analyze & Generate Visualizations" to process with parallel Web Workers!</p>
                    </div>
                `;
                
                analyzeBtn.disabled = false;
            } else {
                fileList.innerHTML = '';
                analyzeBtn.disabled = true;
            }
        });
        
        document.getElementById('analyze-btn').addEventListener('click', async function() {
            const files = Array.from(document.getElementById('image-upload').files);
            
            if (files.length === 0) {
                showError('Please select at least one file');
                return;
            }
            
            await analyzeData(files);
        });
        
        document.getElementById('cancel-btn').addEventListener('click', function() {
            processingCancelled = true;
            
            // Terminate all active workers immediately
            activeWorkers.forEach(worker => worker.terminate());
            activeWorkers.clear();
            updateWorkersMetric();
            
            this.disabled = true;
            this.innerHTML = '‚è≥ Cancelling...';
            this.classList.remove('from-red-500', 'to-red-600', 'hover:from-red-600', 'hover:to-red-700');
            this.classList.add('from-gray-400', 'to-gray-500', 'cursor-not-allowed');
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            activeWorkers.forEach(worker => worker.terminate());
            URL.revokeObjectURL(workerBlobUrl);
        });
        
        console.log(`Sound Object Analyzer Ultra Optimized initialized`);
        console.log(`CPU Cores: ${CPU_CORES}`);
        console.log(`Max Parallel Workers: ${MAX_PARALLEL_WORKERS}`);
        console.log(`Images per Worker: ${IMAGES_PER_WORKER}`);
        console.log(`Optimal Batch Size: ${MAX_PARALLEL_WORKERS * IMAGES_PER_WORKER}`);
    </script>
</body>
</html>
