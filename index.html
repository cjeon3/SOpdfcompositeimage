<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sound Object Analyzer - Cartesian Pipeline v2.2.55</title>
    <meta name="version" content="2.2.55">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        body {
            font-family: ui-sans-serif, system-ui, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .canvas-container {
            background: white;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .canvas-container:hover {
            transform: scale(1.02);
            box-shadow: 0 20px 40px -5px rgba(0, 0, 0, 0.3);
        }
        
        .step-dropdown {
            border: 2px solid;
            border-radius: 1rem;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .step-dropdown summary {
            padding: 1rem 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 1rem;
            font-weight: 600;
            list-style: none;
        }
        
        .step-dropdown summary::-webkit-details-marker {
            display: none;
        }
        
        .step-dropdown .arrow {
            margin-left: auto;
            transition: transform 0.3s ease;
        }
        
        .step-dropdown[open] .arrow {
            transform: rotate(90deg);
        }
        
        .step-content {
            padding: 1.5rem;
            border-top: 1px solid rgba(0,0,0,0.1);
        }
        
        .step-number {
            width: 2rem;
            height: 2rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.875rem;
        }
        
        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
        }
        
        @media (min-width: 1200px) {
            .analysis-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        .drag-active {
            border: 3px dashed #3b82f6 !important;
            background-color: rgba(59, 130, 246, 0.1) !important;
        }
    </style>
</head>
<body class="p-4 sm:p-8">
    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-8 text-white">
            <h1 class="text-4xl font-extrabold mb-2">Sound Object Analyzer</h1>
            <p class="text-xl font-semibold opacity-90">Cartesian Pipeline v2.2.55 - Code Review: Fix pixelCount + Cleanup</p>
            <div class="mt-4 flex flex-wrap justify-center gap-2">
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">‚úì Google Sheets Integration</span>
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">‚úì Adaptive Perimeter Sampling</span>
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">‚úì Perpendicular Cross Detection (1¬∞ precision)</span>
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">‚úì Complete Closure (Red)</span>
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">‚úì Area Statistics</span>
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">‚úì Overlap Preservation</span>
            </div>
        </header>
        
        <div class="space-y-4">
            <!-- Step 1: Upload -->
            <details class="step-dropdown border-blue-300 bg-gradient-to-r from-blue-50 to-blue-100" open>
                <summary>
                    <div class="step-number bg-blue-600">1</div>
                    <span class="text-blue-800">Upload PNG Images</span>
                    <span class="arrow">‚ñ∂</span>
                </summary>
                <div class="step-content bg-white">
                    <div id="drop-zone" class="border-2 border-dashed border-gray-300 rounded-xl p-8 text-center hover:border-blue-400 transition-colors cursor-pointer">
                        <svg class="w-16 h-16 mx-auto text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                        </svg>
                        <p class="text-lg font-semibold text-gray-700 mb-2">Drag and drop PNG files or ZIP archive</p>
                        <p class="text-sm text-gray-500 mb-4">Files should be named like: ParticipantID_FrequencyHz_dB.png</p>
                        <input type="file" id="file-input" multiple accept=".png,.zip" class="hidden">
                        <button onclick="document.getElementById('file-input').click()" class="px-6 py-3 bg-gradient-to-r from-blue-500 to-blue-600 text-white font-bold rounded-xl hover:from-blue-600 hover:to-blue-700 shadow-lg transition-all">
                            Browse Files
                        </button>
                    </div>
                    <div id="file-list" class="mt-4 text-sm text-gray-600 max-h-32 overflow-y-auto"></div>
                </div>
            </details>
            
            <!-- Step 1.5: Google Sheets Integration (NEW) -->
            <details class="step-dropdown border-emerald-300 bg-gradient-to-r from-emerald-50 to-emerald-100" id="sheets-dropdown">
                <summary>
                    <div class="step-number bg-emerald-600">1.5</div>
                    <span class="text-emerald-800">Google Sheets Centroid Data (Recommended)</span>
                    <span class="arrow">‚ñ∂</span>
                </summary>
                <div class="step-content bg-white">
                    <p class="text-sm text-gray-600 mb-4">
                        <strong>Optional but recommended:</strong> Connect to your Google Sheets to get exact centroid positions for each shape. 
                        This ensures accurate marker removal instead of pattern detection.
                    </p>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">Google Apps Script Web App URL:</label>
                            <input type="text" id="sheets-url" placeholder="https://script.google.com/macros/s/.../exec" 
                                   class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500">
                            <p class="text-xs text-gray-500 mt-1">Deploy your Apps Script as a web app and paste the URL here</p>
                        </div>
                        <div class="flex gap-3">
                            <button id="connect-sheets-btn" onclick="connectToSheets()" 
                                    class="px-4 py-2 bg-emerald-500 text-white font-semibold rounded-lg hover:bg-emerald-600 transition-colors">
                                üìä Connect & Fetch Data
                            </button>
                            <button id="skip-sheets-btn" onclick="skipSheetsIntegration()" 
                                    class="px-4 py-2 bg-gray-200 text-gray-700 font-semibold rounded-lg hover:bg-gray-300 transition-colors">
                                Skip (Use Pattern Detection)
                            </button>
                        </div>
                        <div id="sheets-status" class="text-sm font-medium hidden"></div>
                    </div>
                </div>
            </details>
            
            <!-- Step 2: Analyze -->
            <details class="step-dropdown border-purple-300 bg-gradient-to-r from-purple-50 to-purple-100" id="analyze-dropdown">
                <summary>
                    <div class="step-number bg-purple-600">2</div>
                    <span class="text-purple-800">Analyze Images</span>
                    <span class="arrow">‚ñ∂</span>
                </summary>
                <div class="step-content bg-white">
                    <!-- Averaging Mode Selection -->
                    <div class="mb-4 p-4 bg-purple-50 rounded-lg border border-purple-200">
                        <p class="text-sm font-semibold text-purple-800 mb-3">Averaging Mode:</p>
                        <div class="flex flex-col sm:flex-row gap-4">
                            <label class="flex items-start gap-3 cursor-pointer p-3 rounded-lg border-2 transition-all hover:bg-white" id="mode-contour-label">
                                <input type="radio" name="averaging-mode" value="contour" checked 
                                       class="mt-1 text-purple-600 focus:ring-purple-500"
                                       onchange="updateAveragingMode()">
                                <div>
                                    <span class="font-semibold text-gray-800">Contour Only</span>
                                    <p class="text-xs text-gray-600 mt-1">Average contour points directly. Each participant's shape contributes equally regardless of size.</p>
                                </div>
                            </label>
                            <label class="flex items-start gap-3 cursor-pointer p-3 rounded-lg border-2 transition-all hover:bg-white" id="mode-area-label">
                                <input type="radio" name="averaging-mode" value="area" 
                                       class="mt-1 text-purple-600 focus:ring-purple-500"
                                       onchange="updateAveragingMode()">
                                <div>
                                    <span class="font-semibold text-gray-800">Contour + Area Normalization</span>
                                    <p class="text-xs text-gray-600 mt-1">Average contours first, then scale the result to match the median area. Produces average shapes with representative size.</p>
                                </div>
                            </label>
                        </div>
                    </div>
                    
                    <button id="analyze-btn" disabled class="w-full px-6 py-3 bg-gradient-to-r from-purple-500 to-purple-600 text-white font-bold rounded-xl hover:from-purple-600 hover:to-purple-700 shadow-lg transition-all disabled:opacity-50 disabled:cursor-not-allowed">
                        üî¨ Analyze and Generate Composites
                    </button>
                    <p class="mt-3 text-sm text-gray-600">
                        This will extract pixel-based contours using pure Cartesian processing, filter centroid markers, and create composite visualizations.
                    </p>
                </div>
            </details>
            
            <!-- Step 3: Progress -->
            <details class="step-dropdown border-green-300 bg-gradient-to-r from-green-50 to-green-100" id="progress-dropdown">
                <summary>
                    <div class="step-number bg-green-600">3</div>
                    <span class="text-green-800">Processing Progress</span>
                    <span class="arrow">‚ñ∂</span>
                </summary>
                <div class="step-content bg-white">
                    <div class="mb-4">
                        <div class="flex justify-between items-center mb-2">
                            <span class="text-sm font-semibold text-gray-700" id="progress-text">Ready to process...</span>
                            <span class="text-sm font-bold text-blue-600" id="progress-percent">0%</span>
                        </div>
                        <div class="w-full bg-gray-200 rounded-full h-4 overflow-hidden">
                            <div id="progress-bar" class="h-full bg-gradient-to-r from-blue-500 to-purple-600 transition-all duration-300" style="width: 0%"></div>
                        </div>
                    </div>
                    <div class="bg-gray-50 p-4 rounded-lg border border-gray-200 max-h-48 overflow-y-auto">
                        <div class="text-xs font-mono text-gray-600" id="status-log">
                            <div>Waiting to start...</div>
                        </div>
                    </div>
                </div>
            </details>
            
            <!-- Step 4: Results -->
            <details class="step-dropdown border-indigo-300 bg-gradient-to-r from-indigo-50 to-indigo-100" id="results-dropdown">
                <summary>
                    <div class="step-number bg-indigo-600">4</div>
                    <span class="text-indigo-800">View Composite Visualizations</span>
                    <span class="arrow">‚ñ∂</span>
                </summary>
                <div class="step-content bg-white">
                    <div id="results-grid" class="analysis-grid">
                        <div class="text-center text-gray-500 py-8">
                            No results yet. Upload files and click Analyze to generate composites.
                        </div>
                    </div>
                    <div class="mt-6 flex gap-4">
                        <button id="download-all-btn" disabled class="flex-1 px-6 py-3 bg-gradient-to-r from-indigo-500 to-indigo-600 text-white font-bold rounded-xl hover:from-indigo-600 hover:to-indigo-700 shadow-lg transition-all disabled:opacity-50 disabled:cursor-not-allowed">
                            ‚¨áÔ∏è Download All Composites (ZIP)
                        </button>
                    </div>
                </div>
            </details>
            
            <!-- Step 5: Area Statistics -->
            <details class="step-dropdown border-emerald-300 bg-gradient-to-r from-emerald-50 to-emerald-100" id="area-stats-dropdown">
                <summary>
                    <div class="step-number bg-emerald-600">5</div>
                    <span class="text-emerald-800">Area Statistics by Frequency</span>
                    <span class="arrow">‚ñ∂</span>
                </summary>
                <div class="step-content bg-white">
                    <div id="area-stats-container">
                        <div class="text-center text-gray-500 py-8">
                            No area statistics yet. Run analysis to calculate areas.
                        </div>
                    </div>
                </div>
            </details>
        </div>
        
        <footer class="mt-8 text-center text-white/70 text-sm">
            <p>Sound Object Analyzer - Cartesian Pipeline v2.2</p>
            <p>UCI Hearing & Speech Lab</p>
        </footer>
    </div>
    
    <script>
        // ============================================
        // CONSTANTS - MUST Match Drawing Tool EXACTLY for 1:1 Translation
        // ============================================
        // These values ensure that a shape drawn at grid position (3,3) 
        // in the drawing tool will appear at grid position (3,3) in the composite.
        //
        // Drawing Tool Coordinate System:
        //   - Canvas: 1000x1000 pixels
        //   - Grid: -10 to +10 units in both X and Y
        //   - Center: pixel (500, 500) = grid (0, 0)
        //   - Scale: 50 pixels per unit
        //   - Y-axis: inverted (positive Y goes up, but pixel Y increases down)
        //
        // Conversion formulas (from drawing tool):
        //   canvasToUnit(px, py) => { x: (px - 500) / 50, y: (500 - py) / 50 }
        //   unitToCanvas(ux, uy) => { x: ux * 50 + 500, y: 500 - uy * 50 }
        //
        // Example: Grid position (3, 3) = Pixel position (650, 350)
        //   x_pixel = 3 * 50 + 500 = 650
        //   y_pixel = 500 - 3 * 50 = 350
        //
        const CANVAS_SIZE = 1000;
        const UNIT_RANGE = 10;
        const SCALE_FACTOR = CANVAS_SIZE / (UNIT_RANGE * 2); // 50 pixels per unit
        const REFERENCE_CIRCLE_RADIUS_UNITS = 3;
        const REFERENCE_CIRCLE_RADIUS_PX = REFERENCE_CIRCLE_RADIUS_UNITS * SCALE_FACTOR; // 150px
        const CENTER = CANVAS_SIZE / 2; // 500px
        
        // Minimum sample rate for contour interpolation (matches drawing tool minimum)
        const MIN_CONTOUR_SAMPLES = 100;
        // Sampling density: 1 sample per 0.1 units of perimeter (matches drawing tool)
        const UNITS_PER_SAMPLE = 0.1;
        
        // Color thresholds for detection
        const RED_COLOR = { r: 239, g: 68, b: 68 };    // #ef4444
        const BLUE_COLOR = { r: 59, g: 130, b: 246 };  // #3b82f6
        const COLOR_TOLERANCE = 80; // Tolerance for color matching
        
        // Frequencies from drawing tool
        const FREQUENCIES = [31, 62.5, 125, 250, 500, 1000, 2000, 4000, 8000, 12000, 16000];
        
        // Global state
        let uploadedFiles = [];
        let processedImages = {};
        let compositeCanvases = {};
        let averagingMode = 'contour'; // 'contour' or 'area'
        
        // Google Sheets integration state
        let sheetsData = null;          // Data from Google Sheets (all rows)
        let sheetsConnected = false;    // Whether we have valid Sheets data
        let trialMapping = {};          // Maps participant -> {zipOrderNumber: trialNumber}
        let fileTrialInfo = {};         // Maps filename -> {participant, trial, zipName}
        
        // ============================================
        // GOOGLE SHEETS INTEGRATION
        // ============================================
        
        async function connectToSheets() {
            const urlInput = document.getElementById('sheets-url');
            const statusEl = document.getElementById('sheets-status');
            const url = urlInput.value.trim();
            
            if (!url) {
                showSheetsStatus('error', 'Please enter a Google Apps Script URL');
                return;
            }
            
            showSheetsStatus('loading', 'Connecting to Google Sheets...');
            
            try {
                // Fetch all data from the Apps Script
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // Validate data structure
                if (!Array.isArray(data) || data.length === 0) {
                    throw new Error('No data returned from Google Sheets');
                }
                
                // Check for required fields (from Apps Script format)
                const sample = data[0];
                console.log('[Sheets] Sample record structure:', sample);
                
                // Apps Script v2.2.22 returns from Google Sheets columns:
                // Column B: participant
                // Column C: responseNumber (trial) - also aliased as 'trial'
                // Column D: frequency (Hz)
                // Column F: color (red/blue)
                // Column G: area (grid squares, units¬≤)
                // Column H: centroidX (units, -10 to +10)
                // Column I: centroidY (units, -10 to +10)
                const hasParticipant = 'participant' in sample;
                const hasFrequency = 'frequency' in sample;
                const hasColor = 'color' in sample;
                const hasCentroid = ('centroidX' in sample && 'centroidY' in sample) || 
                                   ('centroid' in sample);
                const hasTrial = 'responseNumber' in sample || 'trial' in sample;
                
                if (!hasParticipant || !hasFrequency || !hasColor || !hasCentroid) {
                    throw new Error('Missing required fields. Expected: participant, frequency, color, centroidX/centroidY');
                }
                
                if (!hasTrial) {
                    console.warn('[Sheets] No trial/responseNumber field found - defaulting all to trial 1');
                }
                
                // Normalize the data format
                // CRITICAL: Normalize trial numbers - Google Sheets may have "1.0" which needs to match "1"
                sheetsData = data.map(record => {
                    // Parse trial as number first, then convert to integer string
                    let trialValue = record.responseNumber || record.trial || '1';
                    if (typeof trialValue === 'number') {
                        trialValue = Math.floor(trialValue).toString();
                    } else {
                        // Parse float and floor to handle "1.0" ‚Üí "1"
                        const parsed = parseFloat(trialValue);
                        trialValue = isNaN(parsed) ? '1' : Math.floor(parsed).toString();
                    }
                    
                    return {
                        participant: (record.participant || '').toString().trim(),
                        trial: trialValue,
                        frequency: parseFloat(record.frequency),
                        color: (record.color || '').toString().toLowerCase().trim(),
                        area: parseFloat(record.area || 0),
                        centroid: {
                            x: parseFloat(record.centroidX ?? record.centroid?.x ?? 0),
                            y: parseFloat(record.centroidY ?? record.centroid?.y ?? 0)
                        }
                    };
                });
                
                sheetsConnected = true;
                
                // Count unique participants
                const participants = new Set(sheetsData.map(d => d.participant));
                const frequencies = new Set(sheetsData.map(d => d.frequency));
                const trials = new Set(sheetsData.map(d => d.trial));
                
                showSheetsStatus('success', 
                    `‚úÖ Connected! Loaded ${sheetsData.length} records from ${participants.size} participants across ${frequencies.size} frequencies`);
                
                console.log('[Sheets] Successfully loaded:', sheetsData.length, 'records');
                console.log('[Sheets] Participants:', Array.from(participants).join(', '));
                console.log('[Sheets] Trials found:', Array.from(trials).join(', '));
                console.log('[Sheets] Normalized sample:', sheetsData[0]);
                
                // Log participant/trial breakdown for debugging
                const ptBreakdown = {};
                for (const record of sheetsData) {
                    const key = `${record.participant}`;
                    if (!ptBreakdown[key]) ptBreakdown[key] = new Set();
                    ptBreakdown[key].add(record.trial);
                }
                console.log('[Sheets] Participant trials:', Object.fromEntries(
                    Object.entries(ptBreakdown).map(([p, trials]) => [p, Array.from(trials).sort()])
                ));
                
            } catch (error) {
                sheetsConnected = false;
                sheetsData = null;
                showSheetsStatus('error', `‚ùå Connection failed: ${error.message}`);
                console.error('[Sheets] Connection error:', error);
            }
        }
        
        function skipSheetsIntegration() {
            sheetsConnected = false;
            sheetsData = null;
            showSheetsStatus('info', '‚ö†Ô∏è Skipped - Using pattern-based marker detection (less accurate)');
        }
        
        function showSheetsStatus(type, message) {
            const statusEl = document.getElementById('sheets-status');
            statusEl.classList.remove('hidden');
            statusEl.className = 'text-sm font-medium mt-3 p-3 rounded-lg';
            
            switch (type) {
                case 'success':
                    statusEl.classList.add('bg-green-100', 'text-green-800');
                    break;
                case 'error':
                    statusEl.classList.add('bg-red-100', 'text-red-800');
                    break;
                case 'loading':
                    statusEl.classList.add('bg-blue-100', 'text-blue-800');
                    break;
                case 'info':
                    statusEl.classList.add('bg-yellow-100', 'text-yellow-800');
                    break;
            }
            
            statusEl.textContent = message;
        }
        
        /**
         * Parse ZIP folder name to extract participant and order number
         * Expected format: "ParticipantName_##_Drawings.zip"
         */
        function parseZipName(zipName) {
            // Remove .zip extension
            const nameWithoutExt = zipName.replace(/\.zip$/i, '');
            
            // Try to match pattern: Name_##_Text
            const match = nameWithoutExt.match(/^(.+?)_(\d+)_/);
            
            if (match) {
                return {
                    participant: match[1].trim(),
                    orderNumber: parseInt(match[2]),
                    fullName: zipName
                };
            }
            
            // Fallback: try to extract participant name without order number
            const parts = nameWithoutExt.split('_');
            return {
                participant: parts[0].trim(),
                orderNumber: 999, // Unknown order
                fullName: zipName
            };
        }
        
        /**
         * Build trial mapping from ZIP folder names
         * Groups by participant, sorts by order number, assigns trial 1, 2, 3
         */
        function buildTrialMapping(zipNames) {
            const participantZips = {};
            
            // Group by participant
            for (const zipName of zipNames) {
                const parsed = parseZipName(zipName);
                if (!participantZips[parsed.participant]) {
                    participantZips[parsed.participant] = [];
                }
                participantZips[parsed.participant].push({
                    zipName: zipName,
                    orderNumber: parsed.orderNumber
                });
            }
            
            // Sort by order number and assign trial numbers
            const mapping = {};
            
            for (const [participant, zips] of Object.entries(participantZips)) {
                // Sort by order number (ascending) - lowest number = Trial 1
                zips.sort((a, b) => a.orderNumber - b.orderNumber);
                
                mapping[participant] = {};
                zips.forEach((zip, index) => {
                    const trialNumber = index + 1; // 1, 2, 3
                    mapping[participant][zip.orderNumber] = trialNumber;
                });
                
                // Detailed logging for each participant's trial mapping
                console.log(`üìã Trial mapping for ${participant}:`);
                zips.forEach((zip, index) => {
                    console.log(`   ${zip.zipName} (order ${zip.orderNumber}) ‚Üí Trial ${index + 1}`);
                });
            }
            
            return mapping;
        }
        
        /**
         * Look up centroid from Google Sheets for a specific shape
         * Returns centroid in UNITS (¬±10 range) or null if not found
         */
        function lookupSheetsData(participant, trial, frequency, color) {
            if (!sheetsConnected || !sheetsData) {
                return null;
            }
            
            // Normalize inputs for matching
            const normalizedParticipant = participant.trim();
            // CRITICAL: Normalize trial to integer string (handles "1.0" ‚Üí "1")
            const parsedTrial = parseFloat(trial);
            const normalizedTrial = isNaN(parsedTrial) ? '1' : Math.floor(parsedTrial).toString();
            const normalizedFrequency = parseFloat(frequency);
            const normalizedColor = color.toLowerCase().trim();
            
            // Search for matching record
            for (const record of sheetsData) {
                // Match participant (case-insensitive, trimmed)
                if (record.participant.toLowerCase() !== normalizedParticipant.toLowerCase()) continue;
                
                // Match trial (already normalized to integer strings on both sides)
                if (record.trial !== normalizedTrial) continue;
                
                // Match frequency (with small tolerance for floating point)
                if (Math.abs(record.frequency - normalizedFrequency) > 0.1) continue;
                
                // Match color
                if (record.color !== normalizedColor) continue;
                
                // Found a match! Return centroid data
                if (record.centroid && !isNaN(record.centroid.x) && !isNaN(record.centroid.y)) {
                    return {
                        centroid: record.centroid,
                        area: record.area,
                        participant: record.participant,
                        trial: record.trial,
                        frequency: record.frequency,
                        color: record.color
                    };
                }
            }
            
            // No match found
            return null;
        }
        
        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        
        function canvasToUnit(x, y) {
            return {
                x: (x - CENTER) / SCALE_FACTOR,
                y: (CENTER - y) / SCALE_FACTOR
            };
        }
        
        function unitToCanvas(x, y) {
            return {
                x: x * SCALE_FACTOR + CENTER,
                y: CENTER - y * SCALE_FACTOR
            };
        }
        
        function parseFrequencyFromFilename(filename) {
            // PNG filename format: "ParticipantName_FreqHz_dBdB.png"
            // Example: "Diego G_31Hz_100dB.png" ‚Üí frequency = 31
            // Example: "Diego G_62.5Hz_100dB.png" ‚Üí frequency = 62.5
            const match = filename.match(/(\d+\.?\d*)Hz/i);
            if (match) {
                return parseFloat(match[1]);
            }
            return null;
        }
        
        function parseParticipantFromFilename(filename) {
            // PNG filename format: "ParticipantName_FreqHz_dBdB.png"
            // Example: "Diego G_31Hz_100dB.png" ‚Üí participant = "Diego G"
            // Participant name is everything before the first underscore followed by frequency
            
            // Remove file extension first
            const nameWithoutExt = filename.replace(/\.png$/i, '');
            
            // Split by underscore
            const parts = nameWithoutExt.split('_');
            
            // Find the part that contains "Hz" - everything before that is the participant name
            let participantParts = [];
            for (const part of parts) {
                if (/\d+\.?\d*Hz/i.test(part)) {
                    break; // Stop when we hit the frequency part
                }
                participantParts.push(part);
            }
            
            // Join participant parts (in case name has underscores, though typically it doesn't)
            const participant = participantParts.join('_').trim();
            
            return participant || 'Unknown';
        }
        
        function updateProgress(percent, text) {
            document.getElementById('progress-bar').style.width = percent + '%';
            document.getElementById('progress-percent').textContent = Math.round(percent) + '%';
            document.getElementById('progress-text').textContent = text;
        }
        
        function addLogEntry(message) {
            const log = document.getElementById('status-log');
            const entry = document.createElement('div');
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }
        
        // ============================================
        // COLOR DETECTION - Improved for Anti-Aliasing
        // ============================================
        
        /**
         * Detect if a pixel is part of a RED drawn shape
         * Based on analysis of actual drawing data:
         * - Core red: (239, 68, 68) sat=0.715
         * - Anti-aliased: (243,114,114) sat=0.53, (247,161,161) sat=0.35
         * - Light edges: (251,208,208) sat=0.17, (240,198,200) sat=0.18
         * - Pink edges at grid boundary: (176,139,148) sat=0.21
         * 
         * IMPORTANT: Blue shapes are drawn ON TOP of red shapes.
         * Purple pixels (hue 0.75-0.92) contain BOTH colors - red underneath,
         * blue on top. Both red and blue detection should include purple pixels.
         * 
         * Must distinguish from:
         * - Grid gray: (156,163,175) sat=0.11, (107,114,128) sat=0.16
         */
        function isRedPixel(r, g, b, a) {
            if (a < 128) return false; // Transparent
            
            // Calculate color properties
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const saturation = max > 0 ? (max - min) / max : 0;
            const lightness = (max + min) / 2;
            
            // Calculate hue (0-1 scale, red is near 0 or 1)
            let hue = 0;
            if (max !== min) {
                const d = max - min;
                if (max === r) {
                    hue = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                } else if (max === g) {
                    hue = ((b - r) / d + 2) / 6;
                } else {
                    hue = ((r - g) / d + 4) / 6;
                }
            }
            
            // Red hue: < 0.08 or > 0.92
            // Purple hue (red underneath blue): 0.75-0.92 - ALSO contains red!
            const isRedHue = (hue < 0.08 || hue > 0.92);
            const isPurpleHue = (hue > 0.75 && hue < 0.92);
            
            // Calculate distance to core colors (for edge case detection)
            const distToRed = Math.sqrt(
                Math.pow(r - RED_COLOR.r, 2) + 
                Math.pow(g - RED_COLOR.g, 2) + 
                Math.pow(b - RED_COLOR.b, 2)
            );
            const distToBlue = Math.sqrt(
                Math.pow(r - BLUE_COLOR.r, 2) + 
                Math.pow(g - BLUE_COLOR.g, 2) + 
                Math.pow(b - BLUE_COLOR.b, 2)
            );
            
            // ===== TIER 1: Core red color (exact match) =====
            if (Math.abs(r - 239) < 15 && Math.abs(g - 68) < 30 && Math.abs(b - 68) < 30) {
                return true;
            }
            
            // ===== TIER 2: High saturation red (sat > 0.40) =====
            if (saturation > 0.40 && isRedHue && r > g && r > b && r > 150) {
                return true;
            }
            
            // ===== TIER 3: Medium saturation red (sat 0.25-0.40) =====
            if (saturation > 0.25 && saturation <= 0.40) {
                if (isRedHue && r > g + 20 && r > b + 20 && r > 180) {
                    return true;
                }
            }
            
            // ===== TIER 4: Low saturation edges (sat 0.15-0.25) =====
            if (saturation > 0.15 && saturation <= 0.25) {
                const isPinkTone = Math.abs(g - b) < 20;
                
                // Method A: High lightness pink (blending with white)
                if (isRedHue && r > g && r > b && lightness > 180 && isPinkTone) {
                    return true;
                }
                
                // Method B: Distance-based for medium lightness
                if (isRedHue && r > g && r > b && distToRed < distToBlue * 0.85) {
                    return true;
                }
            }
            
            // ===== TIER 5: Very low saturation but clearly red-leaning =====
            if (saturation > 0.12 && saturation <= 0.15) {
                if (isRedHue && r > g && r > b && distToRed < distToBlue * 0.75) {
                    return true;
                }
            }
            
            // ===== TIER 6: Purple pixels (red underneath blue) =====
            // Purple contains both colors - red is underneath
            if (isPurpleHue && saturation > 0.25) {
                // Purple with decent saturation - red is present underneath
                if (r > 100 && r > g - 20) {
                    return true;
                }
            }
            
            // ===== TIER 7: Low saturation purple =====
            if (isPurpleHue && saturation > 0.12 && saturation <= 0.25) {
                // Red component should be meaningful
                if (r > 150 && r >= b - 10) {
                    return true;
                }
            }
            
            return false;
        }
        
        /**
         * Detect if a pixel is part of a BLUE drawn shape
         * Based on analysis of actual drawing data:
         * - Core blue: (59, 130, 246) sat=0.76
         * - Anti-aliased: (108,161,248) sat=0.57, (157,192,250) sat=0.37
         * - Light edges: (206,223,252) sat=0.18
         * 
         * IMPORTANT: Blue shapes are ALWAYS drawn ON TOP of red shapes.
         * This means purple pixels (blue blending with red below) should
         * be classified as BLUE, not red or ignored.
         * - Purple hue range: 0.75-0.92 (between blue ~0.6 and red ~0/1)
         * 
         * Must distinguish from:
         * - Grid blue-gray: (156,163,175) sat=0.11, (107,114,128) sat=0.16
         */
        function isBluePixel(r, g, b, a) {
            if (a < 128) return false; // Transparent
            
            // Calculate color properties
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const saturation = max > 0 ? (max - min) / max : 0;
            const lightness = (max + min) / 2;
            
            // Calculate hue (0-1 scale)
            let hue = 0;
            if (max !== min) {
                const d = max - min;
                if (max === r) {
                    hue = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                } else if (max === g) {
                    hue = ((b - r) / d + 2) / 6;
                } else {
                    hue = ((r - g) / d + 4) / 6;
                }
            }
            
            // Blue hue: 0.55-0.72
            // Purple hue (blue on top of red): 0.75-0.92
            const isBlueHue = (hue > 0.55 && hue < 0.72);
            const isPurpleHue = (hue > 0.75 && hue < 0.92);
            
            // Calculate distance to core colors
            const distToRed = Math.sqrt(
                Math.pow(r - RED_COLOR.r, 2) + 
                Math.pow(g - RED_COLOR.g, 2) + 
                Math.pow(b - RED_COLOR.b, 2)
            );
            const distToBlue = Math.sqrt(
                Math.pow(r - BLUE_COLOR.r, 2) + 
                Math.pow(g - BLUE_COLOR.g, 2) + 
                Math.pow(b - BLUE_COLOR.b, 2)
            );
            
            // ===== TIER 1: Core blue color (exact match) =====
            if (Math.abs(r - 59) < 30 && Math.abs(g - 130) < 40 && Math.abs(b - 246) < 20) {
                return true;
            }
            
            // ===== TIER 2: High saturation blue (sat > 0.45) =====
            if (saturation > 0.45 && isBlueHue && b > r && b > g && b > 150) {
                return true;
            }
            
            // ===== TIER 3: Medium saturation blue (sat 0.30-0.45) =====
            if (saturation > 0.30 && saturation <= 0.45) {
                if (isBlueHue && b > r + 30 && b > g + 20 && b > 180) {
                    return true;
                }
                // Also accept if clearly closer to blue core
                if (isBlueHue && b > r && b > g && distToBlue < distToRed * 0.75) {
                    return true;
                }
            }
            
            // ===== TIER 4: Low saturation edges (sat 0.17-0.30) =====
            if (saturation > 0.17 && saturation <= 0.30) {
                const blueExcess = b - r;
                
                // Method A: Strong blue characteristics
                if (isBlueHue && b > g && blueExcess > 35 && lightness > 180 && b > 220) {
                    return true;
                }
                
                // Method B: Distance-based (must be MUCH closer to blue)
                if (isBlueHue && b > r && b > g && distToBlue < distToRed * 0.70 && distToBlue < 130) {
                    return true;
                }
            }
            
            // ===== TIER 5: Purple pixels (blue on top of red) =====
            // Since blue is always rendered on top, purple = blue's anti-aliased edge
            if (isPurpleHue && saturation > 0.25) {
                // Purple with decent saturation - this is blue blending with red below
                if (b > 100 && b > g - 20) {
                    return true;
                }
            }
            
            // ===== TIER 6: Low saturation purple =====
            // Light purple like (202,176,205) sat=0.14
            if (isPurpleHue && saturation > 0.12 && saturation <= 0.25) {
                // Blue component should be meaningful
                if (b > 150 && b >= r - 10) {
                    return true;
                }
            }
            
            // ===== Special case: Dark blue tones =====
            if (saturation > 0.70 && b > 150 && b > r * 2 && b > g * 2) {
                return true;
            }
            
            // ===== Special case: Medium blues that pass distance check =====
            if (saturation > 0.40 && b > r && b > g && distToBlue < 100) {
                return true;
            }
            
            return false;
        }
        
        // ============================================
        // PIXEL-BASED CONTOUR EXTRACTION (CARTESIAN)
        // ============================================
        
        function extractColoredPixels(imageData, isColorFunc) {
            const pixels = [];
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    const a = data[idx + 3];
                    
                    if (isColorFunc(r, g, b, a)) {
                        pixels.push({ x, y });
                    }
                }
            }
            
            return pixels;
        }
        
        function findConnectedComponents(pixels, width, height) {
            if (pixels.length === 0) return [];
            
            // Create a grid for fast lookup
            const grid = new Set();
            pixels.forEach(p => grid.add(`${p.x},${p.y}`));
            
            const visited = new Set();
            const components = [];
            
            function floodFill(startX, startY) {
                const component = [];
                const stack = [{ x: startX, y: startY }];
                
                while (stack.length > 0) {
                    const { x, y } = stack.pop();
                    const key = `${x},${y}`;
                    
                    if (visited.has(key) || !grid.has(key)) continue;
                    
                    visited.add(key);
                    component.push({ x, y });
                    
                    // 8-connected neighbors
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            if (dx === 0 && dy === 0) continue;
                            const nx = x + dx;
                            const ny = y + dy;
                            const nkey = `${nx},${ny}`;
                            if (!visited.has(nkey) && grid.has(nkey)) {
                                stack.push({ x: nx, y: ny });
                            }
                        }
                    }
                }
                
                return component;
            }
            
            for (const pixel of pixels) {
                const key = `${pixel.x},${pixel.y}`;
                if (!visited.has(key)) {
                    const component = floodFill(pixel.x, pixel.y);
                    if (component.length > 0) {
                        components.push(component);
                    }
                }
            }
            
            return components;
        }
        
        /**
         * Calculate centroid from a resampled contour - MATCHES DRAWING TOOL
         * The drawing tool uses uniform path resampling then averages.
         * Since our contour is already uniformly resampled, we just average.
         * 
         * @param {Array} resampledContour - Uniformly resampled pixel contour
         * @returns {Object} - Centroid in pixel coordinates {x, y}
         */
        function calculateContourCentroidLikeDrawingTool(resampledContour) {
            if (!resampledContour || resampledContour.length === 0) {
                return { x: 0, y: 0 };
            }
            
            if (resampledContour.length === 1) {
                return { x: resampledContour[0].x, y: resampledContour[0].y };
            }
            
            // The contour is already uniformly resampled (100+ points evenly spaced)
            // This matches the drawing tool's approach:
            //   1. Calculate path length
            //   2. Create uniform samples: numSamples = max(100, floor(totalLength / 0.1))
            //   3. Average all samples
            // Our resampleContour() function already does steps 1-2, so we just average
            
            let sumX = 0, sumY = 0;
            for (const p of resampledContour) {
                sumX += p.x;
                sumY += p.y;
            }
            
            return {
                x: sumX / resampledContour.length,
                y: sumY / resampledContour.length
            };
        }
        
        /**
         * Translate shape data to match Sheets centroid (ground truth)
         * Shifts all pixels and contour points uniformly so the centroid matches exactly.
         * This ensures 100% centroid accuracy when Sheets data is available.
         * 
         * @param {Array} rawPixels - Raw pixel array [{x, y}, ...]
         * @param {Array} contour - Traced contour in pixels [{x, y}, ...]
         * @param {Object} extractedCentroidPixel - Centroid calculated from extraction {x, y}
         * @param {Object} sheetsCentroidUnits - Ground truth centroid from Sheets in units {x, y}
         * @returns {Object} - { rawPixels, contour, centroidPixel, centroidUnit, wasTranslated, offset }
         */
        function translateShapeToSheetsCentroid(rawPixels, contour, extractedCentroidPixel, sheetsCentroidUnits) {
            // If no Sheets centroid, return original data with extracted centroid
            if (!sheetsCentroidUnits || isNaN(sheetsCentroidUnits.x) || isNaN(sheetsCentroidUnits.y)) {
                return {
                    rawPixels: rawPixels,
                    contour: contour,
                    centroidPixel: extractedCentroidPixel,
                    centroidUnit: canvasToUnit(extractedCentroidPixel.x, extractedCentroidPixel.y),
                    wasTranslated: false,
                    offset: { x: 0, y: 0 }
                };
            }
            
            // Convert Sheets centroid to pixel coordinates
            const targetCentroidPixel = unitToCanvas(sheetsCentroidUnits.x, sheetsCentroidUnits.y);
            
            // Calculate offset needed to move extracted centroid to Sheets centroid
            const offsetX = targetCentroidPixel.x - extractedCentroidPixel.x;
            const offsetY = targetCentroidPixel.y - extractedCentroidPixel.y;
            const offsetMagnitude = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
            
            // Always translate to match Sheets centroid exactly (no threshold)
            const translatedRawPixels = rawPixels.map(p => ({
                x: p.x + offsetX,
                y: p.y + offsetY
            }));
            
            // Translate contour
            const translatedContour = contour.map(p => ({
                x: p.x + offsetX,
                y: p.y + offsetY
            }));
            
            const offsetUnits = offsetMagnitude / SCALE_FACTOR;
            if (offsetMagnitude > 0.01) {
                console.log(`    üîÑ Translated shape by (${offsetX.toFixed(1)}, ${offsetY.toFixed(1)}) pixels (${offsetUnits.toFixed(3)} units) to match Sheets centroid`);
            }
            
            return {
                rawPixels: translatedRawPixels,
                contour: translatedContour,
                centroidPixel: { x: targetCentroidPixel.x, y: targetCentroidPixel.y },
                centroidUnit: { x: sheetsCentroidUnits.x, y: sheetsCentroidUnits.y },
                wasTranslated: true,
                offset: { x: offsetX, y: offsetY },
                offsetUnits: offsetUnits
            };
        }
        
        // ============================================
        // CENTROID MARKER REMOVAL (Component-First Approach)
        // ============================================
        // Priority 1: Component-level detection (geometric heuristics)
        // Priority 2: Pixel-based pattern matching at known Sheets location
        
        // Marker geometry constants (from drawing tool)
        // Cross: markerSize=12 (arms ¬±12px), lineWidth=3
        // Circle: radius=14, lineWidth=2
        // Total bbox: ~30px, total pixels: ~250-350 typically
        const MARKER_CROSS_ARM = 12;
        const MARKER_CROSS_WIDTH = 3;
        const MARKER_CIRCLE_RADIUS = 14;
        const MARKER_CIRCLE_WIDTH = 2;
        
        // Detection thresholds (widened for anti-aliasing and edge cases)
        const MARKER_BBOX_MIN = 20;       // Minimum bounding box size
        const MARKER_BBOX_MAX = 45;       // Maximum bounding box size
        const MARKER_PIXELS_MIN = 100;    // Minimum pixel count (was 150)
        const MARKER_PIXELS_MAX = 600;    // Maximum pixel count (was 500)
        
        /**
         * Check if a component looks like a centroid marker based on geometry
         */
        function isMarkerComponent(component) {
            const n = component.length;
            
            // Quick size check
            if (n < MARKER_PIXELS_MIN || n > MARKER_PIXELS_MAX) {
                return false;
            }
            
            // Calculate bounding box
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            for (const p of component) {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y);
                maxY = Math.max(maxY, p.y);
            }
            
            const width = maxX - minX + 1;
            const height = maxY - minY + 1;
            const aspectRatio = Math.max(width, height) / Math.min(width, height);
            const fillRatio = n / (width * height);
            
            // Log for debugging
            const isCandidate = (width >= MARKER_BBOX_MIN && width <= MARKER_BBOX_MAX &&
                                 height >= MARKER_BBOX_MIN && height <= MARKER_BBOX_MAX);
            if (isCandidate || (n >= 100 && n <= 400)) {
                console.log(`  üîç Component: ${n}px, bbox=${width}x${height}, aspect=${aspectRatio.toFixed(2)}, fill=${fillRatio.toFixed(2)}`);
            }
            
            // Size constraints
            if (width < MARKER_BBOX_MIN || width > MARKER_BBOX_MAX) return false;
            if (height < MARKER_BBOX_MIN || height > MARKER_BBOX_MAX) return false;
            
            // Aspect ratio (should be roughly square)
            if (aspectRatio > 1.8) return false;
            
            // Fill ratio (marker is sparse - cross + circle outline)
            if (fillRatio > 0.65) return false; // Too filled in
            if (fillRatio < 0.12) return false; // Too sparse
            
            console.log(`  ‚úÖ Component IS marker: ${n}px, bbox=${width}x${height}`);
            return true;
        }
        
        /**
         * Check if a pixel is part of the marker pattern at given center
         */
        function isMarkerPixel(px, py, centerX, centerY) {
            const dx = px - centerX;
            const dy = py - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // Cross arms (horizontal and vertical, any rotation handled by tolerance)
            const crossTolerance = MARKER_CROSS_WIDTH / 2 + 3; // +3 for anti-aliasing (widened)
            const onHorizontal = Math.abs(dy) <= crossTolerance && Math.abs(dx) <= MARKER_CROSS_ARM + 3;
            const onVertical = Math.abs(dx) <= crossTolerance && Math.abs(dy) <= MARKER_CROSS_ARM + 3;
            
            // Diagonal arms (for rotated markers - 45 degree case)
            const diagDist = Math.abs(Math.abs(dx) - Math.abs(dy));
            const onDiagonal = diagDist <= crossTolerance && dist <= MARKER_CROSS_ARM + 3;
            
            // Circle (widened slightly)
            const innerR = MARKER_CIRCLE_RADIUS - MARKER_CIRCLE_WIDTH / 2 - 3;
            const outerR = MARKER_CIRCLE_RADIUS + MARKER_CIRCLE_WIDTH / 2 + 3;
            const onCircle = dist >= innerR && dist <= outerR;
            
            // Center area (inner circle where cross arms meet)
            const onCenter = dist <= crossTolerance;
            
            return onHorizontal || onVertical || onDiagonal || onCircle || onCenter;
        }
        
        /**
         * Remove marker pixels from a component using known center location
         */
        function removeMarkerAtLocation(component, centerX, centerY) {
            const pixelSet = new Set(component.map(p => `${p.x},${p.y}`));
            
            // Build set of marker pixels
            const markerPixels = new Set();
            for (const p of component) {
                if (isMarkerPixel(p.x, p.y, centerX, centerY)) {
                    markerPixels.add(`${p.x},${p.y}`);
                }
            }
            
            // Check if pixel has non-marker neighbors (part of actual shape, not just anti-aliasing)
            // Require at least 5 non-marker neighbors to consider it as true overlap with shape
            // This is stricter to avoid preserving marker edge pixels
            function hasShapeNeighbors(px, py) {
                let nonMarkerNeighbors = 0;
                for (let ndx = -2; ndx <= 2; ndx++) {
                    for (let ndy = -2; ndy <= 2; ndy++) {
                        if (ndx === 0 && ndy === 0) continue;
                        const key = `${px + ndx},${py + ndy}`;
                        if (pixelSet.has(key) && !markerPixels.has(key)) {
                            nonMarkerNeighbors++;
                        }
                    }
                }
                // Require at least 5 non-marker neighbors (very strict)
                return nonMarkerNeighbors >= 5;
            }
            
            // Filter pixels
            const filtered = [];
            let removed = 0, preserved = 0;
            
            for (const p of component) {
                const key = `${p.x},${p.y}`;
                if (markerPixels.has(key)) {
                    if (hasShapeNeighbors(p.x, p.y)) {
                        filtered.push(p);
                        preserved++;
                    } else {
                        removed++;
                    }
                } else {
                    filtered.push(p);
                }
            }
            
            if (removed > 0) {
                console.log(`  üóëÔ∏è Removed ${removed} marker pixels, preserved ${preserved} (overlap with ‚â•5 neighbors)`);
            }
            
            return filtered;
        }
        
        /**
         * Remove centroid marker from component - COMPONENT-FIRST APPROACH
         */
        function removeCentroidMarkerPixels(componentPixels, knownCentroidUnits = null) {
            if (componentPixels.length < 20) {
                return componentPixels;
            }
            
            // Calculate component center (used by multiple methods)
            let sumX = 0, sumY = 0;
            for (const p of componentPixels) {
                sumX += p.x;
                sumY += p.y;
            }
            const compCenterX = Math.round(sumX / componentPixels.length);
            const compCenterY = Math.round(sumY / componentPixels.length);
            
            // METHOD 1: Check if entire component is a marker (isolated marker)
            if (isMarkerComponent(componentPixels)) {
                console.log(`  üéØ Component detected as isolated marker (${componentPixels.length}px), center=(${compCenterX}, ${compCenterY})`);
                return []; // Remove entire component
            }
            
            // METHOD 2: Use Sheets centroid to find and remove embedded marker
            if (knownCentroidUnits && !isNaN(knownCentroidUnits.x) && !isNaN(knownCentroidUnits.y)) {
                const pixelPos = unitToCanvas(knownCentroidUnits.x, knownCentroidUnits.y);
                const sheetsCx = Math.round(pixelPos.x);
                const sheetsCy = Math.round(pixelPos.y);
                
                // Check distance from Sheets centroid to component center
                const distToCenter = Math.sqrt((compCenterX - sheetsCx) ** 2 + (compCenterY - sheetsCy) ** 2);
                
                // Also find nearest pixel to Sheets centroid
                let nearestDist = Infinity;
                for (const p of componentPixels) {
                    const dist = Math.sqrt((p.x - sheetsCx) ** 2 + (p.y - sheetsCy) ** 2);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                    }
                }
                
                // If Sheets centroid is reasonably close, try marker removal there
                if (nearestDist <= 50 || distToCenter <= 100) {
                    console.log(`  üìç Trying Sheets centroid (${sheetsCx}, ${sheetsCy}), nearest=${nearestDist.toFixed(1)}px, toCenter=${distToCenter.toFixed(1)}px`);
                    const result = removeMarkerAtLocation(componentPixels, sheetsCx, sheetsCy);
                    if (result.length < componentPixels.length) {
                        return result;
                    }
                }
            }
            
            // METHOD 3: Estimate centroid from component and try removal
            // For components large enough to potentially contain an embedded marker
            if (componentPixels.length > 300) {
                console.log(`  üìç Trying estimated center (${compCenterX}, ${compCenterY}) for ${componentPixels.length}px component`);
                const result = removeMarkerAtLocation(componentPixels, compCenterX, compCenterY);
                if (result.length < componentPixels.length) {
                    return result;
                }
            }
            
            return componentPixels;
        }
        
        
        function extractOuterContour(component) {
            if (component.length < 10) return [];
            
            // Create a grid for fast lookup
            const grid = new Set();
            component.forEach(p => grid.add(`${p.x},${p.y}`));
            
            // Find boundary pixels (pixels with at least one non-component neighbor)
            const boundary = [];
            
            for (const p of component) {
                let isBoundary = false;
                
                // Check 8-connected neighbors
                for (let dx = -1; dx <= 1 && !isBoundary; dx++) {
                    for (let dy = -1; dy <= 1 && !isBoundary; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        const nkey = `${p.x + dx},${p.y + dy}`;
                        if (!grid.has(nkey)) {
                            isBoundary = true;
                        }
                    }
                }
                
                if (isBoundary) {
                    boundary.push(p);
                }
            }
            
            return boundary;
        }
        
        // ============================================
        // GAP FILLING UTILITIES
        // ============================================
        
        function fillGapWithStraightLine(p1, p2) {
            // Generate points along a straight line from p1 to p2
            const points = [];
            const dist = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
            const numPoints = Math.max(2, Math.ceil(dist));
            
            for (let i = 1; i < numPoints; i++) {
                const t = i / numPoints;
                points.push({
                    x: Math.round(p1.x + (p2.x - p1.x) * t),
                    y: Math.round(p1.y + (p2.y - p1.y) * t)
                });
            }
            
            return points;
        }
        
        /**
         * Ensure a contour is fully closed by connecting first and last points
         * Ensures contour is closed, using tangent-aware closure when endpoints are far apart
         * Uses endpoint tangent directions to create a smoother closure path
         * @param {Array} contour - Contour to close
         * @param {Object} centroid - Shape centroid (unused but kept for API consistency)
         * @returns {Array} - Closed contour
         */
        function ensureContourClosed(contour, centroid) {
            if (!contour || contour.length < 3) return contour;
            
            const first = contour[0];
            const last = contour[contour.length - 1];
            const dist = Math.sqrt((first.x - last.x) ** 2 + (first.y - last.y) ** 2);
            
            // If start and end are far apart, close with a path that respects endpoint tangents
            if (dist > 2) {
                // Get tangent at the end of the contour (direction we're traveling)
                const LOOKBACK = Math.min(5, Math.floor(contour.length / 4));
                const endTangent = getContourTangent(contour, contour.length - 1, LOOKBACK);
                
                // Get tangent at the start (direction we need to enter)
                const startTangent = getContourTangent(contour, 0, LOOKBACK);
                
                // For small gaps, just use straight line
                if (dist <= 20) {
                    const closurePoints = fillGapWithStraightLine(last, first);
                    if (closurePoints.length > 0) {
                        console.log(`    üîí Final closure: connected endpoints ${dist.toFixed(1)}px apart with straight line`);
                        return [...contour, ...closurePoints];
                    }
                } else {
                    // For larger gaps, create a curved path using control points
                    // that respect the tangent directions at each endpoint
                    const closurePoints = [];
                    const steps = Math.max(10, Math.floor(dist / 5));
                    
                    // Control point distance (how far to extend in tangent direction)
                    const controlDist = dist * 0.3;
                    
                    // Control point 1: extend from last point in its tangent direction
                    const cp1x = last.x + endTangent.x * controlDist;
                    const cp1y = last.y + endTangent.y * controlDist;
                    
                    // Control point 2: extend from first point opposite to its tangent direction
                    // (since we're approaching it, not leaving it)
                    const cp2x = first.x - startTangent.x * controlDist;
                    const cp2y = first.y - startTangent.y * controlDist;
                    
                    // Generate cubic Bezier curve points
                    for (let i = 1; i <= steps; i++) {
                        const t = i / steps;
                        const t2 = t * t;
                        const t3 = t2 * t;
                        const mt = 1 - t;
                        const mt2 = mt * mt;
                        const mt3 = mt2 * mt;
                        
                        // Cubic Bezier: B(t) = (1-t)¬≥P0 + 3(1-t)¬≤tP1 + 3(1-t)t¬≤P2 + t¬≥P3
                        const x = mt3 * last.x + 3 * mt2 * t * cp1x + 3 * mt * t2 * cp2x + t3 * first.x;
                        const y = mt3 * last.y + 3 * mt2 * t * cp1y + 3 * mt * t2 * cp2y + t3 * first.y;
                        
                        closurePoints.push({ x: Math.round(x), y: Math.round(y) });
                    }
                    
                    console.log(`    üîí Final closure: connected endpoints ${dist.toFixed(1)}px apart with tangent-aware curve`);
                    return [...contour, ...closurePoints];
                }
            }
            
            return contour;
        }
        
        // ============================================
        // FILLED SHAPE OUTER CONTOUR (for centroid marker filtering)
        // ============================================
        
        function getFilledShapeBoundingBox(component) {
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            for (const p of component) {
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y);
                maxY = Math.max(maxY, p.y);
            }
            
            return { minX, maxX, minY, maxY, width: maxX - minX, height: maxY - minY };
        }
        
        function treatAsFilled(component) {
            // Create a filled version of the shape by flood-filling the interior
            // This helps identify the true outer contour vs internal holes
            
            const bbox = getFilledShapeBoundingBox(component);
            const { minX, maxX, minY, maxY } = bbox;
            
            // Create a grid of the component
            const grid = new Set();
            component.forEach(p => grid.add(`${p.x},${p.y}`));
            
            // Create a binary image of the region
            const width = maxX - minX + 3;
            const height = maxY - minY + 3;
            const image = new Array(height).fill(null).map(() => new Array(width).fill(0));
            
            // Mark component pixels
            for (const p of component) {
                const x = p.x - minX + 1;
                const y = p.y - minY + 1;
                if (x >= 0 && x < width && y >= 0 && y < height) {
                    image[y][x] = 1;
                }
            }
            
            // Flood fill from outside to mark exterior
            const exterior = new Array(height).fill(null).map(() => new Array(width).fill(false));
            const stack = [{ x: 0, y: 0 }];
            
            while (stack.length > 0) {
                const { x, y } = stack.pop();
                
                if (x < 0 || x >= width || y < 0 || y >= height) continue;
                if (exterior[y][x] || image[y][x] === 1) continue;
                
                exterior[y][x] = true;
                
                stack.push({ x: x + 1, y });
                stack.push({ x: x - 1, y });
                stack.push({ x, y: y + 1 });
                stack.push({ x, y: y - 1 });
            }
            
            // Interior pixels are those not marked as exterior and not part of original shape
            const filledPixels = [];
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (!exterior[y][x]) {
                        filledPixels.push({
                            x: x + minX - 1,
                            y: y + minY - 1
                        });
                    }
                }
            }
            
            return filledPixels;
        }
        
        function extractOuterContourFromFilled(component) {
            // First treat the shape as filled
            const filledPixels = treatAsFilled(component);
            
            if (filledPixels.length < 10) {
                // Fall back to original boundary extraction
                return extractOuterContour(component);
            }
            
            // Extract boundary from filled pixels
            return extractBoundaryFromFilledPixels(filledPixels);
        }
        
        /**
         * Extract outer boundary from already-filled pixel set
         * Use this when pixels are already the result of treatAsFilled()
         */
        function extractBoundaryFromFilledPixels(filledPixels) {
            if (filledPixels.length < 10) {
                return filledPixels; // Not enough pixels for boundary extraction
            }
            
            // Extract the outer boundary of the filled shape
            const grid = new Set();
            filledPixels.forEach(p => grid.add(`${p.x},${p.y}`));
            
            const boundary = [];
            
            for (const p of filledPixels) {
                let isBoundary = false;
                
                // Check 4-connected neighbors (more strict for outer contour)
                const neighbors = [
                    { dx: 1, dy: 0 },
                    { dx: -1, dy: 0 },
                    { dx: 0, dy: 1 },
                    { dx: 0, dy: -1 }
                ];
                
                for (const { dx, dy } of neighbors) {
                    const nkey = `${p.x + dx},${p.y + dy}`;
                    if (!grid.has(nkey)) {
                        isBoundary = true;
                        break;
                    }
                }
                
                if (isBoundary) {
                    boundary.push(p);
                }
            }
            
            return boundary;
        }
        
        function orderBoundaryPixels(boundary) {
            if (boundary.length < 3) return boundary;
            
            // Create a grid for fast lookup
            const boundarySet = new Set();
            boundary.forEach(p => boundarySet.add(`${p.x},${p.y}`));
            
            // Start with the topmost-leftmost point
            let startPixel = boundary[0];
            for (const p of boundary) {
                if (p.y < startPixel.y || (p.y === startPixel.y && p.x < startPixel.x)) {
                    startPixel = p;
                }
            }
            
            const ordered = [startPixel];
            const visited = new Set();
            visited.add(`${startPixel.x},${startPixel.y}`);
            
            let current = startPixel;
            let prevDirection = 0; // Start going right
            
            // 8-directional neighbor offsets (clockwise from right)
            const dx = [1, 1, 0, -1, -1, -1, 0, 1];
            const dy = [0, 1, 1, 1, 0, -1, -1, -1];
            
            while (ordered.length < boundary.length) {
                let foundNext = false;
                
                // Search for next boundary pixel in clockwise order from previous direction
                // This creates a continuous chain following the contour
                for (let offset = 0; offset < 8; offset++) {
                    // Start from the direction we came from + 5 (to continue around the shape)
                    const dir = (prevDirection + 5 + offset) % 8;
                    const nx = current.x + dx[dir];
                    const ny = current.y + dy[dir];
                    const key = `${nx},${ny}`;
                    
                    if (boundarySet.has(key) && !visited.has(key)) {
                        ordered.push({ x: nx, y: ny });
                        visited.add(key);
                        current = { x: nx, y: ny };
                        prevDirection = dir;
                        foundNext = true;
                        break;
                    }
                }
                
                if (!foundNext) {
                    // If no adjacent neighbor found, look for closest unvisited pixel
                    let nearestDist = Infinity;
                    let nearest = null;
                    let nearestDir = 0;
                    
                    for (const p of boundary) {
                        const key = `${p.x},${p.y}`;
                        if (!visited.has(key)) {
                            const dist = Math.sqrt((p.x - current.x) ** 2 + (p.y - current.y) ** 2);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearest = p;
                                // Calculate direction to nearest
                                nearestDir = Math.round(Math.atan2(p.y - current.y, p.x - current.x) / (Math.PI / 4) + 4) % 8;
                            }
                        }
                    }
                    
                    if (nearest) {
                        ordered.push(nearest);
                        visited.add(`${nearest.x},${nearest.y}`);
                        current = nearest;
                        prevDirection = nearestDir;
                    } else {
                        break; // No more pixels to visit
                    }
                }
            }
            
            return ordered;
        }
        
        /**
         * Order boundary pixels with vector-direction based component connection.
         * When hitting a gap (no adjacent neighbor), calculates the direction vector
         * from the last N points and finds the next component point that best 
         * continues that trajectory.
         * 
         * @param {Array} boundary - Unordered boundary pixels
         * @returns {Array} - Ordered boundary pixels with vector-connected components
         */
        function orderBoundaryPixelsWithVectorConnection(boundary) {
            if (boundary.length < 3) return boundary;
            
            // Create a grid for fast lookup
            const boundarySet = new Set();
            boundary.forEach(p => boundarySet.add(`${p.x},${p.y}`));
            
            // Start with the topmost-leftmost point
            let startPixel = boundary[0];
            for (const p of boundary) {
                if (p.y < startPixel.y || (p.y === startPixel.y && p.x < startPixel.x)) {
                    startPixel = p;
                }
            }
            
            const ordered = [startPixel];
            const visited = new Set();
            visited.add(`${startPixel.x},${startPixel.y}`);
            
            let current = startPixel;
            let prevDirection = 0; // Start going right
            
            // 8-directional neighbor offsets (clockwise from right)
            const dx = [1, 1, 0, -1, -1, -1, 0, 1];
            const dy = [0, 1, 1, 1, 0, -1, -1, -1];
            
            // Track component connections for logging
            let componentConnections = 0;
            
            while (ordered.length < boundary.length) {
                let foundNext = false;
                
                // Search for next boundary pixel in clockwise order from previous direction
                for (let offset = 0; offset < 8; offset++) {
                    const dir = (prevDirection + 5 + offset) % 8;
                    const nx = current.x + dx[dir];
                    const ny = current.y + dy[dir];
                    const key = `${nx},${ny}`;
                    
                    if (boundarySet.has(key) && !visited.has(key)) {
                        ordered.push({ x: nx, y: ny });
                        visited.add(key);
                        current = { x: nx, y: ny };
                        prevDirection = dir;
                        foundNext = true;
                        break;
                    }
                }
                
                if (!foundNext) {
                    // GAP DETECTED: Use vector direction to find next component
                    // Calculate direction vector from last N points (weighted average)
                    const lookback = Math.min(20, ordered.length - 1);
                    
                    if (lookback >= 5) {
                        // Calculate weighted direction vector from recent points
                        let vecX = 0, vecY = 0;
                        let totalWeight = 0;
                        
                        for (let i = 0; i < lookback; i++) {
                            const idx = ordered.length - 1 - i;
                            const prevIdx = idx - 1;
                            if (prevIdx >= 0) {
                                const weight = lookback - i; // More recent points have higher weight
                                const segDx = ordered[idx].x - ordered[prevIdx].x;
                                const segDy = ordered[idx].y - ordered[prevIdx].y;
                                vecX += segDx * weight;
                                vecY += segDy * weight;
                                totalWeight += weight;
                            }
                        }
                        
                        if (totalWeight > 0) {
                            vecX /= totalWeight;
                            vecY /= totalWeight;
                            
                            // Normalize direction vector
                            const vecLen = Math.sqrt(vecX * vecX + vecY * vecY);
                            if (vecLen > 0.001) {
                                vecX /= vecLen;
                                vecY /= vecLen;
                                
                                // Find unvisited point closest to the projected line
                                let bestScore = -Infinity;
                                let bestPoint = null;
                                let bestDir = 0;
                                
                                for (const p of boundary) {
                                    const key = `${p.x},${p.y}`;
                                    if (!visited.has(key)) {
                                        // Vector from current to candidate
                                        const toCandX = p.x - current.x;
                                        const toCandY = p.y - current.y;
                                        const dist = Math.sqrt(toCandX * toCandX + toCandY * toCandY);
                                        
                                        if (dist > 0) {
                                            // Dot product gives alignment with direction vector
                                            const dot = (toCandX * vecX + toCandY * vecY) / dist;
                                            
                                            // Score combines alignment (strongly prefer forward) and proximity
                                            // Forward direction (dot > 0) is heavily weighted
                                            // Penalize distance, but not too much
                                            const alignmentScore = dot * 100; // Range: -100 to +100
                                            const distancePenalty = dist * 0.5;
                                            const score = alignmentScore - distancePenalty;
                                            
                                            if (score > bestScore) {
                                                bestScore = score;
                                                bestPoint = p;
                                                // Calculate direction to best point (pure Cartesian)
                                                bestDir = getCartesianDirection8(toCandX, toCandY);
                                            }
                                        }
                                    }
                                }
                                
                                if (bestPoint) {
                                    componentConnections++;
                                    const jumpDist = Math.sqrt((bestPoint.x - current.x) ** 2 + (bestPoint.y - current.y) ** 2);
                                    console.log(`    üîó Vector connection #${componentConnections}: jumped ${jumpDist.toFixed(1)}px (score: ${bestScore.toFixed(1)})`);
                                    
                                    ordered.push(bestPoint);
                                    visited.add(`${bestPoint.x},${bestPoint.y}`);
                                    current = bestPoint;
                                    prevDirection = bestDir;
                                    continue;
                                }
                            }
                        }
                    }
                    
                    // Fallback: find nearest unvisited pixel (for very short contours or edge cases)
                    let nearestDist = Infinity;
                    let nearest = null;
                    let nearestDir = 0;
                    
                    for (const p of boundary) {
                        const key = `${p.x},${p.y}`;
                        if (!visited.has(key)) {
                            const dist = Math.sqrt((p.x - current.x) ** 2 + (p.y - current.y) ** 2);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearest = p;
                                nearestDir = getCartesianDirection8(p.x - current.x, p.y - current.y);
                            }
                        }
                    }
                    
                    if (nearest) {
                        if (nearestDist > 3) {
                            componentConnections++;
                            console.log(`    üîó Fallback connection #${componentConnections}: jumped ${nearestDist.toFixed(1)}px to nearest`);
                        }
                        ordered.push(nearest);
                        visited.add(`${nearest.x},${nearest.y}`);
                        current = nearest;
                        prevDirection = nearestDir;
                    } else {
                        break; // No more pixels to visit
                    }
                }
            }
            
            if (componentConnections > 0) {
                console.log(`    ‚úÖ Total vector connections: ${componentConnections}`);
            }
            
            return ordered;
        }
        
        /**
         * NEW APPROACH: Trace each connected component's boundary separately,
         * then merge them using curvature-aware endpoint matching.
         * This better handles shapes split by overlapping colors.
         * 
         * @param {Array} allPixels - All pixels (may contain multiple disconnected components)
         * @param {number} width - Image width
         * @param {number} height - Image height
         * @returns {Object} - { orderedContour, componentCount, gapsFilled }
         */
        function traceComponentsWithSmartMerge(allPixels, width, height) {
            // Step 1: Find connected components
            const components = findConnectedComponents(allPixels, width, height);
            
            if (components.length === 0) {
                return { orderedContour: [], componentCount: 0, gapsFilled: 0 };
            }
            
            if (components.length === 1) {
                // Single component - just trace its boundary
                const boundary = extractOuterContourFromFilled(components[0]);
                const ordered = orderBoundaryPixelsSimple(boundary);
                return { orderedContour: ordered, componentCount: 1, gapsFilled: 0 };
            }
            
            console.log(`    üß© Found ${components.length} disconnected components - using smart merge`);
            
            // Step 2: Trace each component's boundary separately
            const componentContours = [];
            for (let i = 0; i < components.length; i++) {
                const boundary = extractOuterContourFromFilled(components[i]);
                const ordered = orderBoundaryPixelsSimple(boundary);
                if (ordered.length >= 3) {
                    componentContours.push({
                        contour: ordered,
                        pixelCount: components[i].length,
                        index: i
                    });
                }
            }
            
            if (componentContours.length === 0) {
                return { orderedContour: [], componentCount: 0, gapsFilled: 0 };
            }
            
            if (componentContours.length === 1) {
                return { orderedContour: componentContours[0].contour, componentCount: 1, gapsFilled: 0 };
            }
            
            // Step 3: Find optimal merge points between components
            // For each pair of components, find the closest points that have compatible tangent directions
            const mergedContour = mergeComponentContours(componentContours);
            
            return {
                orderedContour: mergedContour.contour,
                componentCount: componentContours.length,
                gapsFilled: mergedContour.gapsCreated
            };
        }
        
        /**
         * Simple boundary ordering for a single connected component
         * Uses standard contour tracing without gap-jumping
         */
        function orderBoundaryPixelsSimple(boundary) {
            if (boundary.length < 3) return boundary;
            
            const boundarySet = new Set();
            boundary.forEach(p => boundarySet.add(`${p.x},${p.y}`));
            
            // Start with topmost-leftmost point
            let startPixel = boundary[0];
            for (const p of boundary) {
                if (p.y < startPixel.y || (p.y === startPixel.y && p.x < startPixel.x)) {
                    startPixel = p;
                }
            }
            
            const ordered = [startPixel];
            const visited = new Set();
            visited.add(`${startPixel.x},${startPixel.y}`);
            
            let current = startPixel;
            let prevDirection = 0;
            
            const dx = [1, 1, 0, -1, -1, -1, 0, 1];
            const dy = [0, 1, 1, 1, 0, -1, -1, -1];
            
            while (ordered.length < boundary.length) {
                let foundNext = false;
                
                for (let offset = 0; offset < 8; offset++) {
                    const dir = (prevDirection + 5 + offset) % 8;
                    const nx = current.x + dx[dir];
                    const ny = current.y + dy[dir];
                    const key = `${nx},${ny}`;
                    
                    if (boundarySet.has(key) && !visited.has(key)) {
                        ordered.push({ x: nx, y: ny });
                        visited.add(key);
                        current = { x: nx, y: ny };
                        prevDirection = dir;
                        foundNext = true;
                        break;
                    }
                }
                
                if (!foundNext) break; // End of this component's boundary
            }
            
            return ordered;
        }
        
        /**
         * Merge multiple component contours into a single contour
         * Uses tangent-aware endpoint matching to find where components should connect
         */
        function mergeComponentContours(componentContours) {
            if (componentContours.length === 1) {
                return { contour: componentContours[0].contour, gapsCreated: 0 };
            }
            
            // Start with the largest component
            componentContours.sort((a, b) => b.pixelCount - a.pixelCount);
            
            let mergedContour = [...componentContours[0].contour];
            let remainingComponents = componentContours.slice(1);
            let gapsCreated = 0;
            
            while (remainingComponents.length > 0) {
                // Find the best connection point between merged contour and remaining components
                let bestMatch = null;
                let bestScore = -Infinity;
                let bestComponentIdx = -1;
                
                for (let cIdx = 0; cIdx < remainingComponents.length; cIdx++) {
                    const component = remainingComponents[cIdx];
                    
                    // Try to find matching endpoints with compatible tangents
                    const match = findBestConnectionPoint(mergedContour, component.contour);
                    
                    if (match && match.score > bestScore) {
                        bestScore = match.score;
                        bestMatch = match;
                        bestComponentIdx = cIdx;
                    }
                }
                
                if (bestMatch && bestComponentIdx >= 0) {
                    // Merge the component into the main contour at the best connection point
                    const componentToMerge = remainingComponents[bestComponentIdx];
                    mergedContour = spliceContours(mergedContour, componentToMerge.contour, bestMatch);
                    remainingComponents.splice(bestComponentIdx, 1);
                    gapsCreated += 2; // Two gap-jumps per merge (in and out)
                    console.log(`    üîó Merged component (${componentToMerge.contour.length} pts) - score: ${bestScore.toFixed(1)}`);
                } else {
                    // Fallback: just append remaining components
                    for (const comp of remainingComponents) {
                        mergedContour = mergedContour.concat(comp.contour);
                        gapsCreated++;
                    }
                    break;
                }
            }
            
            return { contour: mergedContour, gapsCreated };
        }
        
        /**
         * Find the best point to connect two contours based on:
         * 1. Distance between points
         * 2. Tangent compatibility (the contours should "flow" into each other)
         */
        function findBestConnectionPoint(contour1, contour2) {
            // Safety check - need valid contours
            if (!contour1 || !contour2 || contour1.length < 2 || contour2.length < 2) {
                return null;
            }
            
            const TANGENT_LOOKBACK = 5; // Points to use for tangent calculation
            
            let bestScore = -Infinity;
            let bestMatch = null;
            
            // Check every point in contour1 against every point in contour2
            // (Optimization: could sample for large contours)
            const step1 = Math.max(1, Math.floor(contour1.length / 50));
            const step2 = Math.max(1, Math.floor(contour2.length / 50));
            
            for (let i = 0; i < contour1.length; i += step1) {
                const p1 = contour1[i];
                if (!p1) continue;
                const tangent1 = getContourTangent(contour1, i, TANGENT_LOOKBACK);
                
                for (let j = 0; j < contour2.length; j += step2) {
                    const p2 = contour2[j];
                    if (!p2) continue;
                    const tangent2 = getContourTangent(contour2, j, TANGENT_LOOKBACK);
                    
                    // Distance between points
                    const dist = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
                    
                    // Direction from p1 to p2
                    const toP2x = (p2.x - p1.x) / (dist + 0.001);
                    const toP2y = (p2.y - p1.y) / (dist + 0.001);
                    
                    // Tangent compatibility:
                    // tangent1 should point TOWARD p2 (dot product with toP2 should be positive)
                    // tangent2 should point AWAY from p1 (dot product with toP2 should be negative, 
                    // or we're entering the contour in the right direction)
                    const align1 = tangent1.x * toP2x + tangent1.y * toP2y; // Should be positive
                    const align2 = tangent2.x * toP2x + tangent2.y * toP2y; // Direction check
                    
                    // Score: prefer close points with compatible tangents
                    const distScore = 100 / (dist + 1); // Closer is better
                    const tangentScore = align1 * 50; // Positive alignment is good
                    const score = distScore + tangentScore;
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = {
                            idx1: i,
                            idx2: j,
                            p1: p1,
                            p2: p2,
                            dist: dist,
                            score: score
                        };
                    }
                }
            }
            
            return bestMatch;
        }
        
        /**
         * Get tangent direction at a point on a contour
         */
        function getContourTangent(contour, idx, lookback) {
            // Safety check - need at least 2 points
            if (!contour || contour.length < 2) {
                return { x: 1, y: 0 }; // Default tangent
            }
            
            let dx = 0, dy = 0;
            let count = 0;
            
            for (let i = 1; i <= lookback; i++) {
                const prevIdx = (idx - i + contour.length) % contour.length;
                const currIdx = (idx - i + 1 + contour.length) % contour.length;
                
                // Additional safety check
                if (!contour[prevIdx] || !contour[currIdx]) continue;
                
                dx += contour[currIdx].x - contour[prevIdx].x;
                dy += contour[currIdx].y - contour[prevIdx].y;
                count++;
            }
            
            if (count > 0) {
                dx /= count;
                dy /= count;
            }
            
            const len = Math.sqrt(dx * dx + dy * dy);
            if (len > 0.001) {
                return { x: dx / len, y: dy / len };
            }
            return { x: 1, y: 0 }; // Default tangent
        }
        
        /**
         * Splice contour2 into contour1 at the specified connection point
         */
        function spliceContours(contour1, contour2, match) {
            // Reorder contour2 to start at the connection point
            const reorderedC2 = [
                ...contour2.slice(match.idx2),
                ...contour2.slice(0, match.idx2)
            ];
            
            // Insert contour2 into contour1 at the connection point
            const result = [
                ...contour1.slice(0, match.idx1 + 1),
                ...reorderedC2,
                ...contour1.slice(match.idx1 + 1)
            ];
            
            return result;
        }
        
        /**
         * Get 8-directional index from Cartesian delta (pure Cartesian, no trig)
         * Returns: 0=right, 1=down-right, 2=down, 3=down-left, 4=left, 5=up-left, 6=up, 7=up-right
         */
        function getCartesianDirection8(dx, dy) {
            // Handle zero vector
            if (dx === 0 && dy === 0) return 0;
            
            // Use ratio-based thresholds instead of trig
            // tan(22.5¬∞) ‚âà 0.414, so if |dy/dx| < 0.414, we're closer to horizontal
            const absDx = Math.abs(dx);
            const absDy = Math.abs(dy);
            
            // Cardinal directions (within ~22.5¬∞ of axis)
            if (absDy <= absDx * 0.414) {
                return dx > 0 ? 0 : 4; // Right or Left
            }
            if (absDx <= absDy * 0.414) {
                return dy > 0 ? 2 : 6; // Down or Up
            }
            
            // Diagonal directions
            if (dx > 0 && dy > 0) return 1; // Down-right
            if (dx < 0 && dy > 0) return 3; // Down-left
            if (dx < 0 && dy < 0) return 5; // Up-left
            return 7; // Up-right
        }
        
        /**
         * Calculate adaptive sample count based on perimeter length in units.
         * Matches the drawing tool's algorithm: max(100, floor(perimeterUnits / 0.1))
         * 
         * @param {Array} pixelContour - Contour points in pixel coordinates
         * @returns {number} - Optimal sample count
         */
        function calculateAdaptiveSampleCount(pixelContour) {
            if (pixelContour.length < 2) return MIN_CONTOUR_SAMPLES;
            
            // Calculate perimeter in pixel coordinates first
            let perimeterPixels = 0;
            for (let i = 0; i < pixelContour.length; i++) {
                const p1 = pixelContour[i];
                const p2 = pixelContour[(i + 1) % pixelContour.length];
                perimeterPixels += Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
            }
            
            // Convert to units: 50 pixels = 1 unit
            const perimeterUnits = perimeterPixels / SCALE_FACTOR;
            
            // Apply drawing tool's formula: max(100, floor(perimeter / 0.1))
            const adaptiveCount = Math.max(MIN_CONTOUR_SAMPLES, Math.floor(perimeterUnits / UNITS_PER_SAMPLE));
            
            return adaptiveCount;
        }
        
        function resampleContour(contour, targetSamples) {
            if (contour.length < 2) return contour;
            
            // Calculate total path length
            let totalLength = 0;
            const segmentLengths = [];
            
            for (let i = 0; i < contour.length; i++) {
                const p1 = contour[i];
                const p2 = contour[(i + 1) % contour.length];
                const len = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
                segmentLengths.push(len);
                totalLength += len;
            }
            
            if (totalLength === 0) return contour;
            
            const sampleInterval = totalLength / targetSamples;
            const resampled = [];
            
            let currentDistance = 0;
            let segmentIndex = 0;
            let segmentProgress = 0;
            
            for (let i = 0; i < targetSamples; i++) {
                const targetDistance = (i / targetSamples) * totalLength;
                
                // Find which segment contains this target distance
                while (segmentIndex < segmentLengths.length - 1 && 
                       currentDistance + segmentLengths[segmentIndex] < targetDistance) {
                    currentDistance += segmentLengths[segmentIndex];
                    segmentIndex++;
                }
                
                // Interpolate within the segment
                const remainingDist = targetDistance - currentDistance;
                segmentProgress = segmentLengths[segmentIndex] > 0 ? 
                    remainingDist / segmentLengths[segmentIndex] : 0;
                segmentProgress = Math.max(0, Math.min(1, segmentProgress));
                
                const p1 = contour[segmentIndex];
                const p2 = contour[(segmentIndex + 1) % contour.length];
                
                resampled.push({
                    x: p1.x + (p2.x - p1.x) * segmentProgress,
                    y: p1.y + (p2.y - p1.y) * segmentProgress
                });
            }
            
            return resampled;
        }
        
        function pixelsToUnitContour(pixels) {
            return pixels.map(p => canvasToUnit(p.x, p.y));
        }
        
        /**
         * Create a circular shape from Sheets data (area + centroid)
         * Used when extraction fails or produces a shape that's too small
         * 
         * UNIT SYSTEM:
         * - Canvas is 1000√ó1000 pixels
         * - Grid ranges from -10 to +10 units (20 units total)
         * - 1 unit = 50 pixels (SCALE_FACTOR)
         * - 1 grid square = 1 unit √ó 1 unit = 1 unit¬≤
         * - Area from Sheets is in grid squares (units¬≤)
         * 
         * @param {Object} sheetsRecord - Record with centroid and area from Sheets
         * @param {number} numPoints - Number of points to use for the circle (default: 100)
         * @returns {Object} - Shape object with contour, centroid, etc.
         */
        function createShapeFromSheetsData(sheetsRecord, numPoints = 100) {
            if (!sheetsRecord || !sheetsRecord.centroid) {
                return null;
            }
            
            const cx = sheetsRecord.centroid.x;
            const cy = sheetsRecord.centroid.y;
            const area = sheetsRecord.area || 0;  // Area in units¬≤ (grid squares)
            
            // Calculate radius from area: A = œÄr¬≤ ‚Üí r = ‚àö(A/œÄ)
            // Area and radius are both in unit space (1 unit = 1 grid square width)
            const radius = Math.sqrt(Math.abs(area) / Math.PI);
            
            // For very small areas, use a minimum visible radius
            const effectiveRadius = Math.max(radius, 0.1); // Minimum 0.1 units for visibility
            
            // Create circular contour with the calculated radius
            const unitContour = [];
            for (let i = 0; i < numPoints; i++) {
                const angle = (2 * Math.PI * i) / numPoints;
                unitContour.push({
                    x: cx + effectiveRadius * Math.cos(angle),
                    y: cy + effectiveRadius * Math.sin(angle)
                });
            }
            
            // Convert to pixel coordinates for pixelContour
            const pixelContour = unitContour.map(p => {
                const pixel = unitToCanvas(p.x, p.y);
                return { x: Math.round(pixel.x), y: Math.round(pixel.y) };
            });
            
            const pixelCenter = unitToCanvas(cx, cy);
            
            return {
                contour: unitContour,
                pixelContour: pixelContour,
                rawPixels: pixelContour,
                centroid: { x: cx, y: cy },
                pixelCentroid: { x: Math.round(pixelCenter.x), y: Math.round(pixelCenter.y) },
                pixelCount: pixelContour.length,
                gapsFilled: 0,
                usedSheetsCentroid: true,
                sampleCount: numPoints,
                createdFromSheetsData: true,
                sheetsArea: area,
                sheetsRadius: effectiveRadius
            };
        }
        
        // ============================================
        // MAIN SHAPE EXTRACTION FROM IMAGE
        // ============================================
        
        function extractShapesFromImage(imageData, knownRedCentroid = null, knownBlueCentroid = null) {
            const width = imageData.width;
            const height = imageData.height;
            
            // Extract red and blue pixels
            const redPixels = extractColoredPixels(imageData, isRedPixel);
            const bluePixels = extractColoredPixels(imageData, isBluePixel);
            
            // Find connected components
            const redComponents = findConnectedComponents(redPixels, width, height);
            const blueComponents = findConnectedComponents(bluePixels, width, height);
            
            // Filter out centroid markers and extract main shapes
            // For each color, we expect ONE main shape per image (the participant's drawing)
            // The centroid marker is typically smaller
            
            const redShapes = [];
            const blueShapes = [];
            let redGapsFilled = 0;
            let blueGapsFilled = 0;
            
            // Diagnostic tracking for extraction failures
            let redExtractionNote = null;
            let blueExtractionNote = null;
            
            // Process red components - combine all and remove markers at pixel level
            // This matches how the drawing tool treats all strokes of the same color as one shape
            // The centroid is the mean of ALL pixels, not just one component
            let allCleanedRedPixels = [];
            let redMarkerPixelsRemoved = 0;
            
            for (const component of redComponents) {
                // Skip tiny components (anti-aliasing artifacts, grid noise)
                if (component.length < 10) {
                    console.log(`  üî¥ Skipping tiny red component: ${component.length}px`);
                    continue;
                }
                
                // Skip components in the statistics text region (top-left corner)
                const avgY = component.reduce((sum, p) => sum + p.y, 0) / component.length;
                const avgX = component.reduce((sum, p) => sum + p.x, 0) / component.length;
                if (avgY < 120 && avgX < 350) {
                    console.log(`  üî¥ Skipping text region component: ${component.length}px at (${avgX.toFixed(0)}, ${avgY.toFixed(0)})`);
                    continue;
                }
                
                // Log each component for debugging
                console.log(`  üî¥ Processing red component: ${component.length}px`);
                
                // Pixel-level marker removal on THIS component
                // Uses Sheets centroid as hint, falls back to template scan
                const cleanedComponent = removeCentroidMarkerPixels(component, knownRedCentroid);
                redMarkerPixelsRemoved += (component.length - cleanedComponent.length);
                
                // Only add if there are pixels remaining after marker removal
                if (cleanedComponent.length > 0) {
                    allCleanedRedPixels = allCleanedRedPixels.concat(cleanedComponent);
                } else {
                    console.log(`  üóëÔ∏è Entire component removed as marker (${component.length}px)`);
                }
            }
            
            if (redMarkerPixelsRemoved > 0) {
                console.log(`  üî¥ Red: removed ${redMarkerPixelsRemoved} marker pixels from ${redComponents.length} component(s)`);
            }
            
            // Use all combined cleaned pixels (marker removal already done per-component)
            let redComponentToUse = allCleanedRedPixels.length > 0 ? allCleanedRedPixels : null;
            
            if (redComponentToUse && redComponentToUse.length >= 1) {
                console.log(`  üî¥ Red shape: ${redComponentToUse.length} total cleaned pixels`);
                
                // PRIMARY DATA: Raw pixels after marker removal (already cleaned per-component)
                // These are stored and used for composite visualization (1:1 accuracy)
                // TRACING: Only done to create contour needed for:
                //   1. Centroid calculation (must match drawing tool's contour-based method)
                //   2. Shape averaging across participants (requires aligned contours)
                //   3. Component connection when shape has multiple disconnected parts
                if (redComponentToUse.length >= 3) {
                    // IMPORTANT: Use treatAsFilled to reconnect fragments before component check
                    // This handles cases where marker removal created small gaps in the shape
                    const filledPixels = treatAsFilled(redComponentToUse);
                    const components = findConnectedComponents(filledPixels, 1000, 1000);
                    let orderedContour;
                    
                    if (components.length > 1) {
                        // Multiple components still exist after filling - use smart merge
                        console.log(`  üî¥ Red shape: ${components.length} components after fill, using smart merge...`);
                        const mergeResult = traceComponentsWithSmartMerge(filledPixels, 1000, 1000);
                        orderedContour = mergeResult.orderedContour;
                        redGapsFilled = mergeResult.gapsCreated;
                    } else {
                        // Single component - trace boundary for centroid/averaging only
                        // Use extractBoundaryFromFilledPixels since pixels are already filled
                        const boundary = extractBoundaryFromFilledPixels(filledPixels);
                        console.log(`  üî¥ Red shape: single filled component, tracing boundary...`);
                        orderedContour = orderBoundaryPixelsWithVectorConnection(boundary);
                        redGapsFilled = 0;
                    }
                    
                    // Ensure the contour is fully closed
                    const finalContour = ensureContourClosed(orderedContour, null);
                    
                    if (finalContour.length >= 3) {
                        // Calculate adaptive sample count based on perimeter
                        const adaptiveSamples = calculateAdaptiveSampleCount(finalContour);
                        console.log(`  üìê Red shape: adaptive sample count = ${adaptiveSamples} (min: 100)`);
                        const resampled = resampleContour(finalContour, adaptiveSamples);
                        
                        // CENTROID: Calculate from uniformly resampled contour (matches drawing tool)
                        const extractedCentroidPixel = calculateContourCentroidLikeDrawingTool(resampled);
                        
                        // Translate shape to match Sheets centroid exactly (ground truth)
                        // Use redComponentToUse (cleaned pixels) for display - NOT filledPixels!
                        // filledPixels is only for tracing the boundary contour
                        const translated = translateShapeToSheetsCentroid(
                            redComponentToUse,  // Original cleaned pixels for outline display
                            resampled, 
                            extractedCentroidPixel, 
                            knownRedCentroid
                        );
                        
                        console.log(`  üìç Red centroid: (${translated.centroidUnit.x.toFixed(3)}, ${translated.centroidUnit.y.toFixed(3)})`);
                        
                        const unitContour = pixelsToUnitContour(translated.contour);
                        
                        // Store shape with translated data (matched to Sheets centroid)
                        redShapes.push({
                            contour: unitContour,                    // Traced contour in units - for averaging
                            pixelContour: translated.contour,        // Traced contour in pixels (translated)
                            rawPixels: translated.rawPixels,         // PRIMARY: Pixels for 1:1 display (translated)
                            centroid: translated.centroidUnit,
                            pixelCentroid: translated.centroidPixel,
                            pixelCount: redComponentToUse.length,    // Cleaned outline pixel count (not filled)
                            gapsFilled: redGapsFilled,
                            usedSheetsCentroid: !!knownRedCentroid,
                            wasTranslated: translated.wasTranslated,
                            translationOffset: translated.offset,
                            sampleCount: adaptiveSamples
                        });
                    } else {
                        // Contour too small - will use Sheets data
                        console.log(`  ‚ö†Ô∏è Red shape: contour too small (${finalContour.length} pts) - will use Sheets data`);
                        redExtractionNote = `contour too small (${finalContour.length} pts)`;
                    }
                }
            } else if (redComponents.length > 0) {
                // All pixels were removed as marker pixels - will use Sheets data
                redExtractionNote = `all pixels from ${redComponents.length} components were marker pixels`;
                console.log(`  ‚ö†Ô∏è Red shape: ${redExtractionNote} - will use Sheets data`);
            } else {
                redExtractionNote = `no red pixels found`;
                console.log(`  ‚ö†Ô∏è Red shape: ${redExtractionNote}`);
            }
            
            // Process blue components - combine all and remove markers at pixel level
            // This matches how the drawing tool treats all strokes of the same color as one shape
            // The centroid is the mean of ALL pixels, not just one component
            let allCleanedBluePixels = [];
            let blueMarkerPixelsRemoved = 0;
            
            for (const component of blueComponents) {
                // Skip tiny components (anti-aliasing artifacts, grid noise)
                if (component.length < 10) {
                    console.log(`  üîµ Skipping tiny blue component: ${component.length}px`);
                    continue;
                }
                
                // Skip components in the statistics text region (top-left corner)
                const avgY = component.reduce((sum, p) => sum + p.y, 0) / component.length;
                const avgX = component.reduce((sum, p) => sum + p.x, 0) / component.length;
                if (avgY < 120 && avgX < 350) {
                    console.log(`  üîµ Skipping text region component: ${component.length}px at (${avgX.toFixed(0)}, ${avgY.toFixed(0)})`);
                    continue;
                }
                
                // Log each component for debugging
                console.log(`  üîµ Processing blue component: ${component.length}px`);
                
                // Pixel-level marker removal on THIS component
                // Uses Sheets centroid as hint, falls back to template scan
                const cleanedComponent = removeCentroidMarkerPixels(component, knownBlueCentroid);
                blueMarkerPixelsRemoved += (component.length - cleanedComponent.length);
                
                // Only add if there are pixels remaining after marker removal
                if (cleanedComponent.length > 0) {
                    allCleanedBluePixels = allCleanedBluePixels.concat(cleanedComponent);
                } else {
                    console.log(`  üóëÔ∏è Entire component removed as marker (${component.length}px)`);
                }
            }
            
            if (blueMarkerPixelsRemoved > 0) {
                console.log(`  üîµ Blue: removed ${blueMarkerPixelsRemoved} marker pixels from ${blueComponents.length} component(s)`);
            }
            
            // Use all combined cleaned pixels (marker removal already done per-component)
            let blueComponentToUse = allCleanedBluePixels.length > 0 ? allCleanedBluePixels : null;
            
            if (blueComponentToUse && blueComponentToUse.length >= 1) {
                console.log(`  üîµ Blue shape: ${blueComponentToUse.length} total cleaned pixels`);
                
                // PRIMARY DATA: Raw pixels after marker removal (already cleaned per-component)
                // These are stored and used for composite visualization (1:1 accuracy)
                // TRACING: Only done to create contour needed for:
                //   1. Centroid calculation (must match drawing tool's contour-based method)
                //   2. Shape averaging across participants (requires aligned contours)
                //   3. Component connection when shape has multiple disconnected parts
                if (blueComponentToUse.length >= 3) {
                    // IMPORTANT: Use treatAsFilled to reconnect fragments before component check
                    // This handles cases where marker removal created small gaps in the shape
                    const filledPixels = treatAsFilled(blueComponentToUse);
                    const components = findConnectedComponents(filledPixels, 1000, 1000);
                    let orderedContour;
                    
                    if (components.length > 1) {
                        // Multiple components still exist after filling - use smart merge
                        console.log(`  üîµ Blue shape: ${components.length} components after fill, using smart merge...`);
                        const mergeResult = traceComponentsWithSmartMerge(filledPixels, 1000, 1000);
                        orderedContour = mergeResult.orderedContour;
                        blueGapsFilled = mergeResult.gapsCreated;
                    } else {
                        // Single component - trace boundary for centroid/averaging only
                        // Use extractBoundaryFromFilledPixels since pixels are already filled
                        const boundary = extractBoundaryFromFilledPixels(filledPixels);
                        console.log(`  üîµ Blue shape: single filled component, tracing boundary...`);
                        orderedContour = orderBoundaryPixelsWithVectorConnection(boundary);
                        blueGapsFilled = 0;
                    }
                    
                    const finalContour = ensureContourClosed(orderedContour, null);
                    
                    if (finalContour.length >= 3) {
                        const adaptiveSamples = calculateAdaptiveSampleCount(finalContour);
                        console.log(`  üìê Blue shape: adaptive sample count = ${adaptiveSamples} (min: 100)`);
                        const resampled = resampleContour(finalContour, adaptiveSamples);
                        
                        // CENTROID: Calculate from uniformly resampled contour (matches drawing tool)
                        const extractedCentroidPixel = calculateContourCentroidLikeDrawingTool(resampled);
                        
                        // Translate shape to match Sheets centroid exactly (ground truth)
                        // Use blueComponentToUse (cleaned pixels) for display - NOT filledPixels!
                        // filledPixels is only for tracing the boundary contour
                        const translated = translateShapeToSheetsCentroid(
                            blueComponentToUse,  // Original cleaned pixels for outline display
                            resampled, 
                            extractedCentroidPixel, 
                            knownBlueCentroid
                        );
                        
                        console.log(`  üìç Blue centroid: (${translated.centroidUnit.x.toFixed(3)}, ${translated.centroidUnit.y.toFixed(3)})`);
                        
                        const unitContour = pixelsToUnitContour(translated.contour);
                        
                        // Store shape with translated data (matched to Sheets centroid)
                        blueShapes.push({
                            contour: unitContour,                    // Traced contour in units - for averaging
                            pixelContour: translated.contour,        // Traced contour in pixels (translated)
                            rawPixels: translated.rawPixels,         // PRIMARY: Pixels for 1:1 display (translated)
                            centroid: translated.centroidUnit,
                            pixelCentroid: translated.centroidPixel,
                            pixelCount: blueComponentToUse.length,   // Cleaned outline pixel count (not filled)
                            gapsFilled: blueGapsFilled,
                            usedSheetsCentroid: !!knownBlueCentroid,
                            wasTranslated: translated.wasTranslated,
                            translationOffset: translated.offset,
                            sampleCount: adaptiveSamples
                        });
                    } else {
                        // Contour too small - will use Sheets data
                        console.log(`  ‚ö†Ô∏è Blue shape: contour too small (${finalContour.length} pts) - will use Sheets data`);
                        blueExtractionNote = `contour too small (${finalContour.length} pts)`;
                    }
                }
            } else if (blueComponents.length > 0) {
                // All pixels were removed as marker pixels - will use Sheets data
                blueExtractionNote = `all pixels from ${blueComponents.length} components were marker pixels`;
                console.log(`  ‚ö†Ô∏è Blue shape: ${blueExtractionNote} - will use Sheets data`);
            } else {
                blueExtractionNote = `no blue pixels found`;
                console.log(`  ‚ö†Ô∏è Blue shape: ${blueExtractionNote}`);
            }
            
            // ============================================
            // EXTREME OVERLAP HANDLING
            // If red has very few pixels compared to blue, the participant likely
            // perceived them as approximately the same size/shape.
            // In this case, use blue's already-traced contour for red, translated
            // to red's Sheets centroid position. This avoids re-tracing and uses
            // the pre-existing boundary from blue's extraction.
            // ============================================
            const EXTREME_OVERLAP_THRESHOLD = 0.30; // Red has < 30% of blue's pixels
            let redCopiedFromBlue = false;
            
            if (redShapes.length > 0 && blueShapes.length > 0) {
                const redPixelCount = redShapes[0].pixelCount || 0;
                const bluePixelCount = blueShapes[0].pixelCount || 0;
                
                // Check for extreme overlap (red is severely occluded by blue)
                if (bluePixelCount > 0 && redPixelCount < bluePixelCount * EXTREME_OVERLAP_THRESHOLD) {
                    const ratio = (redPixelCount / bluePixelCount * 100).toFixed(1);
                    console.log(`  ‚ö†Ô∏è EXTREME OVERLAP: Red has only ${ratio}% of blue's pixels (${redPixelCount} vs ${bluePixelCount})`);
                    console.log(`  üîÑ Using blue's traced contour for red, translated to red's Sheets centroid`);
                    
                    // Use blue's already-traced contour, translated to red's centroid from Sheets
                    // No additional tracing or gap-filling needed - blue's contour is already complete
                    const blueShape = blueShapes[0];
                    const redCentroid = knownRedCentroid || redShapes[0].centroid;
                    
                    // Translate blue's contour to red's centroid position
                    const blueCentroid = blueShape.centroid;
                    const dx = redCentroid.x - blueCentroid.x;
                    const dy = redCentroid.y - blueCentroid.y;
                    
                    const translatedContour = blueShape.contour.map(p => ({
                        x: p.x + dx,
                        y: p.y + dy
                    }));
                    
                    // Also translate rawPixels to red's position (for display)
                    // Convert unit offset to pixel offset
                    const dxPixels = dx * SCALE_FACTOR;
                    const dyPixels = -dy * SCALE_FACTOR; // Invert Y for canvas coordinates
                    
                    const translatedRawPixels = blueShape.rawPixels ? blueShape.rawPixels.map(p => ({
                        x: p.x + dxPixels,
                        y: p.y + dyPixels
                    })) : [];
                    
                    // Replace red shape with translated blue contour (same size/shape, different position)
                    // Mark as copiedFromBlue to skip additional processing
                    redShapes[0] = {
                        contour: translatedContour,
                        pixelContour: blueShape.pixelContour,
                        rawPixels: translatedRawPixels,  // Translated to red's position
                        centroid: redCentroid,
                        pixelCentroid: redShapes[0].pixelCentroid,
                        pixelCount: blueShape.pixelCount, // Use blue's pixel count (same shape)
                        gapsFilled: 0,  // No gaps - using pre-traced contour
                        usedSheetsCentroid: !!knownRedCentroid,
                        sampleCount: blueShape.sampleCount,
                        copiedFromBlue: true,  // Flag to skip closure/gap-filling
                        originalRedPixels: redPixelCount
                    };
                    
                    redCopiedFromBlue = true;
                    redExtractionNote = `extreme overlap - used blue's traced contour at red centroid (${ratio}% visible)`;
                }
            }
            
            return { 
                redShapes, 
                blueShapes,
                redGapsFilled,
                blueGapsFilled,
                redExtractionNote,
                blueExtractionNote,
                redCopiedFromBlue
            };
        }
        
        // ============================================
        // CARTESIAN AVERAGING WITH ALIGNMENT
        // ============================================
        
        function normalizeContour(contour) {
            // Normalize contour to ensure consistent winding direction (counter-clockwise)
            if (!contour || contour.length < 3) return contour;
            
            // Check winding order (sum of (x2-x1)*(y2+y1) - positive = clockwise)
            let windingSum = 0;
            for (let i = 0; i < contour.length; i++) {
                const p1 = contour[i];
                const p2 = contour[(i + 1) % contour.length];
                windingSum += (p2.x - p1.x) * (p2.y + p1.y);
            }
            
            // If clockwise, reverse to make counter-clockwise
            if (windingSum > 0) {
                return [contour[0], ...contour.slice(1).reverse()];
            }
            
            return contour;
        }
        
        function alignContoursToCentroid(shapes) {
            // Translate all contours so their centroids are at the origin
            // This allows for better shape averaging
            return shapes.map(shape => {
                const cx = shape.centroid.x;
                const cy = shape.centroid.y;
                
                // Center the contour at origin
                const centeredContour = shape.contour.map(p => ({
                    x: p.x - cx,
                    y: p.y - cy
                }));
                
                // Apply winding normalization (ensures counter-clockwise direction)
                const normalizedContour = normalizeContour(centeredContour);
                
                return {
                    ...shape,
                    originalContour: shape.contour,
                    contour: normalizedContour,
                    offset: { x: cx, y: cy }
                };
            });
        }
        
        function calculateAverageShape(shapes) {
            if (shapes.length === 0) return null;
            if (shapes.length === 1) return shapes[0].contour;
            
            // Find the maximum sample count among all shapes for consistent averaging
            // This preserves the highest resolution available
            let maxSamples = MIN_CONTOUR_SAMPLES;
            const sampleCounts = [];
            for (const shape of shapes) {
                if (shape.sampleCount) {
                    sampleCounts.push(shape.sampleCount);
                    if (shape.sampleCount > maxSamples) {
                        maxSamples = shape.sampleCount;
                    }
                }
            }
            console.log(`    üìä Averaging ${shapes.length} shapes: sample counts = [${sampleCounts.join(', ')}] ‚Üí using ${maxSamples}`);
            
            // Resample all shapes to the common count for averaging
            const resampledShapes = shapes.map(shape => {
                if (!shape.contour || shape.contour.length === 0) return shape;
                
                // If already at target count, use as-is
                if (shape.contour.length === maxSamples) {
                    return shape;
                }
                
                // Convert unit contour back to pixels for resampling, then back to units
                const pixelContour = shape.contour.map(p => unitToCanvas(p.x, p.y));
                const resampledPixels = resampleContour(pixelContour, maxSamples);
                const resampledUnits = resampledPixels.map(p => canvasToUnit(p.x, p.y));
                
                return {
                    ...shape,
                    contour: resampledUnits
                };
            });
            
            // Align all shapes to their centroids for better averaging
            const alignedShapes = alignContoursToCentroid(resampledShapes);
            
            const numPoints = maxSamples;
            const avgContour = [];
            
            // Calculate average centroid offset
            let avgOffsetX = 0, avgOffsetY = 0;
            for (const shape of alignedShapes) {
                avgOffsetX += shape.offset.x;
                avgOffsetY += shape.offset.y;
            }
            avgOffsetX /= alignedShapes.length;
            avgOffsetY /= alignedShapes.length;
            
            // Average each point in Cartesian coordinates
            for (let i = 0; i < numPoints; i++) {
                let sumX = 0, sumY = 0;
                let count = 0;
                
                for (const shape of alignedShapes) {
                    if (shape.contour && shape.contour.length === numPoints) {
                        sumX += shape.contour[i].x;
                        sumY += shape.contour[i].y;
                        count++;
                    }
                }
                
                if (count > 0) {
                    // Add back the average offset to get final position
                    avgContour.push({
                        x: sumX / count + avgOffsetX,
                        y: sumY / count + avgOffsetY
                    });
                }
            }
            
            // Final step: Resample to match drawing tool's even sampling formula
            // This ensures the median shape has evenly spaced points like the drawing tool
            return resampleContourLikeDrawingTool(avgContour);
        }
        
        /**
         * Calculate average shape with area normalization (Option A approach)
         * 
         * Strategy:
         * 1. Average all contours first (no individual scaling)
         * 2. Calculate median area of all input shapes
         * 3. Scale the final averaged shape once to match the median area
         * 
         * This avoids distortion from scaling individual shapes differently.
         */
        function calculateAverageShapeWithAreaNormalization(shapes, colorLabel = 'shapes') {
            if (shapes.length === 0) return null;
            if (shapes.length === 1) return shapes[0].contour;
            
            // Step 1: Calculate median area of all input shapes
            const areas = [];
            for (const shape of shapes) {
                if (shape.contour && shape.contour.length >= 3) {
                    const area = calculateContourArea(shape.contour);
                    if (area > 0) {
                        areas.push(area);
                    }
                }
            }
            
            if (areas.length === 0) return null;
            
            // Calculate median area
            const sortedAreas = [...areas].sort((a, b) => a - b);
            const medianArea = sortedAreas.length % 2 === 0
                ? (sortedAreas[sortedAreas.length / 2 - 1] + sortedAreas[sortedAreas.length / 2]) / 2
                : sortedAreas[Math.floor(sortedAreas.length / 2)];
            console.log(`    üìê ${colorLabel}: median area = ${medianArea.toFixed(3)} units¬≤ from ${areas.length} shapes`);
            
            // Step 2: Calculate the averaged contour using the standard method (no scaling)
            // Find the maximum sample count among all shapes
            let maxSamples = MIN_CONTOUR_SAMPLES;
            for (const shape of shapes) {
                if (shape.sampleCount && shape.sampleCount > maxSamples) {
                    maxSamples = shape.sampleCount;
                }
            }
            
            // Resample all shapes to the common count
            const resampledShapes = shapes.map(shape => {
                if (!shape.contour || shape.contour.length === 0) return shape;
                if (shape.contour.length === maxSamples) return shape;
                
                const pixelContour = shape.contour.map(p => unitToCanvas(p.x, p.y));
                const resampledPixels = resampleContour(pixelContour, maxSamples);
                const resampledUnits = resampledPixels.map(p => canvasToUnit(p.x, p.y));
                
                return { ...shape, contour: resampledUnits };
            });
            
            // Align all shapes to their centroids
            const alignedShapes = alignContoursToCentroid(resampledShapes);
            
            const numPoints = maxSamples;
            const avgContour = [];
            
            // Calculate average centroid offset
            let avgOffsetX = 0, avgOffsetY = 0;
            for (const shape of alignedShapes) {
                avgOffsetX += shape.offset.x;
                avgOffsetY += shape.offset.y;
            }
            avgOffsetX /= alignedShapes.length;
            avgOffsetY /= alignedShapes.length;
            
            // Average each point in Cartesian coordinates
            for (let i = 0; i < numPoints; i++) {
                let sumX = 0, sumY = 0;
                let count = 0;
                
                for (const shape of alignedShapes) {
                    if (shape.contour && shape.contour.length === numPoints) {
                        sumX += shape.contour[i].x;
                        sumY += shape.contour[i].y;
                        count++;
                    }
                }
                
                if (count > 0) {
                    avgContour.push({
                        x: sumX / count + avgOffsetX,
                        y: sumY / count + avgOffsetY
                    });
                }
            }
            
            if (avgContour.length === 0) return null;
            
            // Step 3: Calculate area of the averaged contour
            const avgArea = calculateContourArea(avgContour);
            
            if (avgArea === 0) {
                console.log(`    ‚ö†Ô∏è Averaged contour has zero area, returning unscaled`);
                return avgContour;
            }
            
            // Step 4: Scale the averaged contour to match the median input area
            const scaleFactor = Math.sqrt(medianArea / avgArea);
            console.log(`    üìè ${colorLabel}: scaling area ${avgArea.toFixed(3)} ‚Üí ${medianArea.toFixed(3)} (scale: ${scaleFactor.toFixed(3)})`);
            
            // Calculate centroid of averaged contour for scaling
            let cx = 0, cy = 0;
            for (const p of avgContour) {
                cx += p.x;
                cy += p.y;
            }
            cx /= avgContour.length;
            cy /= avgContour.length;
            
            // Scale around centroid
            const scaledContour = avgContour.map(p => ({
                x: cx + (p.x - cx) * scaleFactor,
                y: cy + (p.y - cy) * scaleFactor
            }));
            
            // Step 5: Resample the final contour to match drawing tool's sampling formula
            // Drawing tool uses: numSamples = Math.max(100, Math.floor(totalLength / 0.1))
            // This ensures ~10 samples per unit of path length for even spacing
            const finalContour = resampleContourLikeDrawingTool(scaledContour);
            
            return finalContour;
        }
        
        /**
         * Resample a contour using the same formula as the drawing tool
         * Drawing tool: numSamples = Math.max(100, Math.floor(totalLength / 0.1))
         * This provides ~10 samples per unit of path length for even spacing
         * 
         * @param {Array} contour - Contour in unit coordinates [{x, y}, ...]
         * @returns {Array} - Resampled contour with even spacing
         */
        function resampleContourLikeDrawingTool(contour) {
            if (!contour || contour.length < 2) return contour;
            
            // Calculate total path length in unit coordinates
            let totalLength = 0;
            const segmentLengths = [];
            
            for (let i = 0; i < contour.length; i++) {
                const p1 = contour[i];
                const p2 = contour[(i + 1) % contour.length];
                const len = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
                segmentLengths.push(len);
                totalLength += len;
            }
            
            if (totalLength === 0) return contour;
            
            // Use drawing tool's formula: at least 100 samples, or ~10 per unit length
            const numSamples = Math.max(100, Math.floor(totalLength / 0.1));
            const sampleInterval = totalLength / numSamples;
            
            const resampled = [];
            let currentDistance = 0;
            let segmentIndex = 0;
            
            // Add first point
            resampled.push({ x: contour[0].x, y: contour[0].y });
            
            // Sample remaining points evenly along the path
            for (let sample = 1; sample < numSamples; sample++) {
                const targetDistance = sample * sampleInterval;
                
                // Find which segment contains this target distance
                while (segmentIndex < segmentLengths.length && 
                       currentDistance + segmentLengths[segmentIndex] < targetDistance) {
                    currentDistance += segmentLengths[segmentIndex];
                    segmentIndex++;
                }
                
                if (segmentIndex >= segmentLengths.length) break;
                
                // Interpolate within the segment
                const remainingDist = targetDistance - currentDistance;
                const segmentProgress = segmentLengths[segmentIndex] > 0 ? 
                    remainingDist / segmentLengths[segmentIndex] : 0;
                
                const p1 = contour[segmentIndex];
                const p2 = contour[(segmentIndex + 1) % contour.length];
                
                resampled.push({
                    x: p1.x + (p2.x - p1.x) * segmentProgress,
                    y: p1.y + (p2.y - p1.y) * segmentProgress
                });
            }
            
            return resampled;
        }
        
        /**
         * Calculate the area of a contour using the shoelace formula
         */
        function calculateContourArea(contour) {
            if (!contour || contour.length < 3) return 0;
            
            let area = 0;
            for (let i = 0; i < contour.length; i++) {
                const j = (i + 1) % contour.length;
                area += contour[i].x * contour[j].y;
                area -= contour[j].x * contour[i].y;
            }
            
            return Math.abs(area / 2);
        }
        
        /**
         * Update UI when averaging mode changes
         */
        function updateAveragingMode() {
            const selectedMode = document.querySelector('input[name="averaging-mode"]:checked').value;
            averagingMode = selectedMode;
            
            // Update visual styling
            const contourLabel = document.getElementById('mode-contour-label');
            const areaLabel = document.getElementById('mode-area-label');
            
            if (selectedMode === 'contour') {
                contourLabel.classList.add('border-purple-500', 'bg-purple-50');
                contourLabel.classList.remove('border-gray-200');
                areaLabel.classList.remove('border-purple-500', 'bg-purple-50');
                areaLabel.classList.add('border-gray-200');
            } else {
                areaLabel.classList.add('border-purple-500', 'bg-purple-50');
                areaLabel.classList.remove('border-gray-200');
                contourLabel.classList.remove('border-purple-500', 'bg-purple-50');
                contourLabel.classList.add('border-gray-200');
            }
            
            console.log(`Averaging mode changed to: ${averagingMode}`);
        }
        
        // ============================================
        // STATISTICS CALCULATIONS
        // ============================================
        
        function calculateMedianRadius(shapes) {
            if (shapes.length === 0) return 0;
            
            const shapeRadii = [];
            
            for (const shape of shapes) {
                if (shape.contour && shape.contour.length > 0) {
                    // Calculate median distance from centroid to all contour points
                    const cx = shape.centroid.x;
                    const cy = shape.centroid.y;
                    
                    const distances = shape.contour.map(point => 
                        Math.sqrt((point.x - cx) ** 2 + (point.y - cy) ** 2)
                    );
                    
                    // Get median distance for this shape
                    const sorted = [...distances].sort((a, b) => a - b);
                    const mid = Math.floor(sorted.length / 2);
                    const shapeRadius = sorted.length % 2 === 0
                        ? (sorted[mid - 1] + sorted[mid]) / 2
                        : sorted[mid];
                    
                    shapeRadii.push(shapeRadius);
                }
            }
            
            if (shapeRadii.length === 0) return 0;
            
            // Return median of all shape radii
            const sorted = [...shapeRadii].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0
                ? (sorted[mid - 1] + sorted[mid]) / 2
                : sorted[mid];
        }
        
        function calculateContourMedianRadius(contour) {
            if (!contour || contour.length === 0) return 0;
            
            // Calculate centroid
            let cx = 0, cy = 0;
            for (const p of contour) {
                cx += p.x;
                cy += p.y;
            }
            cx /= contour.length;
            cy /= contour.length;
            
            // Calculate distances from centroid
            const distances = contour.map(p => 
                Math.sqrt((p.x - cx) ** 2 + (p.y - cy) ** 2)
            );
            
            // Return median distance
            const sorted = [...distances].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0
                ? (sorted[mid - 1] + sorted[mid]) / 2
                : sorted[mid];
        }
        
        /**
         * Calculate the area of a contour using the Shoelace formula
         * @param {Array} contour - Array of {x, y} points in unit coordinates
         * @returns {number} - Area in square units
         */
        /**
         * Calculate area statistics for a set of shapes
         * @param {Array} shapes - Array of shape objects with contour property
         * @returns {Object} - { median, stdDev, min, max, areas, diagnostics }
         */
        function calculateAreaStatistics(shapes) {
            if (!shapes || shapes.length === 0) {
                return { median: 0, stdDev: 0, min: 0, max: 0, areas: [], diagnostics: { total: 0, noContour: 0, shortContour: 0, zeroArea: 0, valid: 0, sheetsCreated: 0 } };
            }
            
            // Diagnostic tracking
            const diagnostics = {
                total: shapes.length,
                noContour: 0,
                shortContour: 0,
                zeroArea: 0,
                valid: 0,
                sheetsCreated: 0,  // Track shapes created from Sheets data
                excluded: []  // Track which shapes were excluded and why
            };
            
            // Calculate area for each shape with diagnostic tracking
            const areas = [];
            shapes.forEach((shape, index) => {
                // Track shapes created from Sheets
                if (shape.createdFromSheetsData) {
                    diagnostics.sheetsCreated++;
                }
                
                if (!shape.contour) {
                    diagnostics.noContour++;
                    diagnostics.excluded.push({ index, participant: shape.participant, trial: shape.trial, reason: 'no contour' });
                } else if (shape.contour.length < 3) {
                    // Shapes with fewer than 3 points = zero area
                    areas.push(0);
                    diagnostics.valid++;
                    diagnostics.zeroArea++;
                } else {
                    const area = calculateContourArea(shape.contour);
                    areas.push(area);
                    diagnostics.valid++;
                    if (area === 0) {
                        diagnostics.zeroArea++;
                    }
                }
            });
            
            if (areas.length === 0) {
                return { median: 0, stdDev: 0, min: 0, max: 0, areas: [], diagnostics };
            }
            
            // Calculate median (primary statistic)
            const sortedAreas = [...areas].sort((a, b) => a - b);
            const mid = Math.floor(sortedAreas.length / 2);
            const median = sortedAreas.length % 2 === 0
                ? (sortedAreas[mid - 1] + sortedAreas[mid]) / 2
                : sortedAreas[mid];
            
            // Calculate standard deviation (using median for robustness)
            const squaredDiffs = areas.map(a => (a - median) ** 2);
            const variance = squaredDiffs.reduce((sum, d) => sum + d, 0) / areas.length;
            const stdDev = Math.sqrt(variance);
            
            // Min and max
            const min = Math.min(...areas);
            const max = Math.max(...areas);
            
            return { median, stdDev, min, max, areas, diagnostics };
        }
        
        /**
         * Calculate centroid statistics for a set of shapes
         * Returns median, stdDev for both X and Y coordinates
         */
        function calculateCentroidStatistics(shapes) {
            if (!shapes || shapes.length === 0) {
                return {
                    medianX: 0, medianY: 0,
                    stdDevX: 0, stdDevY: 0,
                    minX: 0, maxX: 0,
                    minY: 0, maxY: 0,
                    count: 0
                };
            }
            
            // Extract centroid coordinates (all shapes now have valid centroids from Sheets)
            const xCoords = [];
            const yCoords = [];
            
            for (const shape of shapes) {
                if (shape.centroid && 
                    !isNaN(shape.centroid.x) && !isNaN(shape.centroid.y)) {
                    xCoords.push(shape.centroid.x);
                    yCoords.push(shape.centroid.y);
                }
            }
            
            if (xCoords.length === 0) {
                return {
                    medianX: 0, medianY: 0,
                    stdDevX: 0, stdDevY: 0,
                    minX: 0, maxX: 0,
                    minY: 0, maxY: 0,
                    count: 0
                };
            }
            
            // Calculate medians
            const sortedX = [...xCoords].sort((a, b) => a - b);
            const sortedY = [...yCoords].sort((a, b) => a - b);
            const mid = Math.floor(sortedX.length / 2);
            
            const medianX = sortedX.length % 2 === 0 
                ? (sortedX[mid - 1] + sortedX[mid]) / 2 
                : sortedX[mid];
            const medianY = sortedY.length % 2 === 0 
                ? (sortedY[mid - 1] + sortedY[mid]) / 2 
                : sortedY[mid];
            
            // Calculate standard deviations (using median for robustness)
            const squaredDiffsX = xCoords.map(x => (x - medianX) ** 2);
            const squaredDiffsY = yCoords.map(y => (y - medianY) ** 2);
            const stdDevX = Math.sqrt(squaredDiffsX.reduce((sum, d) => sum + d, 0) / xCoords.length);
            const stdDevY = Math.sqrt(squaredDiffsY.reduce((sum, d) => sum + d, 0) / yCoords.length);
            
            // Min and max
            const minX = Math.min(...xCoords);
            const maxX = Math.max(...xCoords);
            const minY = Math.min(...yCoords);
            const maxY = Math.max(...yCoords);
            
            return {
                medianX, medianY,
                stdDevX, stdDevY,
                minX, maxX,
                minY, maxY,
                count: xCoords.length
            };
        }
        
        // ============================================
        // DRAWING FUNCTIONS
        // ============================================
        
        function drawGrid(ctx) {
            const gridColor = '#d1d5db';  // Slightly darker grid lines
            const axisColor = '#6b7280';  // Darker axes
            const labelColor = '#4b5563';  // Darker labels
            
            ctx.save();
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1;
            
            // Draw grid lines - MUST match drawing tool exactly for 1:1 alignment
            for (let i = -UNIT_RANGE + 1; i < UNIT_RANGE; i++) {
                if (i !== 0) {
                    // Get position for this grid line
                    const coord = unitToCanvas(i, i);
                    
                    // Horizontal line at y = coord.y
                    ctx.beginPath();
                    ctx.moveTo(0, coord.y);
                    ctx.lineTo(CANVAS_SIZE, coord.y);
                    ctx.stroke();
                    
                    // Vertical line at x = coord.x
                    ctx.beginPath();
                    ctx.moveTo(coord.x, 0);
                    ctx.lineTo(coord.x, CANVAS_SIZE);
                    ctx.stroke();
                }
            }
            
            // Draw axes
            ctx.strokeStyle = axisColor;
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(0, CENTER);
            ctx.lineTo(CANVAS_SIZE, CENTER);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(CENTER, 0);
            ctx.lineTo(CENTER, CANVAS_SIZE);
            ctx.stroke();
            
            // Draw labels
            ctx.fillStyle = labelColor;
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // X-axis labels
            for (let i = -UNIT_RANGE; i <= UNIT_RANGE; i += 2) {
                if (i === 0) continue;
                const coord = unitToCanvas(i, 0);
                const labelY = i === UNIT_RANGE || i === -UNIT_RANGE ? CENTER + 25 : CENTER + 20;
                ctx.fillText(i.toString(), coord.x, labelY);
            }
            
            // Y-axis labels
            ctx.textAlign = 'left';
            for (let j = -UNIT_RANGE; j <= UNIT_RANGE; j += 2) {
                if (j === 0) continue;
                const coord = unitToCanvas(0, j);
                ctx.fillText(j.toString(), CENTER + 10, coord.y);
            }
            
            ctx.textAlign = 'right';
            ctx.fillText('0', CENTER - 8, CENTER + 20);
            
            ctx.restore();
        }
        
        function drawReferenceCircle(ctx) {
            ctx.save();
            ctx.beginPath();
            ctx.arc(CENTER, CENTER, REFERENCE_CIRCLE_RADIUS_PX, 0, 2 * Math.PI);
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
        }
        
        function drawContour(ctx, contour, color, lineWidth = 3, alpha = 1.0, dashed = false) {
            if (!contour || contour.length < 2) return;
            
            // Validate and filter contour points - remove NaN/Infinity
            const validContour = contour.filter(p => 
                p && typeof p.x === 'number' && typeof p.y === 'number' &&
                isFinite(p.x) && isFinite(p.y)
            );
            
            if (validContour.length < 2) return;
            
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            
            if (dashed) {
                ctx.setLineDash([8, 6]);
            }
            
            ctx.beginPath();
            const start = unitToCanvas(validContour[0].x, validContour[0].y);
            ctx.moveTo(start.x, start.y);
            
            for (let i = 1; i < validContour.length; i++) {
                const p = unitToCanvas(validContour[i].x, validContour[i].y);
                // Skip if there's a huge jump (more than 5 units = 250 pixels)
                const prev = unitToCanvas(validContour[i-1].x, validContour[i-1].y);
                const dist = Math.sqrt((p.x - prev.x) ** 2 + (p.y - prev.y) ** 2);
                if (dist > 250) {
                    // Large jump - close current path and start new one
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                } else {
                    ctx.lineTo(p.x, p.y);
                }
            }
            
            // Close the path
            ctx.closePath();
            ctx.stroke();
            
            ctx.restore();
        }
        
        function drawRawPixels(ctx, rawPixels, color, alpha = 0.4) {
            // Draw raw pixels directly at their exact positions for 1:1 accuracy
            if (!rawPixels || rawPixels.length === 0) return;
            
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = color;
            
            // Draw each pixel at its exact position
            for (const pixel of rawPixels) {
                ctx.fillRect(pixel.x, pixel.y, 1, 1);
            }
            
            ctx.restore();
        }
        
        function drawCompositeVisualization(canvas, frequency, redShapes, blueShapes, redAvg, blueAvg) {
            const ctx = canvas.getContext('2d');
            
            // White background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            
            // Draw grid
            drawGrid(ctx);
            
            // Draw reference circle
            drawReferenceCircle(ctx);
            
            // Draw individual shapes using RAW PIXELS for exact 1:1 translation
            // Red shapes - very light and transparent for background
            for (const shape of redShapes) {
                // Skip Sheets-created shapes - they're synthetic and would show as circles
                if (shape.createdFromSheetsData) {
                    continue;
                }
                
                if (shape.rawPixels && shape.rawPixels.length > 0) {
                    // Use raw pixels for 1:1 accuracy - light but visible
                    drawRawPixels(ctx, shape.rawPixels, '#ffcccc', 0.3);
                } else if (shape.contour && shape.contour.length > 0) {
                    // Fallback to contour - light but visible
                    drawContour(ctx, shape.contour, 'rgba(255, 180, 180, 0.25)', 1, 1.0);
                }
            }
            
            // Blue shapes - very light and transparent for background
            for (const shape of blueShapes) {
                // Skip Sheets-created shapes - they're synthetic and would show as circles
                if (shape.createdFromSheetsData) {
                    continue;
                }
                
                if (shape.rawPixels && shape.rawPixels.length > 0) {
                    // Use raw pixels for 1:1 accuracy - light but visible
                    drawRawPixels(ctx, shape.rawPixels, '#ccccff', 0.3);
                } else if (shape.contour && shape.contour.length > 0) {
                    // Fallback to contour - light but visible
                    drawContour(ctx, shape.contour, 'rgba(180, 180, 255, 0.25)', 1, 1.0);
                }
            }
            
            // Draw average shapes (solid colors, thicker lines for visibility)
            // Red average - solid line, thicker
            if (redAvg && redAvg.length > 0) {
                drawContour(ctx, redAvg, '#cc0000', 5, 1.0, false);
            }
            
            // Blue average - solid line (not dashed), thicker
            if (blueAvg && blueAvg.length > 0) {
                drawContour(ctx, blueAvg, '#0000cc', 5, 1.0, false);
            }
            
            // Calculate statistics (using median for robustness)
            const redMedianR = redAvg ? calculateContourMedianRadius(redAvg) : calculateMedianRadius(redShapes);
            const blueMedianR = blueAvg ? calculateContourMedianRadius(blueAvg) : calculateMedianRadius(blueShapes);
            
            // Draw frequency label at top
            ctx.save();
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 28px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(`${frequency} Hz`, CENTER, 15);
            
            // Draw statistics labels
            ctx.font = '18px sans-serif';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            
            // Red stats (in-phase)
            ctx.fillStyle = '#cc0000';
            ctx.fillText(`N=${redShapes.length}, median r=${redMedianR.toFixed(2)} (in-phase)`, 20, 55);
            
            // Blue stats (out-of-phase)  
            ctx.fillStyle = '#0000cc';
            ctx.fillText(`N=${blueShapes.length}, median r=${blueMedianR.toFixed(2)} (out-of-phase)`, 20, 80);
            
            ctx.restore();
        }
        
        // ============================================
        // FILE HANDLING
        // ============================================
        
        async function loadImageFromFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // Create canvas to get image data
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        
                        // Scale to standard size if needed
                        let imageData;
                        if (img.width !== CANVAS_SIZE || img.height !== CANVAS_SIZE) {
                            // Scale image
                            const scaledCanvas = document.createElement('canvas');
                            scaledCanvas.width = CANVAS_SIZE;
                            scaledCanvas.height = CANVAS_SIZE;
                            const scaledCtx = scaledCanvas.getContext('2d');
                            scaledCtx.drawImage(img, 0, 0, CANVAS_SIZE, CANVAS_SIZE);
                            imageData = scaledCtx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                        } else {
                            imageData = ctx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                        }
                        
                        resolve({
                            filename: file.name,
                            imageData: imageData,
                            width: CANVAS_SIZE,
                            height: CANVAS_SIZE
                        });
                    };
                    img.onerror = () => reject(new Error(`Failed to load image: ${file.name}`));
                    img.src = e.target.result;
                };
                reader.onerror = () => reject(new Error(`Failed to read file: ${file.name}`));
                reader.readAsDataURL(file);
            });
        }
        
        async function processZipFile(zipFile) {
            const zip = new JSZip();
            const contents = await zip.loadAsync(zipFile);
            const imageFiles = [];
            const nestedZipNames = []; // Track nested ZIP names for trial mapping
            
            // Process all files including those in nested folders
            const processEntries = async (entries) => {
                for (const [path, file] of Object.entries(entries)) {
                    // Skip directories
                    if (file.dir) continue;
                    
                    // Check if it's a PNG file (case insensitive)
                    if (path.toLowerCase().endsWith('.png')) {
                        try {
                            const blob = await file.async('blob');
                            // Extract just the filename from the full path
                            const name = path.split('/').pop();
                            imageFiles.push(new File([blob], name, { type: 'image/png' }));
                        } catch (err) {
                            console.warn(`Failed to extract: ${path}`, err);
                        }
                    }
                    
                    // Check if it's a nested ZIP file
                    if (path.toLowerCase().endsWith('.zip')) {
                        const nestedZipName = path.split('/').pop();
                        nestedZipNames.push(nestedZipName);
                        
                        try {
                            const nestedZipBlob = await file.async('blob');
                            const nestedZip = new JSZip();
                            const nestedContents = await nestedZip.loadAsync(nestedZipBlob);
                            
                            // Parse the nested ZIP name for trial mapping
                            const parsed = parseZipName(nestedZipName);
                            
                            // Recursively process nested ZIP
                            for (const [nestedPath, nestedFile] of Object.entries(nestedContents.files)) {
                                if (nestedFile.dir) continue;
                                
                                if (nestedPath.toLowerCase().endsWith('.png')) {
                                    try {
                                        const nestedBlob = await nestedFile.async('blob');
                                        const nestedName = nestedPath.split('/').pop();
                                        
                                        // Create unique filename that includes ZIP folder info
                                        // This prevents overwriting when same PNG exists in multiple trials
                                        const uniqueName = `${parsed.participant}_T${parsed.orderNumber}_${nestedName}`;
                                        const pngFile = new File([nestedBlob], uniqueName, { type: 'image/png' });
                                        
                                        // Store original filename for display/parsing
                                        pngFile.originalName = nestedName;
                                        pngFile.zipFolder = nestedZipName;
                                        pngFile.participantFromZip = parsed.participant;
                                        pngFile.orderNumberFromZip = parsed.orderNumber;
                                        
                                        imageFiles.push(pngFile);
                                        
                                        // Store trial info for this file using unique name
                                        fileTrialInfo[uniqueName] = {
                                            participant: parsed.participant,
                                            orderNumber: parsed.orderNumber,
                                            zipName: nestedZipName,
                                            originalName: nestedName
                                        };
                                    } catch (err) {
                                        console.warn(`Failed to extract nested: ${nestedPath}`, err);
                                    }
                                }
                            }
                        } catch (err) {
                            console.warn(`Failed to process nested ZIP: ${path}`, err);
                        }
                    }
                }
            };
            
            await processEntries(contents.files);
            
            // Build trial mapping from nested ZIP names
            if (nestedZipNames.length > 0) {
                trialMapping = buildTrialMapping(nestedZipNames);
                
                // Update fileTrialInfo with actual trial numbers
                for (const [filename, info] of Object.entries(fileTrialInfo)) {
                    if (trialMapping[info.participant] && trialMapping[info.participant][info.orderNumber]) {
                        info.trial = trialMapping[info.participant][info.orderNumber].toString();
                    } else {
                        info.trial = '1'; // Default
                    }
                }
                
                console.log('[Trial Mapping] Built mapping:', trialMapping);
                console.log('[Trial Mapping] File info sample:', Object.entries(fileTrialInfo).slice(0, 3));
            }
            
            return imageFiles;
        }
        
        async function handleFiles(files) {
            uploadedFiles = [];
            trialMapping = {};     // Reset trial mapping
            fileTrialInfo = {};    // Reset file trial info
            const fileList = document.getElementById('file-list');
            fileList.innerHTML = '<div class="text-blue-600">Processing files...</div>';
            
            for (const file of files) {
                if (file.name.toLowerCase().endsWith('.zip')) {
                    addLogEntry(`Extracting ZIP: ${file.name} (including nested folders)`);
                    try {
                        const extractedFiles = await processZipFile(file);
                        uploadedFiles.push(...extractedFiles);
                        addLogEntry(`Extracted ${extractedFiles.length} PNG files from ${file.name}`);
                    } catch (err) {
                        addLogEntry(`ERROR extracting ${file.name}: ${err.message}`);
                    }
                } else if (file.name.toLowerCase().endsWith('.png')) {
                    uploadedFiles.push(file);
                }
            }
            
            fileList.innerHTML = `<strong>${uploadedFiles.length} PNG files ready for analysis:</strong><br>`;
            
            // Group by frequency
            const byFreq = {};
            for (const file of uploadedFiles) {
                const freq = parseFrequencyFromFilename(file.name);
                if (freq) {
                    if (!byFreq[freq]) byFreq[freq] = 0;
                    byFreq[freq]++;
                }
            }
            
            // Sort frequencies numerically
            const sortedFreqs = Object.keys(byFreq).map(Number).sort((a, b) => a - b);
            for (const freq of sortedFreqs) {
                fileList.innerHTML += `‚Ä¢ ${freq} Hz: ${byFreq[freq]} files<br>`;
            }
            
            // Show trial mapping info if available
            const mappedParticipants = Object.keys(trialMapping);
            if (mappedParticipants.length > 0) {
                fileList.innerHTML += `<br><strong>üìã Trial Mapping:</strong><br>`;
                for (const participant of mappedParticipants) {
                    const trials = trialMapping[participant];
                    const trialStr = Object.entries(trials)
                        .map(([order, trial]) => `#${order}‚ÜíT${trial}`)
                        .join(', ');
                    fileList.innerHTML += `‚Ä¢ ${participant}: ${trialStr}<br>`;
                }
            }
            
            document.getElementById('analyze-btn').disabled = uploadedFiles.length === 0;
            
            if (uploadedFiles.length > 0) {
                addLogEntry(`Total: ${uploadedFiles.length} PNG files ready across ${sortedFreqs.length} frequencies`);
                
                if (mappedParticipants.length > 0) {
                    addLogEntry(`‚úÖ Trial mapping built for ${mappedParticipants.length} participants`);
                    console.log('[Files] Participants from ZIPs:', mappedParticipants);
                }
                
                // Suggest connecting to Sheets if not connected
                if (!sheetsConnected) {
                    addLogEntry('üí° Tip: Connect Google Sheets (Step 1.5) for exact centroid positions');
                } else {
                    // Check for participant name mismatches
                    const sheetsParticipants = new Set(sheetsData.map(d => d.participant.toLowerCase()));
                    const fileParticipants = new Set(mappedParticipants.map(p => p.toLowerCase()));
                    
                    const unmatchedFiles = mappedParticipants.filter(p => !sheetsParticipants.has(p.toLowerCase()));
                    const unmatchedSheets = Array.from(new Set(sheetsData.map(d => d.participant)))
                        .filter(p => !fileParticipants.has(p.toLowerCase()));
                    
                    if (unmatchedFiles.length > 0) {
                        console.warn('[Match] File participants NOT in Sheets:', unmatchedFiles);
                        addLogEntry(`‚ö†Ô∏è Warning: ${unmatchedFiles.length} file participants not found in Sheets: ${unmatchedFiles.join(', ')}`);
                    }
                    if (unmatchedSheets.length > 0) {
                        console.warn('[Match] Sheets participants NOT in files:', unmatchedSheets);
                    }
                }
            }
        }
        
        // ============================================
        // MAIN ANALYSIS
        // ============================================
        
        async function runAnalysis() {
            if (uploadedFiles.length === 0) {
                alert('Please upload PNG files first.');
                return;
            }
            
            // Open progress dropdown
            document.getElementById('progress-dropdown').open = true;
            document.getElementById('status-log').innerHTML = '';
            
            addLogEntry('Starting Cartesian pipeline analysis...');
            updateProgress(0, 'Initializing...');
            
            // Log Sheets connection status
            if (sheetsConnected) {
                addLogEntry(`‚úÖ Using Google Sheets data for exact centroid positions (${sheetsData.length} records)`);
            } else {
                addLogEntry('‚ö†Ô∏è No Sheets connection - using pattern-based marker detection');
            }
            
            try {
                // Group files by frequency and track trial info
                const filesByFrequency = {};
                let sheetsMatchCount = 0;
                let sheetsMissCount = 0;
                
                for (const file of uploadedFiles) {
                    // Use originalName if available (from ZIP extraction), else use file.name
                    const filenameForParsing = file.originalName || file.name;
                    const freq = parseFrequencyFromFilename(filenameForParsing);
                    if (freq && FREQUENCIES.includes(freq)) {
                        if (!filesByFrequency[freq]) {
                            filesByFrequency[freq] = [];
                        }
                        filesByFrequency[freq].push(file);
                    }
                }
                
                const totalFreqs = Object.keys(filesByFrequency).length;
                let processedFreqs = 0;
                
                const results = {};
                
                for (const [freq, files] of Object.entries(filesByFrequency)) {
                    addLogEntry(`Processing ${freq} Hz (${files.length} images)...`);
                    
                    const allRedShapes = [];
                    const allBlueShapes = [];
                    
                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        
                        // Get participant from PNG filename (more reliable)
                        // Get trial from ZIP folder order number
                        let participant, trial;
                        
                        // Always parse participant from the PNG filename
                        const pngFilename = file.originalName || file.name;
                        participant = parseParticipantFromFilename(pngFilename);
                        
                        if (file.orderNumberFromZip !== undefined) {
                            // File came from a nested ZIP - use ZIP order for trial mapping
                            const orderNum = file.orderNumberFromZip;
                            const zipParticipant = file.participantFromZip;
                            
                            // Look up trial number from mapping using ZIP participant
                            if (trialMapping[zipParticipant] && trialMapping[zipParticipant][orderNum]) {
                                trial = trialMapping[zipParticipant][orderNum].toString();
                                console.log(`  üìÇ ZIP: ${file.zipFolder} ‚Üí Order ${orderNum} ‚Üí Trial ${trial}`);
                                console.log(`  üìÑ PNG: ${pngFilename} ‚Üí Participant: "${participant}", Freq: ${freq} Hz`);
                            } else {
                                trial = '1';
                                console.log(`  ‚ö†Ô∏è No trial mapping for ${zipParticipant} order ${orderNum}, defaulting to Trial 1`);
                            }
                            
                            // Warn if ZIP participant doesn't match PNG participant
                            if (zipParticipant.toLowerCase() !== participant.toLowerCase()) {
                                console.warn(`  ‚ö†Ô∏è Participant mismatch: ZIP says "${zipParticipant}", PNG says "${participant}"`);
                            }
                        } else {
                            // Fallback to fileTrialInfo lookup
                            const trialInfo = fileTrialInfo[file.name] || {};
                            trial = trialInfo.trial || '1';
                            console.log(`  üìÑ PNG: ${pngFilename} ‚Üí Participant: "${participant}", Trial: ${trial} (from fileTrialInfo)`);
                        }
                        
                        // Use original filename for display
                        const displayName = file.originalName || file.name;
                        
                        updateProgress(
                            (processedFreqs / totalFreqs + (i / files.length) / totalFreqs) * 90,
                            `${freq} Hz: Processing ${displayName} (Trial ${trial})`
                        );
                        
                        try {
                            // Look up centroid data from Google Sheets
                            let knownRedCentroid = null;
                            let knownBlueCentroid = null;
                            let redData = null;
                            let blueData = null;
                            
                            if (sheetsConnected) {
                                // Log lookup attempt for debugging
                                console.log(`  üîé Looking up: participant="${participant}", trial="${trial}", freq=${freq}`);
                                
                                // Look up red shape centroid
                                redData = lookupSheetsData(participant, trial, freq, 'red');
                                if (redData && redData.centroid) {
                                    knownRedCentroid = redData.centroid;
                                    sheetsMatchCount++;
                                    console.log(`    ‚úÖ Red match: centroid (${redData.centroid.x.toFixed(2)}, ${redData.centroid.y.toFixed(2)}), area=${redData.area?.toFixed(2)}`);
                                } else {
                                    sheetsMissCount++;
                                    console.log(`    ‚ùå Red: no match found`);
                                }
                                
                                // Look up blue shape centroid
                                blueData = lookupSheetsData(participant, trial, freq, 'blue');
                                if (blueData && blueData.centroid) {
                                    knownBlueCentroid = blueData.centroid;
                                    sheetsMatchCount++;
                                    console.log(`    ‚úÖ Blue match: centroid (${blueData.centroid.x.toFixed(2)}, ${blueData.centroid.y.toFixed(2)}), area=${blueData.area?.toFixed(2)}`);
                                } else {
                                    sheetsMissCount++;
                                    console.log(`    ‚ùå Blue: no match found`);
                                }
                            }
                            
                            const imgData = await loadImageFromFile(file);
                            const shapes = extractShapesFromImage(imgData.imageData, knownRedCentroid, knownBlueCentroid);
                            
                            // ============================================
                            // SHEETS FALLBACK: Create shapes from Sheets data ONLY when:
                            // 1. Extraction completely failed (no shape at all)
                            // Keep extracted shapes even if small - they represent real drawings
                            // ============================================
                            
                            // Check red shape - only use Sheets if NO extraction
                            if (sheetsConnected && redData && redData.centroid) {
                                if (shapes.redShapes.length === 0) {
                                    const sheetsArea = redData.area || 0;
                                    const sheetsShape = createShapeFromSheetsData(redData);
                                    if (sheetsShape) {
                                        console.log(`    üîß Red: no extraction - using Sheets shape (area=${sheetsArea.toFixed(2)})`);
                                        shapes.redShapes.push(sheetsShape);
                                        shapes.redExtractionNote = `created from Sheets (no extraction, area=${sheetsArea.toFixed(2)})`;
                                    }
                                }
                            }
                            
                            // Check blue shape - only use Sheets if NO extraction
                            if (sheetsConnected && blueData && blueData.centroid) {
                                if (shapes.blueShapes.length === 0) {
                                    const sheetsArea = blueData.area || 0;
                                    const sheetsShape = createShapeFromSheetsData(blueData);
                                    if (sheetsShape) {
                                        console.log(`    üîß Blue: no extraction - using Sheets shape (area=${sheetsArea.toFixed(2)})`);
                                        shapes.blueShapes.push(sheetsShape);
                                        shapes.blueExtractionNote = `created from Sheets (no extraction, area=${sheetsArea.toFixed(2)})`;
                                    }
                                }
                            }
                            
                            // Add participant info to shapes
                            shapes.redShapes.forEach(s => {
                                s.participant = participant;
                                s.frequency = freq;
                                s.trial = trial;
                                s.filename = displayName;
                            });
                            shapes.blueShapes.forEach(s => {
                                s.participant = participant;
                                s.frequency = freq;
                                s.trial = trial;
                                s.filename = displayName;
                            });
                            
                            allRedShapes.push(...shapes.redShapes);
                            allBlueShapes.push(...shapes.blueShapes);
                            
                            // Create detailed log entry
                            let logMsg = `  ${participant}`;
                            if (trial !== '1') logMsg += ` (Trial ${trial})`;
                            logMsg += ': ';
                            
                            if (shapes.redShapes.length > 0 || shapes.blueShapes.length > 0) {
                                logMsg += `R:${shapes.redShapes.length}`;
                                if (shapes.redShapes[0]?.usedSheetsCentroid) logMsg += 'üìç';
                                if (shapes.redGapsFilled > 0) logMsg += `(${shapes.redGapsFilled} gaps)`;
                                logMsg += ` B:${shapes.blueShapes.length}`;
                                if (shapes.blueShapes[0]?.usedSheetsCentroid) logMsg += 'üìç';
                                if (shapes.blueGapsFilled > 0) logMsg += `(${shapes.blueGapsFilled} gaps)`;
                            } else {
                                logMsg += 'No shapes detected';
                            }
                            
                            // Log extraction failures
                            if (shapes.redExtractionNote) {
                                logMsg += ` ‚ö†Ô∏è Red: ${shapes.redExtractionNote}`;
                            }
                            if (shapes.blueExtractionNote) {
                                logMsg += ` ‚ö†Ô∏è Blue: ${shapes.blueExtractionNote}`;
                            }
                            
                            addLogEntry(logMsg);
                        } catch (err) {
                            addLogEntry(`  ERROR processing ${displayName}: ${err.message}`);
                        }
                    }
                    
                    // No balancing - preserve all shapes for accurate averaging
                    // Calculate average shapes using selected averaging mode
                    let redAvg, blueAvg;
                    
                    if (averagingMode === 'area') {
                        addLogEntry(`  üìê Using Area-Normalized Averaging`);
                        redAvg = calculateAverageShapeWithAreaNormalization(allRedShapes, 'Red');
                        blueAvg = calculateAverageShapeWithAreaNormalization(allBlueShapes, 'Blue');
                    } else {
                        addLogEntry(`  üìè Using Contour-Only Averaging`);
                        redAvg = calculateAverageShape(allRedShapes);
                        blueAvg = calculateAverageShape(allBlueShapes);
                    }
                    
                    results[freq] = {
                        redShapes: allRedShapes,
                        blueShapes: allBlueShapes,
                        redAvg,
                        blueAvg,
                        averagingMode: averagingMode
                    };
                    
                    processedFreqs++;
                    addLogEntry(`${freq} Hz: Completed (${allRedShapes.length} red, ${allBlueShapes.length} blue)`);
                }
                
                // Report Sheets matching summary
                if (sheetsConnected) {
                    const matchRate = sheetsMatchCount + sheetsMissCount > 0 
                        ? Math.round(100 * sheetsMatchCount / (sheetsMatchCount + sheetsMissCount)) 
                        : 0;
                    addLogEntry(`üìä Sheets Match Summary: ${sheetsMatchCount} matched, ${sheetsMissCount} not found (${matchRate}% match rate)`);
                    if (sheetsMissCount > 0) {
                        addLogEntry('   üìç = Used Sheets centroid, no icon = Pattern detection fallback');
                    }
                }
                
                // Generate composite visualizations
                updateProgress(90, 'Generating composite visualizations...');
                addLogEntry('Creating composite images...');
                
                const resultsGrid = document.getElementById('results-grid');
                resultsGrid.innerHTML = '';
                compositeCanvases = {};
                
                const sortedFreqs = Object.keys(results).map(Number).sort((a, b) => a - b);
                
                for (const freq of sortedFreqs) {
                    const data = results[freq];
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = CANVAS_SIZE;
                    canvas.height = CANVAS_SIZE;
                    
                    drawCompositeVisualization(canvas, freq, data.redShapes, data.blueShapes, data.redAvg, data.blueAvg);
                    
                    compositeCanvases[freq] = canvas;
                    
                    // Create container
                    const container = document.createElement('div');
                    container.className = 'canvas-container p-4';
                    container.title = 'Click to download';
                    
                    const displayCanvas = document.createElement('canvas');
                    displayCanvas.width = 400;
                    displayCanvas.height = 400;
                    displayCanvas.style.width = '100%';
                    displayCanvas.style.height = 'auto';
                    
                    const displayCtx = displayCanvas.getContext('2d');
                    displayCtx.drawImage(canvas, 0, 0, 400, 400);
                    
                    container.appendChild(displayCanvas);
                    
                    // Click to download
                    container.addEventListener('click', () => {
                        const link = document.createElement('a');
                        link.download = `composite_${freq}Hz.png`;
                        link.href = canvas.toDataURL('image/png');
                        link.click();
                    });
                    
                    resultsGrid.appendChild(container);
                }
                
                // Calculate and display area statistics
                updateProgress(95, 'Calculating area statistics...');
                displayAreaStatistics(results, sortedFreqs);
                
                // Final validation pass: cross-check centroids with Google Sheets data
                if (sheetsConnected) {
                    updateProgress(98, 'Validating centroids against Google Sheets...');
                    validateCentroidsAgainstSheets(results, sortedFreqs);
                }
                
                updateProgress(100, 'Analysis complete!');
                addLogEntry('All composites generated successfully!');
                
                // Open results dropdown
                document.getElementById('results-dropdown').open = true;
                document.getElementById('download-all-btn').disabled = false;
                
                // Also open area stats dropdown
                document.getElementById('area-stats-dropdown').open = true;
                
            } catch (error) {
                console.error('Analysis error:', error);
                addLogEntry(`ERROR: ${error.message}`);
                alert(`Analysis failed: ${error.message}`);
            }
        }
        
        /**
         * Display area statistics in a table format
         * @param {Object} results - Results object with frequency keys
         * @param {Array} sortedFreqs - Sorted array of frequencies
         */
        function displayAreaStatistics(results, sortedFreqs) {
            const container = document.getElementById('area-stats-container');
            
            // Build table HTML
            let html = `
                <div class="overflow-x-auto">
                    <table class="w-full text-sm border-collapse">
                        <thead>
                            <tr class="bg-gray-100">
                                <th class="border border-gray-300 px-4 py-2 text-left font-bold">Frequency</th>
                                <th class="border border-gray-300 px-4 py-2 text-center font-bold text-red-600" colspan="4">In-Phase (Red) Area (units¬≤)</th>
                                <th class="border border-gray-300 px-4 py-2 text-center font-bold text-blue-600" colspan="4">Out-of-Phase (Blue) Area (units¬≤)</th>
                            </tr>
                            <tr class="bg-gray-50">
                                <th class="border border-gray-300 px-4 py-2"></th>
                                <th class="border border-gray-300 px-3 py-1 text-center text-red-500 text-xs">N</th>
                                <th class="border border-gray-300 px-3 py-1 text-center text-red-500 text-xs">Median ¬± SD</th>
                                <th class="border border-gray-300 px-3 py-1 text-center text-red-500 text-xs">Min</th>
                                <th class="border border-gray-300 px-3 py-1 text-center text-red-500 text-xs">Max</th>
                                <th class="border border-gray-300 px-3 py-1 text-center text-blue-500 text-xs">N</th>
                                <th class="border border-gray-300 px-3 py-1 text-center text-blue-500 text-xs">Median ¬± SD</th>
                                <th class="border border-gray-300 px-3 py-1 text-center text-blue-500 text-xs">Min</th>
                                <th class="border border-gray-300 px-3 py-1 text-center text-blue-500 text-xs">Max</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            // Store all area data for summary
            const allRedAreas = [];
            const allBlueAreas = [];
            
            for (const freq of sortedFreqs) {
                const data = results[freq];
                
                const redStats = calculateAreaStatistics(data.redShapes);
                const blueStats = calculateAreaStatistics(data.blueShapes);
                
                allRedAreas.push(...redStats.areas);
                allBlueAreas.push(...blueStats.areas);
                
                const freqLabel = freq === 62.5 ? '62.5 Hz' : `${freq} Hz`;
                
                html += `
                    <tr class="hover:bg-gray-50">
                        <td class="border border-gray-300 px-4 py-2 font-medium">${freqLabel}</td>
                        <td class="border border-gray-300 px-3 py-2 text-center text-red-600">${redStats.areas.length}</td>
                        <td class="border border-gray-300 px-3 py-2 text-center text-red-600">${redStats.median.toFixed(2)} ¬± ${redStats.stdDev.toFixed(2)}</td>
                        <td class="border border-gray-300 px-3 py-2 text-center text-red-600">${redStats.min.toFixed(2)}</td>
                        <td class="border border-gray-300 px-3 py-2 text-center text-red-600">${redStats.max.toFixed(2)}</td>
                        <td class="border border-gray-300 px-3 py-2 text-center text-blue-600">${blueStats.areas.length}</td>
                        <td class="border border-gray-300 px-3 py-2 text-center text-blue-600">${blueStats.median.toFixed(2)} ¬± ${blueStats.stdDev.toFixed(2)}</td>
                        <td class="border border-gray-300 px-3 py-2 text-center text-blue-600">${blueStats.min.toFixed(2)}</td>
                        <td class="border border-gray-300 px-3 py-2 text-center text-blue-600">${blueStats.max.toFixed(2)}</td>
                    </tr>
                `;
            }
            
            html += `
                        </tbody>
                    </table>
                </div>
                <div class="mt-4 text-xs text-gray-500">
                    <p><strong>Note:</strong> Area is calculated using the Shoelace formula on the contour coordinates in unit space (where the reference circle has radius 3).</p>
                    <p class="mt-1">Units¬≤ = square units where 1 unit = 50 pixels on the 1000√ó1000 canvas.</p>
                </div>
            `;
            
            // Add diagnostic section - show point responses and any exclusions
            let diagnosticHtml = `
                <div class="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                    <h4 class="font-bold text-blue-800 mb-3">üìä Data Quality Report</h4>
                    <div class="text-xs space-y-2">
            `;
            
            let totalExcluded = 0;
            let totalZeroArea = 0;
            let totalSheetsCreated = 0;
            
            for (const freq of sortedFreqs) {
                const data = results[freq];
                const redStats = calculateAreaStatistics(data.redShapes);
                const blueStats = calculateAreaStatistics(data.blueShapes);
                
                const freqLabel = freq === 62.5 ? '62.5 Hz' : `${freq} Hz`;
                
                const redExcluded = redStats.diagnostics.total - redStats.diagnostics.valid;
                const blueExcluded = blueStats.diagnostics.total - blueStats.diagnostics.valid;
                const redZeroArea = redStats.diagnostics.zeroArea || 0;
                const blueZeroArea = blueStats.diagnostics.zeroArea || 0;
                const redSheetsCreated = redStats.diagnostics.sheetsCreated || 0;
                const blueSheetsCreated = blueStats.diagnostics.sheetsCreated || 0;
                
                totalExcluded += redExcluded + blueExcluded;
                totalZeroArea += redZeroArea + blueZeroArea;
                totalSheetsCreated += redSheetsCreated + blueSheetsCreated;
                
                // Show info if there are issues or Sheets-created shapes
                if (redExcluded > 0 || blueExcluded > 0 || redZeroArea > 0 || blueZeroArea > 0 || redSheetsCreated > 0 || blueSheetsCreated > 0) {
                    diagnosticHtml += `<div class="mb-2 p-2 bg-white rounded border">`;
                    diagnosticHtml += `<strong>${freqLabel}</strong>: `;
                    
                    // Red info
                    let redInfo = [];
                    if (redSheetsCreated > 0) redInfo.push(`${redSheetsCreated} from Sheets`);
                    if (redZeroArea > 0) redInfo.push(`${redZeroArea} minimal area`);
                    if (redStats.diagnostics.noContour > 0) redInfo.push(`${redStats.diagnostics.noContour} no contour`);
                    if (redInfo.length > 0) {
                        diagnosticHtml += `<span class="text-red-600">Red: ${redInfo.join(', ')}</span> `;
                    }
                    
                    // Blue info
                    let blueInfo = [];
                    if (blueSheetsCreated > 0) blueInfo.push(`${blueSheetsCreated} from Sheets`);
                    if (blueZeroArea > 0) blueInfo.push(`${blueZeroArea} minimal area`);
                    if (blueStats.diagnostics.noContour > 0) blueInfo.push(`${blueStats.diagnostics.noContour} no contour`);
                    if (blueInfo.length > 0) {
                        diagnosticHtml += `<span class="text-blue-600">Blue: ${blueInfo.join(', ')}</span>`;
                    }
                    
                    // List excluded shapes
                    if (redStats.diagnostics.excluded && redStats.diagnostics.excluded.length > 0) {
                        diagnosticHtml += `<br><span class="text-red-500 ml-4">‚ö†Ô∏è Excluded: ${redStats.diagnostics.excluded.map(e => e.participant + (e.trial !== '1' ? ' T' + e.trial : '')).join(', ')}</span>`;
                    }
                    if (blueStats.diagnostics.excluded && blueStats.diagnostics.excluded.length > 0) {
                        diagnosticHtml += `<br><span class="text-blue-500 ml-4">‚ö†Ô∏è Excluded: ${blueStats.diagnostics.excluded.map(e => e.participant + (e.trial !== '1' ? ' T' + e.trial : '')).join(', ')}</span>`;
                    }
                    
                    diagnosticHtml += `</div>`;
                }
            }
            
            // Summary
            if (totalExcluded === 0 && totalZeroArea === 0 && totalSheetsCreated === 0) {
                diagnosticHtml += `<p class="text-green-600">‚úì All shapes extracted from PNGs successfully.</p>`;
            } else {
                if (totalSheetsCreated > 0) {
                    diagnosticHtml += `<p class="mt-2 text-purple-700">üìã <strong>${totalSheetsCreated}</strong> shapes created from Google Sheets data (small or missing extraction)</p>`;
                }
                if (totalZeroArea > 0) {
                    diagnosticHtml += `<p class="mt-1 text-blue-700">üìç <strong>${totalZeroArea}</strong> shapes with minimal/zero area</p>`;
                }
                if (totalExcluded > 0) {
                    diagnosticHtml += `<p class="mt-1 text-yellow-700">‚ö†Ô∏è <strong>${totalExcluded}</strong> shapes excluded (no contour detected)</p>`;
                }
            }
            
            diagnosticHtml += `</div></div>`;
            
            html += diagnosticHtml;
            
            container.innerHTML = html;
            
            addLogEntry(`üìê Area statistics calculated for ${sortedFreqs.length} frequencies`);
            if (totalSheetsCreated > 0) {
                addLogEntry(`üìã ${totalSheetsCreated} shapes created from Google Sheets data`);
            }
            if (totalZeroArea > 0) {
                addLogEntry(`üìç ${totalZeroArea} shapes with minimal/zero area`);
            }
            if (totalExcluded > 0) {
                addLogEntry(`‚ö†Ô∏è ${totalExcluded} shapes excluded (no contour detected)`);
            }
            
            // ============================================
            // CENTROID STATISTICS TABLE
            // ============================================
            let centroidHtml = `
                <div class="mt-8">
                    <h4 class="font-bold text-gray-800 mb-3">üìç Centroid Statistics by Frequency</h4>
                    <div class="overflow-x-auto">
                        <table class="w-full text-sm border-collapse">
                            <thead>
                                <tr class="bg-gray-100">
                                    <th class="border border-gray-300 px-4 py-2 text-left font-bold">Frequency</th>
                                    <th class="border border-gray-300 px-4 py-2 text-center font-bold text-red-600" colspan="3">In-Phase (Red) Centroid</th>
                                    <th class="border border-gray-300 px-4 py-2 text-center font-bold text-blue-600" colspan="3">Out-of-Phase (Blue) Centroid</th>
                                </tr>
                                <tr class="bg-gray-50">
                                    <th class="border border-gray-300 px-4 py-2"></th>
                                    <th class="border border-gray-300 px-3 py-1 text-center text-red-500 text-xs">N</th>
                                    <th class="border border-gray-300 px-3 py-1 text-center text-red-500 text-xs">Median (x, y)</th>
                                    <th class="border border-gray-300 px-3 py-1 text-center text-red-500 text-xs">SD (x, y)</th>
                                    <th class="border border-gray-300 px-3 py-1 text-center text-blue-500 text-xs">N</th>
                                    <th class="border border-gray-300 px-3 py-1 text-center text-blue-500 text-xs">Median (x, y)</th>
                                    <th class="border border-gray-300 px-3 py-1 text-center text-blue-500 text-xs">SD (x, y)</th>
                                </tr>
                            </thead>
                            <tbody>
            `;
            
            for (const freq of sortedFreqs) {
                const data = results[freq];
                
                const redCentroidStats = calculateCentroidStatistics(data.redShapes);
                const blueCentroidStats = calculateCentroidStatistics(data.blueShapes);
                
                const freqLabel = freq === 62.5 ? '62.5 Hz' : `${freq} Hz`;
                
                centroidHtml += `
                    <tr class="hover:bg-gray-50">
                        <td class="border border-gray-300 px-4 py-2 font-medium">${freqLabel}</td>
                        <td class="border border-gray-300 px-3 py-2 text-center text-red-600">${redCentroidStats.count}</td>
                        <td class="border border-gray-300 px-3 py-2 text-center text-red-600 font-medium">(${redCentroidStats.medianX.toFixed(2)}, ${redCentroidStats.medianY.toFixed(2)})</td>
                        <td class="border border-gray-300 px-3 py-2 text-center text-red-600">(${redCentroidStats.stdDevX.toFixed(2)}, ${redCentroidStats.stdDevY.toFixed(2)})</td>
                        <td class="border border-gray-300 px-3 py-2 text-center text-blue-600">${blueCentroidStats.count}</td>
                        <td class="border border-gray-300 px-3 py-2 text-center text-blue-600 font-medium">(${blueCentroidStats.medianX.toFixed(2)}, ${blueCentroidStats.medianY.toFixed(2)})</td>
                        <td class="border border-gray-300 px-3 py-2 text-center text-blue-600">(${blueCentroidStats.stdDevX.toFixed(2)}, ${blueCentroidStats.stdDevY.toFixed(2)})</td>
                    </tr>
                `;
            }
            
            centroidHtml += `
                            </tbody>
                        </table>
                    </div>
                    <div class="mt-2 text-xs text-gray-500">
                        <p><strong>Note:</strong> Centroid coordinates are in unit space (range: -10 to +10).</p>
                        <p class="mt-1">Median values are more robust to outliers.</p>
                    </div>
                </div>
            `;
            
            container.innerHTML += centroidHtml;
            
            addLogEntry(`üìç Centroid statistics calculated for ${sortedFreqs.length} frequencies`);
        }
        
        /**
         * Validate extracted centroids against Google Sheets ground truth
         * @param {Object} results - Results object with frequency keys
         * @param {Array} sortedFreqs - Sorted array of frequencies
         */
        function validateCentroidsAgainstSheets(results, sortedFreqs) {
            const validationResults = {
                total: 0,
                matched: 0,
                discrepancies: [],
                missingSheets: 0,
                sheetsSkipped: 0  // Shapes created from Sheets (no validation needed)
            };
            
            // Threshold for considering centroids as matching (in unit space)
            const MATCH_THRESHOLD = 0.5; // Half a unit tolerance
            
            for (const freq of sortedFreqs) {
                const data = results[freq];
                
                // Check red shapes
                for (const shape of data.redShapes) {
                    if (!shape.participant || !shape.trial) continue;
                    
                    // Skip shapes that were created FROM Sheets data or copied from blue
                    // These would be comparing Sheets data to itself
                    if (shape.createdFromSheetsData || shape.copiedFromBlue) {
                        validationResults.sheetsSkipped++;
                        continue;
                    }
                    
                    validationResults.total++;
                    
                    // Look up the Sheets centroid
                    const sheetsData = lookupSheetsData(shape.participant, shape.trial, freq, 'red');
                    
                    if (!sheetsData || !sheetsData.centroid) {
                        validationResults.missingSheets++;
                        continue;
                    }
                    
                    // Calculate distance between extracted and Sheets centroid
                    const dx = shape.centroid.x - sheetsData.centroid.x;
                    const dy = shape.centroid.y - sheetsData.centroid.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= MATCH_THRESHOLD) {
                        validationResults.matched++;
                    } else {
                        // Calculate extracted area if contour exists
                        const extractedArea = shape.contour ? calculateContourArea(shape.contour) : 0;
                        
                        validationResults.discrepancies.push({
                            participant: shape.participant,
                            trial: shape.trial,
                            frequency: freq,
                            color: 'red',
                            filename: shape.filename || `${shape.participant}_${freq}Hz`,
                            extracted: { x: shape.centroid.x.toFixed(2), y: shape.centroid.y.toFixed(2) },
                            sheets: { x: sheetsData.centroid.x.toFixed(2), y: sheetsData.centroid.y.toFixed(2) },
                            distance: distance.toFixed(3),
                            extractedArea: extractedArea.toFixed(2),
                            sheetsArea: sheetsData.area ? sheetsData.area.toFixed(2) : 'N/A',
                            pixelCount: shape.pixelCount || 'N/A',
                            wasTranslated: shape.wasTranslated || false,
                            translationOffset: shape.translationOffset ? 
                                `(${shape.translationOffset.x.toFixed(1)}, ${shape.translationOffset.y.toFixed(1)})` : 'N/A'
                        });
                    }
                }
                
                // Check blue shapes
                for (const shape of data.blueShapes) {
                    if (!shape.participant || !shape.trial) continue;
                    
                    // Skip shapes that were created FROM Sheets data
                    // These would be comparing Sheets data to itself
                    if (shape.createdFromSheetsData) {
                        validationResults.sheetsSkipped++;
                        continue;
                    }
                    
                    validationResults.total++;
                    
                    // Look up the Sheets centroid
                    const sheetsData = lookupSheetsData(shape.participant, shape.trial, freq, 'blue');
                    
                    if (!sheetsData || !sheetsData.centroid) {
                        validationResults.missingSheets++;
                        continue;
                    }
                    
                    // Calculate distance between extracted and Sheets centroid
                    const dx = shape.centroid.x - sheetsData.centroid.x;
                    const dy = shape.centroid.y - sheetsData.centroid.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= MATCH_THRESHOLD) {
                        validationResults.matched++;
                    } else {
                        // Calculate extracted area if contour exists
                        const extractedArea = shape.contour ? calculateContourArea(shape.contour) : 0;
                        
                        validationResults.discrepancies.push({
                            participant: shape.participant,
                            trial: shape.trial,
                            frequency: freq,
                            color: 'blue',
                            filename: shape.filename || `${shape.participant}_${freq}Hz`,
                            extracted: { x: shape.centroid.x.toFixed(2), y: shape.centroid.y.toFixed(2) },
                            sheets: { x: sheetsData.centroid.x.toFixed(2), y: sheetsData.centroid.y.toFixed(2) },
                            distance: distance.toFixed(3),
                            extractedArea: extractedArea.toFixed(2),
                            sheetsArea: sheetsData.area ? sheetsData.area.toFixed(2) : 'N/A',
                            pixelCount: shape.pixelCount || 'N/A',
                            wasTranslated: shape.wasTranslated || false,
                            translationOffset: shape.translationOffset ? 
                                `(${shape.translationOffset.x.toFixed(1)}, ${shape.translationOffset.y.toFixed(1)})` : 'N/A'
                        });
                    }
                }
            }
            
            // Display validation results
            displayCentroidValidation(validationResults);
        }
        
        /**
         * Display centroid validation results
         * @param {Object} validationResults - Results from validateCentroidsAgainstSheets
         */
        function displayCentroidValidation(validationResults) {
            const container = document.getElementById('area-stats-container');
            
            const matchRate = validationResults.total > 0 
                ? Math.round(100 * validationResults.matched / validationResults.total) 
                : 100;
            
            const totalAnalyzed = validationResults.total + validationResults.sheetsSkipped;
            const pngExtracted = validationResults.total;
            const fromSheets = validationResults.sheetsSkipped;
            
            let validationHtml = `
                <div class="mt-6 p-4 bg-purple-50 border border-purple-200 rounded-lg">
                    <h4 class="font-bold text-purple-800 mb-3">üîç Centroid Validation (vs Google Sheets)</h4>
                    <div class="text-sm mb-3">
                        <p class="mb-2 text-lg"><strong>üìä Total shapes in analysis: ${totalAnalyzed}</strong></p>
                        <p class="ml-4">‚Ä¢ ${pngExtracted} extracted from PNG images</p>
                        <p class="ml-4">‚Ä¢ ${fromSheets} created from Sheets data (small/missing extractions)</p>
                        <hr class="my-2 border-purple-200">
                        <p><strong>Validation threshold:</strong> 0.5 units</p>
                        <p class="mt-1"><strong>PNG extraction accuracy:</strong> ${validationResults.matched}/${pngExtracted} centroids match Sheets (${matchRate}%)</p>
            `;
            
            if (validationResults.sheetsSkipped > 0) {
                validationHtml += `<p class="text-green-600 mt-1">‚úì ${fromSheets} Sheets-created shapes included in all statistics above</p>`;
            }
            
            if (validationResults.missingSheets > 0) {
                validationHtml += `<p class="text-yellow-600 mt-1">‚ö†Ô∏è ${validationResults.missingSheets} shapes had no matching Sheets data for comparison</p>`;
            }
            
            validationHtml += `</div>`;
            
            if (validationResults.discrepancies.length > 0) {
                validationHtml += `
                    <div class="mt-3">
                        <p class="font-semibold text-red-700 mb-2">‚ö†Ô∏è ${validationResults.discrepancies.length} Discrepancies Found:</p>
                        <div class="max-h-96 overflow-y-auto overflow-x-auto">
                            <table class="w-full text-xs border-collapse min-w-max">
                                <thead>
                                    <tr class="bg-purple-100">
                                        <th class="border border-purple-300 px-2 py-1 text-left">File</th>
                                        <th class="border border-purple-300 px-2 py-1 text-left">Participant</th>
                                        <th class="border border-purple-300 px-2 py-1 text-left">T</th>
                                        <th class="border border-purple-300 px-2 py-1 text-left">Freq</th>
                                        <th class="border border-purple-300 px-2 py-1 text-left">Color</th>
                                        <th class="border border-purple-300 px-2 py-1 text-left">Extracted (x,y)</th>
                                        <th class="border border-purple-300 px-2 py-1 text-left">Sheets (x,y)</th>
                                        <th class="border border-purple-300 px-2 py-1 text-left">Dist</th>
                                        <th class="border border-purple-300 px-2 py-1 text-left">Ext Area</th>
                                        <th class="border border-purple-300 px-2 py-1 text-left">Sheets Area</th>
                                        <th class="border border-purple-300 px-2 py-1 text-left">Pixels</th>
                                        <th class="border border-purple-300 px-2 py-1 text-left">Translated?</th>
                                    </tr>
                                </thead>
                                <tbody>
                `;
                
                // Sort discrepancies by distance (largest first)
                const sortedDiscrepancies = [...validationResults.discrepancies].sort((a, b) => 
                    parseFloat(b.distance) - parseFloat(a.distance)
                );
                
                for (const d of sortedDiscrepancies) {
                    const colorClass = d.color === 'red' ? 'text-red-600' : 'text-blue-600';
                    const bgColor = d.color === 'red' ? 'bg-red-50' : 'bg-blue-50';
                    const distanceFloat = parseFloat(d.distance);
                    const distanceClass = distanceFloat > 2 ? 'bg-red-200 font-bold' : 
                                         distanceFloat > 1 ? 'bg-orange-200' : '';
                    
                    // Calculate area deviation if both areas available
                    let areaDeviation = '';
                    if (d.extractedArea !== 'N/A' && d.sheetsArea !== 'N/A') {
                        const extArea = parseFloat(d.extractedArea);
                        const shArea = parseFloat(d.sheetsArea);
                        if (shArea > 0) {
                            const deviation = Math.abs(1 - extArea / shArea) * 100;
                            areaDeviation = deviation > 30 ? ` (${deviation.toFixed(0)}%‚ö†Ô∏è)` : ` (${deviation.toFixed(0)}%)`;
                        }
                    }
                    
                    validationHtml += `
                        <tr class="hover:bg-purple-50 ${bgColor}">
                            <td class="border border-purple-200 px-2 py-1 font-mono text-[10px] max-w-32 truncate" title="${d.filename}">${d.filename}</td>
                            <td class="border border-purple-200 px-2 py-1">${d.participant}</td>
                            <td class="border border-purple-200 px-2 py-1">${d.trial}</td>
                            <td class="border border-purple-200 px-2 py-1">${d.frequency}</td>
                            <td class="border border-purple-200 px-2 py-1 ${colorClass} font-semibold">${d.color}</td>
                            <td class="border border-purple-200 px-2 py-1 font-mono">(${d.extracted.x}, ${d.extracted.y})</td>
                            <td class="border border-purple-200 px-2 py-1 font-mono">(${d.sheets.x}, ${d.sheets.y})</td>
                            <td class="border border-purple-200 px-2 py-1 font-semibold ${distanceClass}">${d.distance}</td>
                            <td class="border border-purple-200 px-2 py-1">${d.extractedArea}${areaDeviation}</td>
                            <td class="border border-purple-200 px-2 py-1">${d.sheetsArea}</td>
                            <td class="border border-purple-200 px-2 py-1">${d.pixelCount}</td>
                            <td class="border border-purple-200 px-2 py-1">${d.wasTranslated ? '‚úì' : '‚úó'}</td>
                        </tr>
                    `;
                }
                
                validationHtml += `
                                </tbody>
                            </table>
                        </div>
                        <p class="text-xs text-gray-500 mt-2">Sorted by distance (largest first). Dist > 2 units highlighted in red, > 1 unit in orange.</p>
                    </div>
                `;
            } else if (validationResults.total > 0) {
                validationHtml += `<p class="text-green-600 mt-2">‚úì All extracted centroids match Google Sheets data within tolerance!</p>`;
            }
            
            validationHtml += `</div>`;
            
            // Append to existing container
            container.innerHTML += validationHtml;
            
            // Log summary
            addLogEntry(`üîç Centroid validation: ${validationResults.matched}/${validationResults.total} match (${matchRate}%)`);
            if (validationResults.discrepancies.length > 0) {
                addLogEntry(`‚ö†Ô∏è ${validationResults.discrepancies.length} centroid discrepancies found (see validation report)`);
            }
        }
        
        async function downloadAllComposites() {
            const zip = new JSZip();
            const folder = zip.folder('composite_images');
            
            for (const [freq, canvas] of Object.entries(compositeCanvases)) {
                const dataUrl = canvas.toDataURL('image/png');
                const base64 = dataUrl.split(',')[1];
                folder.file(`composite_${freq}Hz.png`, base64, { base64: true });
            }
            
            const blob = await zip.generateAsync({ type: 'blob' });
            saveAs(blob, 'sound_object_composites.zip');
        }
        
        // ============================================
        // EVENT LISTENERS
        // ============================================
        
        document.addEventListener('DOMContentLoaded', () => {
            const dropZone = document.getElementById('drop-zone');
            const fileInput = document.getElementById('file-input');
            
            // Initialize averaging mode UI
            updateAveragingMode();
            
            // Drag and drop
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-active');
            });
            
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('drag-active');
            });
            
            dropZone.addEventListener('drop', async (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-active');
                await handleFiles(e.dataTransfer.files);
            });
            
            // File input
            fileInput.addEventListener('change', async (e) => {
                await handleFiles(e.target.files);
            });
            
            // Analyze button
            document.getElementById('analyze-btn').addEventListener('click', runAnalysis);
            
            // Download all button
            document.getElementById('download-all-btn').addEventListener('click', downloadAllComposites);
        });
    </script>
</body>
</html>
