<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sound Object Analyzer - Complete v5.0 with Google Sheets Validation</title>
    <meta name="version" content="5.0.0">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            font-family: ui-sans-serif, system-ui, sans-serif;
            background-color: #f3f4f6;
            zoom: 0.75;
            -moz-transform: scale(0.75);
            -moz-transform-origin: 0 0;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .canvas-container {
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        
        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
        }
        
        @media (max-width: 768px) {
            body {
                zoom: 1;
                -moz-transform: scale(1);
                padding: 0.75rem;
                width: 100vw;
            }
            
            .analysis-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .max-w-7xl {
                max-width: 100%;
                width: 100%;
                padding: 0;
                margin: 0;
            }
            
            button {
                min-height: 44px;
                touch-action: manipulation;
            }
            
            input[type="file"] {
                font-size: 16px;
            }
        }
        
        @media (min-width: 769px) and (max-width: 1024px) {
            body {
                zoom: 0.9;
                -moz-transform: scale(0.9);
                -moz-transform-origin: 0 0;
                width: 100vw;
                padding: 1rem;
            }
            
            .analysis-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .max-w-7xl {
                max-width: 100%;
                width: 100%;
            }
        }
        
        @media (min-width: 1920px) {
            body {
                zoom: 0.8;
                -moz-transform: scale(0.8);
            }
        }
        
        .metrics-dropdown {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            opacity: 0;
        }
        
        .metrics-dropdown.open {
            max-height: 800px;
            opacity: 1;
        }
        
        .validation-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .validation-pass {
            background-color: #d1fae5;
            color: #065f46;
        }
        
        .validation-warn {
            background-color: #fef3c7;
            color: #92400e;
        }
        
        .validation-fail {
            background-color: #fee2e2;
            color: #991b1b;
        }
        
        .progress-bar-fill {
            transition: width 0.2s ease-out;
        }
    </style>
</head>
<body class="p-4 md:p-8">
    
    <div class="max-w-7xl mx-auto">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-2xl sm:text-3xl lg:text-4xl font-extrabold text-blue-800 mb-2">
                Sound Object Average Shape Analyzer
                <span class="inline-block ml-2 px-3 py-1 text-xs font-bold bg-gradient-to-r from-purple-500 to-pink-600 text-white rounded-full shadow-lg">
                    âš¡ COMPLETE v5.0
                </span>
            </h1>
            <p class="text-lg sm:text-xl font-semibold text-gray-600">UCI Hearing & Speech Lab</p>
            <p class="text-xs sm:text-sm text-gray-500 mt-2">
                Advanced contour detection â€¢ Overlap handling â€¢ MAD outlier filtering â€¢ Google Sheets validation
            </p>
        </header>
        
        <!-- Google Sheets Configuration Section -->
        <div class="bg-gradient-to-r from-green-50 to-emerald-50 p-4 sm:p-6 rounded-xl shadow-lg mb-6 border border-green-200">
            <h2 class="text-lg sm:text-xl font-bold text-green-800 mb-4 flex items-center gap-2">
                <svg class="w-5 h-5 sm:w-6 sm:h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                </svg>
                Google Sheets Validation (Optional)
            </h2>
            <p class="text-sm text-gray-700 mb-4">
                Enable continuous validation against your Google Sheets data containing participant ID, frequency, color, centroid coordinates, and area measurements.
                <strong class="text-green-700">âœ… COMPLETELY FREE</strong> - Choose either method below.
            </p>
            
            <div class="mb-3 p-3 bg-blue-50 border-l-4 border-blue-400 rounded">
                <p class="text-xs font-semibold text-blue-800">ðŸ“Œ Two Methods (Both Free):</p>
                <p class="text-xs text-gray-700 mt-1">
                    <strong>Option 1 (Easiest):</strong> Deploy your Apps Script â†’ Paste web app URL below (no API key needed!)
                    <a href="#" onclick="showAppsScriptGuide(); return false;" class="text-blue-600 hover:underline ml-1">Setup guide â†’</a>
                </p>
                <p class="text-xs text-gray-700 mt-1">
                    <strong>Option 2:</strong> Use Google Sheets API â†’ Need both URL and API key
                    <a href="#" onclick="showSheetsInstructions(); return false;" class="text-blue-600 hover:underline ml-1">Instructions â†’</a>
                </p>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label class="block text-xs sm:text-sm font-semibold text-gray-700 mb-2">
                        Google Sheets URL or Apps Script URL
                    </label>
                    <input 
                        type="text" 
                        id="sheets-url" 
                        placeholder="https://docs.google.com/spreadsheets/... OR https://script.google.com/macros/..."
                        class="w-full px-3 py-2 border-2 border-gray-200 rounded-lg text-sm focus:border-green-400 focus:outline-none"
                    >
                    <p class="text-xs text-gray-500 mt-1">Paste either your Sheet URL or Apps Script web app URL</p>
                </div>
                <div>
                    <label class="block text-xs sm:text-sm font-semibold text-gray-700 mb-2">
                        Google API Key <span class="text-xs font-normal text-gray-500">(only if using Option 2)</span>
                    </label>
                    <input 
                        type="password" 
                        id="api-key" 
                        placeholder="Leave blank if using Apps Script"
                        class="w-full px-3 py-2 border-2 border-gray-200 rounded-lg text-sm focus:border-green-400 focus:outline-none"
                    >
                    <p class="text-xs text-gray-500 mt-1">Not needed for Apps Script web app</p>
                </div>
            </div>
            
            <div class="flex gap-3">
                <button 
                    id="validate-sheets-btn" 
                    class="px-4 py-2 rounded-lg font-bold text-sm text-white bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 transition-all shadow"
                >
                    ðŸ”— Connect & Validate
                </button>
                <button 
                    id="test-sheets-btn" 
                    class="px-4 py-2 rounded-lg font-bold text-sm text-gray-700 bg-gray-100 hover:bg-gray-200 transition-all"
                >
                    ðŸ§ª Test Connection
                </button>
            </div>
            
            <div id="sheets-status" class="mt-4 hidden">
                <div class="p-3 rounded-lg border-2" id="sheets-status-content"></div>
            </div>
        </div>
        
        <!-- Instructions -->
        <div class="bg-gradient-to-r from-blue-50 to-indigo-50 p-4 sm:p-6 rounded-xl shadow-lg mb-6 border border-blue-200">
            <h2 class="text-lg sm:text-xl font-bold text-blue-800 mb-4 flex items-center gap-2">
                <svg class="w-5 h-5 sm:w-6 sm:h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
                How to Use - Enhanced Features
            </h2>
            <ol class="list-decimal list-inside space-y-2 text-sm sm:text-base text-gray-700">
                <li><strong>Upload Files:</strong> Select PNG files OR ZIP files (even nested ZIPs!) from the Sound Object tool</li>
                <li><strong>Auto-Detection:</strong> Frequency, phase (Red/Blue), and participant ID parsed from filenames</li>
                <li><strong>Trial Mapping:</strong> Inconsistent trial numbers auto-corrected (lowestâ†’1, middleâ†’2, highestâ†’3)</li>
                <li><strong>Overlap Handling:</strong> Advanced contour detection reconstructs shapes where blue overlaps red</li>
                <li><strong>Outlier Filtering:</strong> MAD (Median Absolute Deviation) removes statistical outliers while preserving natural variation</li>
                <li><strong>Google Sheets Validation:</strong> Optional continuous validation against ground truth data</li>
                <li><strong>View Results:</strong> Publication-ready composite figures with individual gray shapes + averaged red/blue lines</li>
            </ol>
        </div>
        
        <!-- File Upload Section -->
        <div class="bg-white p-4 sm:p-6 rounded-xl shadow-lg mb-6 border border-gray-100">
            <h2 class="text-xl sm:text-2xl font-bold text-gray-800 mb-4 flex items-center gap-2">
                <svg class="w-6 h-6 sm:w-7 sm:h-7 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                </svg>
                Upload Participant Images
            </h2>
            
            <div class="mb-4">
                <label class="block text-xs sm:text-sm font-semibold text-gray-700 mb-2">
                    Select PNG files OR ZIP files containing PNGs (multiple files/folders allowed)
                </label>
                <input 
                    type="file" 
                    id="image-upload" 
                    accept="image/png,.zip,application/zip" 
                    multiple
                    class="block w-full text-xs sm:text-sm text-gray-700
                        file:mr-4 file:py-2 sm:file:py-3 file:px-4 sm:file:px-6
                        file:rounded-xl file:border-0
                        file:text-xs sm:file:text-sm file:font-bold
                        file:bg-gradient-to-r file:from-blue-500 file:to-indigo-600
                        file:text-white file:cursor-pointer
                        hover:file:from-blue-600 hover:file:to-indigo-700
                        border-2 border-gray-200 rounded-xl
                        hover:border-blue-300 transition-all p-2 sm:p-3 bg-gray-50"
                >
            </div>
            
            <div id="file-list" class="mt-4 text-xs sm:text-sm text-gray-600"></div>
            
            <div class="mt-6 flex flex-col sm:flex-row gap-3">
                <button 
                    id="analyze-btn" 
                    disabled
                    class="flex-1 px-4 sm:px-6 py-2 sm:py-3 rounded-xl font-bold text-sm sm:text-base text-white 
                        bg-gradient-to-r from-purple-500 to-pink-600 
                        hover:from-purple-600 hover:to-pink-700 
                        disabled:from-gray-300 disabled:to-gray-400 
                        disabled:cursor-not-allowed transition-all transform 
                        hover:scale-105 disabled:hover:scale-100 shadow-lg"
                >
                    ðŸš€ Analyze & Generate Visualizations
                </button>
                
                <button 
                    id="cancel-btn" 
                    class="hidden flex-1 px-4 sm:px-6 py-2 sm:py-3 rounded-xl font-bold text-sm sm:text-base text-white 
                        bg-gradient-to-r from-red-500 to-red-600 
                        hover:from-red-600 hover:to-red-700 
                        transition-all shadow-lg"
                >
                    â›” Cancel Processing
                </button>
            </div>
        </div>
        
        <!-- Progress Container with Metrics Dropdown -->
        <div id="progress-container" class="hidden bg-white p-6 rounded-xl shadow-lg mb-6 border border-gray-200">
            <div class="mb-2 flex justify-between items-center">
                <h3 class="text-lg font-bold text-gray-800">Processing Progress</h3>
                <span id="progress-percentage" class="text-sm font-mono font-bold text-purple-600">0%</span>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-4 overflow-hidden shadow-inner">
                <div id="progress-bar" class="progress-bar-fill h-4 bg-gradient-to-r from-purple-500 to-pink-600 rounded-full" style="width: 0%"></div>
            </div>
            <p id="progress-text" class="mt-2 text-sm text-gray-600 font-semibold"></p>
            
            <!-- Real-Time Metrics Dropdown -->
            <div class="mt-4">
                <button 
                    id="toggle-metrics" 
                    class="w-full flex items-center justify-between px-4 py-2 bg-gradient-to-r from-purple-50 to-pink-50 hover:from-purple-100 hover:to-pink-100 rounded-lg border border-purple-200 transition-all"
                >
                    <span class="text-sm font-bold text-purple-800 flex items-center gap-2">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                        </svg>
                        Real-Time Performance Metrics
                    </span>
                    <svg id="metrics-arrow" class="w-5 h-5 text-purple-600 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </button>
                
                <div id="metrics-dropdown" class="metrics-dropdown mt-3">
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 p-4 bg-gradient-to-r from-purple-50 to-pink-50 rounded-lg border border-purple-200">
                        <div class="bg-white p-3 rounded-lg shadow">
                            <div class="flex justify-between items-center mb-2">
                                <div class="text-xs text-gray-500 font-semibold">Processing Speed</div>
                                <div id="speed-metric" class="text-lg font-bold text-purple-600">0 img/s</div>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-2 overflow-hidden">
                                <div id="speed-progress" class="h-2 bg-gradient-to-r from-purple-400 to-purple-600 rounded-full" style="width: 0%"></div>
                            </div>
                        </div>
                        
                        <div class="bg-white p-3 rounded-lg shadow">
                            <div class="flex justify-between items-center mb-2">
                                <div class="text-xs text-gray-500 font-semibold">Time Remaining</div>
                                <div id="eta-metric" class="text-lg font-bold text-blue-600">--</div>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-2 overflow-hidden">
                                <div id="eta-progress" class="h-2 bg-gradient-to-r from-blue-400 to-blue-600 rounded-full" style="width: 0%"></div>
                            </div>
                        </div>
                        
                        <div class="bg-white p-3 rounded-lg shadow">
                            <div class="flex justify-between items-center mb-2">
                                <div class="text-xs text-gray-500 font-semibold">Shapes Validated</div>
                                <div id="validation-metric" class="text-lg font-bold text-green-600">0/0</div>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-2 overflow-hidden">
                                <div id="validation-progress" class="h-2 bg-gradient-to-r from-green-400 to-green-600 rounded-full" style="width: 0%"></div>
                            </div>
                        </div>
                        
                        <div class="bg-white p-3 rounded-lg shadow">
                            <div class="flex justify-between items-center mb-2">
                                <div class="text-xs text-gray-500 font-semibold">Outliers Filtered</div>
                                <div id="outlier-metric" class="text-lg font-bold text-amber-600">0</div>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-2 overflow-hidden">
                                <div id="outlier-progress" class="h-2 bg-gradient-to-r from-amber-400 to-amber-600 rounded-full" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Validation Summary -->
        <div id="validation-summary" class="hidden bg-white p-6 rounded-xl shadow-lg mb-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Validation Summary</h2>
            <div id="validation-content" class="grid grid-cols-1 md:grid-cols-3 gap-4"></div>
        </div>
        
        <!-- Data Summary -->
        <div id="data-summary" class="hidden bg-white p-6 rounded-xl shadow-lg mb-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Analysis Summary</h2>
            <div id="summary-content" class="grid grid-cols-1 md:grid-cols-3 gap-4"></div>
        </div>
        
        <!-- Visualization Results -->
        <div id="visualization-container" class="hidden mb-6">
            <div class="bg-white p-6 rounded-xl shadow-lg mb-4">
                <h2 class="text-2xl font-bold text-gray-800 mb-2">Averaged Shape Visualizations</h2>
                <p class="text-sm text-gray-600 mb-4">Click on any figure to download as PNG</p>
            </div>
            <div id="canvas-grid" class="analysis-grid"></div>
        </div>
        
        <!-- Statistics Table -->
        <div id="statistics-container" class="hidden bg-white p-6 rounded-xl shadow-lg mb-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Statistical Summary</h2>
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gradient-to-r from-blue-50 to-indigo-50">
                        <tr>
                            <th class="px-4 py-3 text-left text-xs font-bold text-gray-700 uppercase tracking-wider">Frequency</th>
                            <th class="px-4 py-3 text-left text-xs font-bold text-gray-700 uppercase tracking-wider">Color</th>
                            <th class="px-4 py-3 text-left text-xs font-bold text-gray-700 uppercase tracking-wider">N</th>
                            <th class="px-4 py-3 text-left text-xs font-bold text-gray-700 uppercase tracking-wider">Outliers</th>
                            <th class="px-4 py-3 text-left text-xs font-bold text-gray-700 uppercase tracking-wider">Mean Radius</th>
                            <th class="px-4 py-3 text-left text-xs font-bold text-gray-700 uppercase tracking-wider">SD Radius</th>
                            <th class="px-4 py-3 text-left text-xs font-bold text-gray-700 uppercase tracking-wider">Mean Area</th>
                            <th class="px-4 py-3 text-left text-xs font-bold text-gray-700 uppercase tracking-wider">Validation</th>
                        </tr>
                    </thead>
                    <tbody id="statistics-body" class="bg-white divide-y divide-gray-200"></tbody>
                </table>
            </div>
        </div>
        
        <!-- Footer -->
        <footer class="text-center text-sm text-gray-500 mt-8 pb-4">
            <p class="font-semibold">UCI Hearing & Speech Lab - Sound Object Analyzer v5.0 Complete</p>
            <p class="mt-1">Contour Detection â€¢ Overlap Reconstruction â€¢ MAD Outlier Filtering â€¢ Google Sheets Validation</p>
        </footer>
    </div>
    
    <script>
        // ============================================
        // GLOBAL CONSTANTS & CONFIGURATION
        // ============================================
        
        const FREQUENCIES = ['31Hz', '62.5Hz', '125Hz', '250Hz', '500Hz', '1000Hz', '2000Hz', '4000Hz', '8000Hz', '12000Hz', '16000Hz'];
        const FREQUENCY_NUMBERS = [31, 62.5, 125, 250, 500, 1000, 2000, 4000, 8000, 12000, 16000];
        const CPU_CORES = navigator.hardwareConcurrency || 4;
        const MAX_PARALLEL_WORKERS = Math.max(2, Math.min(CPU_CORES, 6));
        
        // Canvas/Grid constants (from original drawing tool)
        const CANVAS_SIZE = 1000;  // 1000x1000 pixels
        const GRID_RANGE = 10;     // -10 to +10 units
        const SCALE_FACTOR = CANVAS_SIZE / (2 * GRID_RANGE); // 50 pixels per unit
        const CENTER_X = CANVAS_SIZE / 2;  // 500
        const CENTER_Y = CANVAS_SIZE / 2;  // 500
        const REFERENCE_CIRCLE_RADIUS = 3; // 3 units
        
        // Processing state
        let processingCancelled = false;
        let activeWorkers = new Set();
        let googleSheetsData = null;
        let sheetsValidationEnabled = false;
        
        const processingStats = {
            startTime: 0,
            processedCount: 0,
            totalCount: 0,
            speedHistory: [],
            maxSpeed: 0,
            validatedCount: 0,
            outliersFiltered: 0
        };
        
        // ============================================
        // GOOGLE SHEETS INTEGRATION (READ-ONLY)
        // ============================================
        
        async function connectToGoogleSheets() {
            const url = document.getElementById('sheets-url').value.trim();
            const apiKey = document.getElementById('api-key').value.trim();
            
            if (!url) {
                showSheetsStatus('error', 'Please enter a Google Sheets URL or Apps Script URL');
                return false;
            }
            
            try {
                // Detect which method: Apps Script or Direct API
                const isAppsScript = url.includes('script.google.com');
                
                if (isAppsScript) {
                    // **METHOD 1: Apps Script (No API Key Needed)** âœ… FREE
                    console.log('[Sheets] Using Apps Script web app (no API key needed)');
                    showSheetsStatus('loading', 'Connecting via Apps Script...');
                    
                    const response = await fetch(`${url}?action=getAllData`);
                    
                    if (!response.ok) {
                        throw new Error(`Apps Script request failed: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    
                    if (!data.success || !data.shapes || data.shapes.length === 0) {
                        throw new Error('No data found in Apps Script response');
                    }
                    
                    // Convert Apps Script format to our internal format
                    googleSheetsData = data.shapes.map(shape => ({
                        participantId: String(shape.participant).trim(),
                        frequency: parseFloat(shape.frequency),
                        color: String(shape.color).toLowerCase(),
                        trial: parseInt(shape.trial),
                        centroidX: parseFloat(shape.centroid.x),
                        centroidY: parseFloat(shape.centroid.y),
                        area: parseFloat(shape.area)
                    }));
                    
                    sheetsValidationEnabled = true;
                    showSheetsStatus('success', `âœ… Connected via Apps Script! Loaded ${googleSheetsData.length} records (FREE - no API key)`);
                    console.log('[Sheets] Loaded', googleSheetsData.length, 'records from Apps Script');
                    return true;
                    
                } else {
                    // **METHOD 2: Direct Google Sheets API** âœ… Also FREE (within generous limits)
                    if (!apiKey) {
                        showSheetsStatus('error', 'API key required for direct API access (or use Apps Script URL)');
                        return false;
                    }
                    
                    console.log('[Sheets] Using Google Sheets API (with API key)');
                    showSheetsStatus('loading', 'Connecting via Google Sheets API...');
                    
                    // Extract spreadsheet ID
                    const spreadsheetId = extractSpreadsheetId(url);
                    if (!spreadsheetId) {
                        throw new Error('Invalid Google Sheets URL');
                    }
                    
                    // Fetch from "Data" tab
                    const range = 'Data!A:I';
                    const apiUrl = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${range}?key=${apiKey}`;
                    
                    const response = await fetch(apiUrl);
                    if (!response.ok) {
                        throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    
                    if (!data.values || data.values.length === 0) {
                        throw new Error('No data found in "Data" tab');
                    }
                    
                    // Parse sheet data (existing function)
                    googleSheetsData = parseGoogleSheetsData(data.values);
                    sheetsValidationEnabled = true;
                    
                    showSheetsStatus('success', `âœ… Connected via API! Loaded ${googleSheetsData.length} records (FREE - within quota)`);
                    console.log('[Sheets] Loaded', googleSheetsData.length, 'records from API');
                    return true;
                }
                
            } catch (error) {
                showSheetsStatus('error', `Connection failed: ${error.message}`);
                console.error('[Sheets] Error:', error);
                return false;
            }
        }
        
        function extractSpreadsheetId(url) {
            const match = url.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
            return match ? match[1] : null;
        }
        
        function parseGoogleSheetsData(values) {
            // Expected columns: Participant ID | Frequency | Color | Trial | Centroid X | Centroid Y | Area | ... 
            const headers = values[0].map(h => h.toLowerCase().trim());
            const data = [];
            
            for (let i = 1; i < values.length; i++) {
                const row = values[i];
                if (row.length < 7) continue; // Skip incomplete rows
                
                const record = {
                    participantId: row[headers.indexOf('participant id')] || row[headers.indexOf('participant')] || row[0],
                    frequency: parseFloat(row[headers.indexOf('frequency')]) || parseFloat(row[1]),
                    color: (row[headers.indexOf('color')] || row[2]).toLowerCase(),
                    trial: parseInt(row[headers.indexOf('trial')]) || parseInt(row[3]),
                    centroidX: parseFloat(row[headers.indexOf('centroid x')] || row[headers.indexOf('centroid_x')] || row[4]),
                    centroidY: parseFloat(row[headers.indexOf('centroid y')] || row[headers.indexOf('centroid_y')] || row[5]),
                    area: parseFloat(row[headers.indexOf('area')] || row[6])
                };
                
                // Validate required fields
                if (record.participantId && !isNaN(record.frequency) && record.color && 
                    !isNaN(record.centroidX) && !isNaN(record.centroidY) && !isNaN(record.area)) {
                    data.push(record);
                }
            }
            
            return data;
        }
        
        function showSheetsStatus(type, message) {
            const container = document.getElementById('sheets-status');
            const content = document.getElementById('sheets-status-content');
            
            container.classList.remove('hidden');
            
            let bgColor, borderColor, textColor, icon;
            
            if (type === 'success') {
                bgColor = 'bg-green-50';
                borderColor = 'border-green-300';
                textColor = 'text-green-800';
                icon = 'âœ“';
            } else if (type === 'error') {
                bgColor = 'bg-red-50';
                borderColor = 'border-red-300';
                textColor = 'text-red-800';
                icon = 'âœ—';
            } else if (type === 'loading') {
                bgColor = 'bg-blue-50';
                borderColor = 'border-blue-300';
                textColor = 'text-blue-800';
                icon = 'â³';
            } else {
                bgColor = 'bg-yellow-50';
                borderColor = 'border-yellow-300';
                textColor = 'text-yellow-800';
                icon = 'âš ';
            }
            
            content.className = `p-3 rounded-lg border-2 ${bgColor} ${borderColor}`;
            content.innerHTML = `<p class="text-sm font-semibold ${textColor}">${icon} ${message}</p>`;
        }
        
        function validateShapeAgainstSheets(participantId, frequency, color, trial, centroid, area) {
            if (!sheetsValidationEnabled || !googleSheetsData) {
                return { valid: true, confidence: 0, message: 'Validation disabled' };
            }
            
            // Find matching record in sheets
            const matchingRecords = googleSheetsData.filter(record => 
                record.participantId === participantId &&
                Math.abs(record.frequency - frequency) < 0.1 &&
                record.color === color.toLowerCase() &&
                record.trial === trial
            );
            
            if (matchingRecords.length === 0) {
                return { valid: true, confidence: 0, message: 'No sheet data for comparison' };
            }
            
            const sheetRecord = matchingRecords[0];
            
            // Calculate deviations
            const centroidErrorX = Math.abs(centroid.x - sheetRecord.centroidX);
            const centroidErrorY = Math.abs(centroid.y - sheetRecord.centroidY);
            const centroidError = Math.sqrt(centroidErrorX * centroidErrorX + centroidErrorY * centroidErrorY);
            const areaError = Math.abs((area - sheetRecord.area) / sheetRecord.area) * 100; // Percentage
            
            // Validation thresholds
            const CENTROID_THRESHOLD = 0.5; // 0.5 units
            const AREA_THRESHOLD = 15; // 15% difference
            
            let valid = true;
            let confidence = 100;
            let warnings = [];
            
            if (centroidError > CENTROID_THRESHOLD) {
                valid = false;
                confidence -= 30;
                warnings.push(`Centroid mismatch: ${centroidError.toFixed(2)} units`);
            }
            
            if (areaError > AREA_THRESHOLD) {
                valid = false;
                confidence -= 30;
                warnings.push(`Area mismatch: ${areaError.toFixed(1)}%`);
            }
            
            // If minor deviations, still pass but with lower confidence
            if (centroidError > CENTROID_THRESHOLD / 2 && centroidError <= CENTROID_THRESHOLD) {
                confidence -= 10;
            }
            if (areaError > AREA_THRESHOLD / 2 && areaError <= AREA_THRESHOLD) {
                confidence -= 10;
            }
            
            processingStats.validatedCount++;
            updateValidationMetric();
            
            return {
                valid,
                confidence: Math.max(0, confidence),
                centroidError,
                areaError,
                warnings: warnings.length > 0 ? warnings.join('; ') : 'Validation passed',
                sheetData: sheetRecord
            };
        }
        
        // ============================================
        // TRIAL NUMBER RE-MAPPING
        // ============================================
        
        function normalizeTrialNumbers(participantFiles) {
            // Group files by participant and frequency (NOT color, since each file has both colors)
            const grouped = {};
            
            participantFiles.forEach(file => {
                const key = `${file.participant}_${file.frequency}`;
                if (!grouped[key]) {
                    grouped[key] = [];
                }
                grouped[key].push(file);
            });
            
            // For each group, re-map trial numbers based on ZIP order
            Object.keys(grouped).forEach(key => {
                const files = grouped[key];
                
                // Check if files have ZIP order numbers
                const hasZipOrder = files.some(f => f.zipOrderNumber !== null && f.zipOrderNumber !== undefined);
                
                if (hasZipOrder) {
                    // Sort by ZIP order number (lowest first)
                    files.sort((a, b) => {
                        const orderA = a.zipOrderNumber !== null ? a.zipOrderNumber : 999;
                        const orderB = b.zipOrderNumber !== null ? b.zipOrderNumber : 999;
                        return orderA - orderB;
                    });
                    
                    console.log(`[Trial] ${key}: Sorting by ZIP order numbers`);
                } else {
                    // Fallback: Sort alphabetically by filename
                    files.sort((a, b) => a.filename.localeCompare(b.filename));
                    console.log(`[Trial] ${key}: No ZIP order found, sorting alphabetically`);
                }
                
                // Re-map: lowest â†’ 1, second-lowest â†’ 2, highest â†’ 3
                if (files.length >= 1) files[0].normalizedTrial = 1;
                if (files.length >= 2) files[1].normalizedTrial = 2;
                if (files.length >= 3) files[2].normalizedTrial = 3;
                
                // Handle cases with more than 3 files (use only first 3)
                for (let i = 3; i < files.length; i++) {
                    files[i].normalizedTrial = null; // Mark as extra/invalid
                    const zipInfo = files[i].sourceZip ? ` from ${files[i].sourceZip}` : '';
                    console.warn(`[Trial] ${key}: File ${files[i].filename}${zipInfo} is position #${i+1} (>3), will be ignored`);
                }
                
                // Log the mapping for transparency
                if (files.length > 0 && files.length <= 3) {
                    console.log(`[Trial] ${key}: Assigned trials:`);
                    files.forEach((f, idx) => {
                        const zipInfo = f.sourceZip ? ` (from ${f.sourceZip}, ZIP order=${f.zipOrderNumber})` : ' (direct PNG)';
                        console.log(`[Trial]   â†’ Trial ${idx + 1}: ${f.filename}${zipInfo}`);
                    });
                }
            });
            
            return participantFiles;
        }
        
        // ============================================
        // ADVANCED EDGE DETECTION & CONTOUR TRACING
        // ============================================
        
        function detectEdges(imageData, targetColor) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            const edges = [];
            
            // Convert target color string to RGB
            const [tr, tg, tb] = targetColor.split(',').map(Number);
            
            // Scan for edge pixels (pixels of target color adjacent to non-target pixels)
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    const a = data[idx + 3];
                    
                    // Skip if not target color
                    if (Math.abs(r - tr) > 5 || Math.abs(g - tg) > 5 || Math.abs(b - tb) > 5 || a < 128) {
                        continue;
                    }
                    
                    // Check if this is an edge pixel (has non-target neighbor)
                    let isEdge = false;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            
                            const nx = x + dx;
                            const ny = y + dy;
                            const nidx = (ny * width + nx) * 4;
                            const nr = data[nidx];
                            const ng = data[nidx + 1];
                            const nb = data[nidx + 2];
                            const na = data[nidx + 3];
                            
                            if (Math.abs(nr - tr) > 5 || Math.abs(ng - tg) > 5 || Math.abs(nb - tb) > 5 || na < 128) {
                                isEdge = true;
                                break;
                            }
                        }
                        if (isEdge) break;
                    }
                    
                    if (isEdge) {
                        edges.push({ x, y });
                    }
                }
            }
            
            return edges;
        }
        
        function traceContour(edges) {
            if (edges.length === 0) return [];
            
            // Sort edges by angle from center
            const sortedEdges = edges.map(edge => {
                const dx = edge.x - CENTER_X;
                const dy = edge.y - CENTER_Y;
                const angle = Math.atan2(dy, dx);
                const radius = Math.sqrt(dx * dx + dy * dy);
                return { ...edge, angle, radius };
            });
            
            sortedEdges.sort((a, b) => a.angle - b.angle);
            
            return sortedEdges;
        }
        
        function extractCompleteShapeContour(imageData, targetColorString) {
            // Detect edges
            const edges = detectEdges(imageData, targetColorString);
            
            if (edges.length === 0) {
                console.warn('[Contour] No edges found for color:', targetColorString);
                return [];
            }
            
            // Trace contour
            const contour = traceContour(edges);
            
            // Fill gaps using interpolation
            const completeContour = fillContourGaps(contour);
            
            return completeContour;
        }
        
        function fillContourGaps(contour) {
            if (contour.length < 2) return contour;
            
            const filled = [];
            const angleThreshold = 0.05; // ~3 degrees
            
            for (let i = 0; i < contour.length; i++) {
                const current = contour[i];
                const next = contour[(i + 1) % contour.length];
                
                filled.push(current);
                
                // Check if there's a gap
                const angleDiff = Math.abs(next.angle - current.angle);
                
                if (angleDiff > angleThreshold) {
                    // Interpolate between current and next
                    const steps = Math.ceil(angleDiff / angleThreshold);
                    
                    for (let step = 1; step < steps; step++) {
                        const t = step / steps;
                        const interpolatedAngle = current.angle + (next.angle - current.angle) * t;
                        const interpolatedRadius = current.radius + (next.radius - current.radius) * t;
                        
                        const x = CENTER_X + interpolatedRadius * Math.cos(interpolatedAngle);
                        const y = CENTER_Y + interpolatedRadius * Math.sin(interpolatedAngle);
                        
                        filled.push({
                            x: Math.round(x),
                            y: Math.round(y),
                            angle: interpolatedAngle,
                            radius: interpolatedRadius,
                            interpolated: true
                        });
                    }
                }
            }
            
            return filled;
        }
        
        // ============================================
        // MAD (MEDIAN ABSOLUTE DEVIATION) OUTLIER DETECTION
        // ============================================
        
        function calculateMedian(values) {
            if (values.length === 0) return 0;
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
        }
        
        function calculateMAD(values) {
            const median = calculateMedian(values);
            const absoluteDeviations = values.map(v => Math.abs(v - median));
            return calculateMedian(absoluteDeviations);
        }
        
        function filterOutliersMAD(values, threshold = 3.5) {
            if (values.length < 3) return { valid: values, outliers: [] };
            
            const median = calculateMedian(values);
            const mad = calculateMAD(values);
            
            const valid = [];
            const outliers = [];
            
            values.forEach((value, index) => {
                const modifiedZScore = mad === 0 ? 0 : (0.6745 * (value - median)) / mad;
                
                if (Math.abs(modifiedZScore) < threshold) {
                    valid.push({ value, index });
                } else {
                    outliers.push({ value, index, zScore: modifiedZScore });
                    processingStats.outliersFiltered++;
                }
            });
            
            updateOutlierMetric();
            
            return { valid, outliers };
        }
        
        function filterRadialOutliers(participantShapes) {
            const numAngles = 360;
            const filteredShapes = participantShapes.map(shape => ({ ...shape, radialData: [...shape.radialData] }));
            
            // For each angle, detect outliers across all participants
            for (let angle = 0; angle < numAngles; angle++) {
                const radiiAtAngle = participantShapes.map((shape, idx) => ({
                    value: shape.radialData[angle],
                    shapeIndex: idx
                }));
                
                const values = radiiAtAngle.map(r => r.value);
                const { valid, outliers } = filterOutliersMAD(values);
                
                // For outliers, replace with median value
                if (outliers.length > 0) {
                    const median = calculateMedian(valid.map(v => v.value));
                    
                    outliers.forEach(outlier => {
                        const shapeIdx = radiiAtAngle[outlier.index].shapeIndex;
                        filteredShapes[shapeIdx].radialData[angle] = median;
                        
                        if (!filteredShapes[shapeIdx].outlierCount) {
                            filteredShapes[shapeIdx].outlierCount = 0;
                        }
                        filteredShapes[shapeIdx].outlierCount++;
                    });
                }
            }
            
            // Remove shapes with too many outliers (>25% of angles)
            const validShapes = filteredShapes.filter(shape => {
                const outlierPercentage = ((shape.outlierCount || 0) / numAngles) * 100;
                return outlierPercentage < 25;
            });
            
            console.log(`[MAD Filter] Kept ${validShapes.length}/${participantShapes.length} shapes`);
            
            return validShapes;
        }
        
        // ============================================
        // SHAPE ANALYSIS WITH CONTOUR & VALIDATION
        // ============================================
        
        function pixelsToUnits(pixels) {
            return pixels / SCALE_FACTOR;
        }
        
        function unitsToPixels(units) {
            return units * SCALE_FACTOR;
        }
        
        function calculateCentroid(contour) {
            if (contour.length === 0) return { x: 0, y: 0 };
            
            let sumX = 0;
            let sumY = 0;
            
            contour.forEach(point => {
                sumX += point.x;
                sumY += point.y;
            });
            
            const centroidX = sumX / contour.length;
            const centroidY = sumY / contour.length;
            
            // Convert to units relative to center
            return {
                x: pixelsToUnits(centroidX - CENTER_X),
                y: pixelsToUnits(CENTER_Y - centroidY) // Flip Y axis
            };
        }
        
        function calculateAreaFromContour(contour) {
            if (contour.length < 3) return 0;
            
            // Use shoelace formula
            let area = 0;
            
            for (let i = 0; i < contour.length; i++) {
                const current = contour[i];
                const next = contour[(i + 1) % contour.length];
                area += current.x * next.y - next.x * current.y;
            }
            
            area = Math.abs(area) / 2;
            
            // Convert from pixelsÂ² to unitsÂ²
            const areaInUnits = area / (SCALE_FACTOR * SCALE_FACTOR);
            
            return areaInUnits;
        }
        
        function contourToRadialData(contour) {
            const numAngles = 360;
            const radialData = new Array(numAngles).fill(0);
            
            // For each angle, find the maximum radius
            contour.forEach(point => {
                const dx = point.x - CENTER_X;
                const dy = point.y - CENTER_Y;
                const angle = Math.atan2(dy, dx);
                const angleIndex = Math.round(((angle + Math.PI) / (2 * Math.PI)) * numAngles) % numAngles;
                const radius = pixelsToUnits(Math.sqrt(dx * dx + dy * dy));
                
                radialData[angleIndex] = Math.max(radialData[angleIndex], radius);
            });
            
            // Fill zero values with interpolation
            for (let i = 0; i < numAngles; i++) {
                if (radialData[i] === 0) {
                    // Find nearest non-zero values
                    let before = i - 1;
                    let after = i + 1;
                    
                    while (before >= 0 && radialData[before] === 0) before--;
                    while (after < numAngles && radialData[after] === 0) after++;
                    
                    if (before >= 0 && after < numAngles) {
                        radialData[i] = (radialData[before] + radialData[after]) / 2;
                    } else if (before >= 0) {
                        radialData[i] = radialData[before];
                    } else if (after < numAngles) {
                        radialData[i] = radialData[after];
                    }
                }
            }
            
            return radialData;
        }
        
        // ============================================
        // METRICS UPDATE FUNCTIONS
        // ============================================
        
        function updateProgress(percentage, message) {
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            const progressPercentage = document.getElementById('progress-percentage');
            
            progressBar.style.width = `${percentage}%`;
            progressText.textContent = message;
            progressPercentage.textContent = `${Math.round(percentage)}%`;
            
            if (percentage > 0 && percentage < 100) {
                document.getElementById('progress-container').classList.remove('hidden');
            }
        }
        
        function updateSpeedMetric() {
            const elapsed = (Date.now() - processingStats.startTime) / 1000;
            const speed = elapsed > 0 ? (processingStats.processedCount / elapsed) : 0;
            
            processingStats.speedHistory.push(speed);
            if (processingStats.speedHistory.length > 10) {
                processingStats.speedHistory.shift();
            }
            
            const avgSpeed = processingStats.speedHistory.reduce((a, b) => a + b, 0) / processingStats.speedHistory.length;
            processingStats.maxSpeed = Math.max(processingStats.maxSpeed, avgSpeed);
            
            document.getElementById('speed-metric').textContent = `${avgSpeed.toFixed(1)} img/s`;
            
            const speedProgress = processingStats.maxSpeed > 0 ? (avgSpeed / processingStats.maxSpeed) * 100 : 0;
            document.getElementById('speed-progress').style.width = `${speedProgress}%`;
        }
        
        function updateETAMetric() {
            const elapsed = (Date.now() - processingStats.startTime) / 1000;
            const remaining = processingStats.totalCount - processingStats.processedCount;
            
            if (elapsed > 0 && processingStats.processedCount > 0) {
                const speed = processingStats.processedCount / elapsed;
                const eta = speed > 0 ? remaining / speed : 0;
                
                if (eta < 60) {
                    document.getElementById('eta-metric').textContent = `${Math.round(eta)}s`;
                } else {
                    const minutes = Math.floor(eta / 60);
                    const seconds = Math.round(eta % 60);
                    document.getElementById('eta-metric').textContent = `${minutes}m ${seconds}s`;
                }
                
                const totalEstimated = processingStats.totalCount / speed;
                const etaProgress = totalEstimated > 0 ? (elapsed / totalEstimated) * 100 : 0;
                document.getElementById('eta-progress').style.width = `${Math.min(etaProgress, 100)}%`;
            } else {
                document.getElementById('eta-metric').textContent = '--';
                document.getElementById('eta-progress').style.width = '0%';
            }
        }
        
        function updateValidationMetric() {
            const validated = processingStats.validatedCount;
            const total = processingStats.totalCount;
            
            document.getElementById('validation-metric').textContent = `${validated}/${total}`;
            
            const progress = total > 0 ? (validated / total) * 100 : 0;
            document.getElementById('validation-progress').style.width = `${progress}%`;
        }
        
        function updateOutlierMetric() {
            const filtered = processingStats.outliersFiltered;
            
            document.getElementById('outlier-metric').textContent = filtered;
            
            // Progress bar shows relative filtering rate
            const maxOutliers = Math.max(processingStats.totalCount * 0.1, 10); // Assume max 10% outliers
            const progress = Math.min((filtered / maxOutliers) * 100, 100);
            document.getElementById('outlier-progress').style.width = `${progress}%`;
        }
        
        function updateAllMetrics() {
            updateSpeedMetric();
            updateETAMetric();
            updateValidationMetric();
            updateOutlierMetric();
        }
        
        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        
        function parseFilename(filename) {
            try {
                const cleanFilename = filename.replace(/[\uFEFF\u200B-\u200D\uFFFE]/g, '').trim();
                const parts = cleanFilename.split('_').map(p => p.trim());
                
                if (parts.length < 2) {
                    console.warn(`Invalid filename format: ${filename}`);
                    return null;
                }
                
                // Extract frequency
                let freqPart = null;
                let frequencyNum = null;
                
                freqPart = parts.find(p => /^\d+(?:\.\d+)?hz$/i.test(p));
                
                if (freqPart) {
                    const match = freqPart.match(/^(\d+(?:\.\d+)?)hz$/i);
                    if (match) {
                        frequencyNum = parseFloat(match[1]);
                    }
                }
                
                if (!frequencyNum || !freqPart) {
                    for (const part of parts) {
                        const match = part.match(/(\d+(?:\.\d+)?)hz/i);
                        if (match) {
                            frequencyNum = parseFloat(match[1]);
                            freqPart = part;
                            break;
                        }
                    }
                }
                
                if (!frequencyNum || !freqPart) {
                    console.warn(`Frequency not found in: ${filename}`);
                    return null;
                }
                
                const frequency = frequencyNum.toString() + 'Hz';
                
                const validFrequencies = ['31Hz', '62.5Hz', '125Hz', '250Hz', '500Hz', '1000Hz', '2000Hz', '4000Hz', '8000Hz', '12000Hz', '16000Hz'];
                if (!validFrequencies.includes(frequency)) {
                    console.warn(`Unknown frequency ${frequency} in: ${filename}`);
                    return null;
                }
                
                // Get participant name
                const freqIndex = parts.indexOf(freqPart);
                const participant = parts.slice(0, freqIndex).join(' ').trim() || 'Unknown';
                
                // Extract trial number (if present)
                let trialNumber = 1; // Default
                const trialMatch = cleanFilename.match(/trial[\s_-]?(\d+)/i) || cleanFilename.match(/_(\d+)\.png$/i);
                if (trialMatch) {
                    trialNumber = parseInt(trialMatch[1]);
                }
                
                return { participant, frequency, frequencyNumber: frequencyNum, trialNumber };
            } catch (err) {
                console.error(`Error parsing filename ${filename}:`, err);
                return null;
            }
        }
        
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'fixed top-4 right-4 bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-lg shadow-lg z-50 max-w-md';
            errorDiv.innerHTML = `
                <div class="flex items-start">
                    <svg class="w-6 h-6 mr-3 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"></path>
                    </svg>
                    <div>
                        <p class="font-bold">Error</p>
                        <p class="text-sm">${message}</p>
                    </div>
                </div>
            `;
            document.body.appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 5000);
        }
        
        // ============================================
        // WEB WORKER FOR IMAGE PROCESSING
        // ============================================
        
        const workerCode = `
self.onmessage = function(e) {
    try {
        const data = e.data;
        
        // Validate input
        if (!data) {
            self.postMessage({
                success: false,
                filename: 'unknown',
                error: 'No data received'
            });
            return;
        }
        
        const { imageData, filename } = data;
        
        if (!imageData || !imageData.data || !imageData.width || !imageData.height) {
            self.postMessage({
                success: false,
                filename: filename || 'unknown',
                error: 'Invalid image data structure'
            });
            return;
        }
        
        const width = imageData.width;
        const height = imageData.height;
        const pixelData = imageData.data;
        
        // Detect colors - simplified logic
        const redPixels = [];
        const bluePixels = [];
        
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const idx = (y * width + x) * 4;
                const r = pixelData[idx];
                const g = pixelData[idx + 1];
                const b = pixelData[idx + 2];
                const a = pixelData[idx + 3];
                
                // Skip transparent pixels
                if (a < 128) continue;
                
                // Red detection (strict thresholds)
                if (r > 240 && g < 20 && b < 20) {
                    redPixels.push({ x: x, y: y });
                }
                
                // Blue detection (strict thresholds)
                if (b > 240 && r < 20 && g < 20) {
                    bluePixels.push({ x: x, y: y });
                }
            }
        }
        
        // Send success response
        self.postMessage({
            success: true,
            filename: filename,
            redPixels: redPixels,
            bluePixels: bluePixels,
            hasRed: redPixels.length > 0,
            hasBlue: bluePixels.length > 0
        });
        
    } catch (error) {
        // Send error response
        self.postMessage({
            success: false,
            filename: e.data && e.data.filename ? e.data.filename : 'unknown',
            error: error.message || 'Unknown worker error'
        });
    }
};
`;
        
        const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
        const workerBlobUrl = URL.createObjectURL(workerBlob);
        
        // ============================================
        // FILE LOADING
        // ============================================
        
        async function loadImagesFromZip(file) {
            try {
                console.log(`[ZIP] Extracting from: ${file.name}`);
                
                // Extract ordering number from ZIP name (e.g., "Michael D_07_Drawings.zip" â†’ 7)
                const zipOrderMatch = file.name.match(/_(\d+)_/);
                const zipOrderNumber = zipOrderMatch ? parseInt(zipOrderMatch[1]) : null;
                
                // Extract participant name from ZIP name (before first underscore+number pattern)
                const nameWithoutExt = file.name.replace(/\.zip$/i, '');
                const zipParticipantMatch = nameWithoutExt.match(/^(.+?)_\d+/);
                const zipParticipant = zipParticipantMatch ? zipParticipantMatch[1].trim() : null;
                
                if (zipOrderNumber !== null && zipParticipant !== null) {
                    console.log(`[ZIP]   âœ“ Participant="${zipParticipant}", Order=${zipOrderNumber}`);
                } else {
                    console.warn(`[ZIP]   âš  Could not extract order/participant from: ${file.name}`);
                }
                
                const zip = await JSZip.loadAsync(file);
                const images = [];
                let pngCount = 0;
                let nestedZipCount = 0;
            
            for (const [path, zipEntry] of Object.entries(zip.files)) {
                if (zipEntry.dir) continue;
                
                if (path.toLowerCase().endsWith('.zip')) {
                    try {
                        nestedZipCount++;
                        const nestedZipBlob = await zipEntry.async('blob');
                        const nestedZipFile = new File([nestedZipBlob], path.split('/').pop());
                        
                        console.log(`[ZIP]   â†’ Processing nested ZIP: ${path.split('/').pop()}`);
                        const nestedImages = await loadImagesFromZip(nestedZipFile);
                        console.log(`[ZIP]   â†’ Got ${nestedImages.length} images from nested ZIP`);
                        
                        images.push(...nestedImages);
                        console.log(`[ZIP]   â†’ Total images so far: ${images.length}`);
                    } catch (err) {
                        console.error(`[ZIP] âœ– Error processing nested ZIP ${path}:`, err);
                    }
                    continue;
                }
                
                if (path.toLowerCase().endsWith('.png')) {
                    try {
                        pngCount++;
                        const blobData = await zipEntry.async('blob');
                        const pngBlob = new Blob([blobData], { type: 'image/png' });
                        const filename = path.split('/').pop();
                        
                        images.push({
                            name: filename,
                            blob: pngBlob,
                            fullPath: `${file.name}/${path}`,
                            sourceZip: file.name,
                            zipOrderNumber: zipOrderNumber,
                            zipParticipant: zipParticipant
                        });
                    } catch (err) {
                        console.error(`[ZIP] âœ– Error extracting PNG ${path}:`, err);
                    }
                }
            }
            
            // Log summary for this ZIP
            console.log(`[ZIP] === Summary for ${file.name} ===`);
            if (pngCount > 0) {
                console.log(`[ZIP]   â†’ Direct PNGs: ${pngCount}`);
            }
            if (nestedZipCount > 0) {
                console.log(`[ZIP]   â†’ Nested ZIPs processed: ${nestedZipCount}`);
            }
            console.log(`[ZIP]   â†’ Returning ${images.length} total images from this ZIP`);
            console.log(`[ZIP] =====================================`);
            
            if (pngCount === 0 && nestedZipCount === 0) {
                console.warn(`[ZIP]   âš  No PNG or ZIP files found in ${file.name}`);
            }
            
            return images;
            
            } catch (zipError) {
                console.error(`[ZIP] âœ–âœ–âœ– FATAL ERROR in ${file.name}:`, zipError);
                console.error(`[ZIP] Error type:`, zipError.name);
                console.error(`[ZIP] Error message:`, zipError.message);
                console.error(`[ZIP] Stack:`, zipError.stack);
                // Return empty array to allow processing to continue
                return [];
            }
        }
        
        async function loadImageToCanvas(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                let objectUrl = null;
                
                const loadTimeout = setTimeout(() => {
                    if (objectUrl) URL.revokeObjectURL(objectUrl);
                    reject(new Error(`Image load timeout: ${file.name}`));
                }, 10000);
                
                img.onload = function() {
                    clearTimeout(loadTimeout);
                    try {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        
                        const ctx = canvas.getContext('2d', { willReadFrequently: true });
                        if (!ctx) {
                            reject(new Error('Failed to get canvas context'));
                            return;
                        }
                        
                        ctx.drawImage(img, 0, 0);
                        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        resolve(imgData);
                    } catch (err) {
                        reject(err);
                    } finally {
                        if (objectUrl) URL.revokeObjectURL(objectUrl);
                    }
                };
                
                img.onerror = function() {
                    clearTimeout(loadTimeout);
                    if (objectUrl) URL.revokeObjectURL(objectUrl);
                    reject(new Error(`Failed to load image: ${file.name}`));
                };
                
                try {
                    if (!file.blob) {
                        reject(new Error(`No blob data for ${file.name}`));
                        return;
                    }
                    
                    objectUrl = URL.createObjectURL(file.blob);
                    img.crossOrigin = 'anonymous';
                    img.src = objectUrl;
                } catch (err) {
                    clearTimeout(loadTimeout);
                    if (objectUrl) URL.revokeObjectURL(objectUrl);
                    reject(new Error(`Failed to create object URL for ${file.name}: ${err.message}`));
                }
            });
        }
        
        // ============================================
        // MAIN PROCESSING PIPELINE
        // ============================================
        
        async function processImage(file) {
            const imageData = await loadImageToCanvas(file);
            
            const worker = new Worker(workerBlobUrl);
            activeWorkers.add(worker);
            
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    activeWorkers.delete(worker);
                    worker.terminate();
                    reject(new Error(`Worker timeout for ${file.name}`));
                }, 30000);
                
                worker.onmessage = function(e) {
                    clearTimeout(timeout);
                    activeWorkers.delete(worker);
                    worker.terminate();
                    
                    processingStats.processedCount++;
                    updateAllMetrics();
                    
                    if (e.data.success) {
                        resolve({
                            filename: file.name,
                            imageData,
                            sourceZip: file.sourceZip,
                            zipOrderNumber: file.zipOrderNumber,
                            zipParticipant: file.zipParticipant,
                            ...e.data
                        });
                    } else {
                        reject(new Error(e.data.error));
                    }
                };
                
                worker.onerror = function(error) {
                    clearTimeout(timeout);
                    activeWorkers.delete(worker);
                    worker.terminate();
                    reject(error);
                };
                
                worker.postMessage({ imageData, filename: file.name });
            });
        }
        
        async function processImagesParallel(files) {
            const results = [];
            const batchSize = MAX_PARALLEL_WORKERS * 3;
            
            for (let i = 0; i < files.length; i += batchSize) {
                if (processingCancelled) {
                    throw new Error('Processing cancelled by user');
                }
                
                const batch = files.slice(i, i + batchSize);
                
                const batchPromises = batch.map(async (file) => {
                    try {
                        const result = await processImage(file);
                        return result;
                    } catch (err) {
                        console.warn(`Skipping ${file.name}:`, err.message);
                        return null;
                    }
                });
                
                const batchResults = await Promise.all(batchPromises);
                
                batchResults.forEach(result => {
                    if (result !== null) {
                        results.push(result);
                    }
                });
                
                const progress = 10 + ((processingStats.processedCount / processingStats.totalCount) * 40);
                updateProgress(progress, `Processing images (${processingStats.processedCount}/${processingStats.totalCount})`);
                
                await new Promise(resolve => setTimeout(resolve, 50));
            }
            
            return results;
        }
        
        // ============================================
        // SHAPE AVERAGING WITH ADVANCED FEATURES
        // ============================================
        
        function calculateAverageShape(participantShapes) {
            if (participantShapes.length === 0) {
                return { radialData: [], meanRadius: 0, sdRadius: 0, meanArea: 0, sdArea: 0, nShapes: 0, outliersRemoved: 0 };
            }
            
            // Filter outliers using MAD
            const validShapes = filterRadialOutliers(participantShapes);
            const outliersRemoved = participantShapes.length - validShapes.length;
            
            const numAngles = 360;
            const avgRadii = new Array(numAngles).fill(0);
            
            // Calculate median radius at each angle (more robust than mean)
            for (let angle = 0; angle < numAngles; angle++) {
                const radiiAtAngle = validShapes.map(shape => shape.radialData[angle]);
                avgRadii[angle] = calculateMedian(radiiAtAngle);
            }
            
            // Light smoothing (window size 3) to preserve hand-drawn characteristics
            const smoothedRadii = [...avgRadii];
            for (let angle = 0; angle < numAngles; angle++) {
                const prev = avgRadii[(angle - 1 + numAngles) % numAngles];
                const curr = avgRadii[angle];
                const next = avgRadii[(angle + 1) % numAngles];
                smoothedRadii[angle] = (prev + curr + next) / 3;
            }
            
            // Calculate statistics
            const meanRadius = smoothedRadii.reduce((a, b) => a + b, 0) / numAngles;
            const radiusVariances = smoothedRadii.map(r => Math.pow(r - meanRadius, 2));
            const sdRadius = Math.sqrt(radiusVariances.reduce((a, b) => a + b, 0) / numAngles);
            
            // Calculate areas
            const areas = validShapes.map(shape => shape.area);
            const meanArea = calculateMedian(areas);
            const areaDeviations = areas.map(a => Math.abs(a - meanArea));
            const sdArea = calculateMedian(areaDeviations) * 1.4826; // MAD to SD conversion
            
            return {
                radialData: smoothedRadii,
                meanRadius,
                sdRadius,
                meanArea,
                sdArea,
                nShapes: validShapes.length,
                outliersRemoved
            };
        }
        
        // ============================================
        // DRAWING FUNCTIONS
        // ============================================
        
        function drawGrid(ctx, size) {
            const gridSize = size / (2 * GRID_RANGE); // pixels per unit
            const center = size / 2;
            
            ctx.strokeStyle = '#e5e5e5';
            ctx.lineWidth = 1;
            
            // Vertical lines
            for (let i = -GRID_RANGE; i <= GRID_RANGE; i++) {
                const x = center + i * gridSize;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, size);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let i = -GRID_RANGE; i <= GRID_RANGE; i++) {
                const y = center + i * gridSize;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(size, y);
                ctx.stroke();
            }
            
            // Axes (darker)
            ctx.strokeStyle = '#d0d0d0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(center, 0);
            ctx.lineTo(center, size);
            ctx.moveTo(0, center);
            ctx.lineTo(size, center);
            ctx.stroke();
        }
        
        function drawReferenceCircle(ctx, size) {
            const center = size / 2;
            const radius = unitsToPixels(REFERENCE_CIRCLE_RADIUS);
            
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(center, center, radius, 0, 2 * Math.PI);
            ctx.stroke();
        }
        
        function drawIndividualShapes(ctx, shapes, color = '#999999') {
            ctx.strokeStyle = color;
            ctx.fillStyle = 'transparent'; // UNFILLED
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.5;
            
            shapes.forEach(shape => {
                ctx.beginPath();
                shape.radialData.forEach((radius, angle) => {
                    const rad = (angle * Math.PI) / 180;
                    const x = CENTER_X + unitsToPixels(radius) * Math.cos(rad);
                    const y = CENTER_Y + unitsToPixels(radius) * Math.sin(rad);
                    
                    if (angle === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.closePath();
                ctx.stroke(); // ONLY stroke, never fill
            });
            
            ctx.globalAlpha = 1.0;
        }
        
        function drawAveragedShape(ctx, radialData, color, dashed = false) {
            ctx.strokeStyle = color;
            ctx.fillStyle = 'transparent'; // UNFILLED
            ctx.lineWidth = 3;
            
            if (dashed) {
                ctx.setLineDash([10, 5]);
            } else {
                ctx.setLineDash([]);
            }
            
            ctx.beginPath();
            radialData.forEach((radius, angle) => {
                const rad = (angle * Math.PI) / 180;
                const x = CENTER_X + unitsToPixels(radius) * Math.cos(rad);
                const y = CENTER_Y + unitsToPixels(radius) * Math.sin(rad);
                
                if (angle === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.closePath();
            ctx.stroke(); // ONLY stroke, never fill
            
            ctx.setLineDash([]);
        }
        
        function drawCompositeVisualization(canvas, frequency, redShapes, blueShapes, redAvg, blueAvg) {
            const ctx = canvas.getContext('2d');
            
            // Clear and white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            drawGrid(ctx, canvas.width);
            
            // Draw reference circle
            drawReferenceCircle(ctx, canvas.width);
            
            // Draw individual shapes in gray (background)
            drawIndividualShapes(ctx, redShapes, '#999999');
            drawIndividualShapes(ctx, blueShapes, '#999999');
            
            // Draw averaged shapes on top
            if (redAvg && redAvg.radialData.length > 0) {
                drawAveragedShape(ctx, redAvg.radialData, '#FF0000', false); // Solid red
            }
            
            if (blueAvg && blueAvg.radialData.length > 0) {
                drawAveragedShape(ctx, blueAvg.radialData, '#0000FF', true); // Dashed blue
            }
            
            // Add frequency label
            ctx.fillStyle = 'black';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(frequency, canvas.width / 2, 40);
            
            // Add N and outlier info
            const nRed = redShapes.length;
            const nBlue = blueShapes.length;
            const outliersRed = redAvg ? redAvg.outliersRemoved : 0;
            const outliersBlue = blueAvg ? blueAvg.outliersRemoved : 0;
            
            ctx.font = '16px Arial';
            ctx.fillText(`N(red)=${nRed}, outliers=${outliersRed}`, canvas.width / 2, canvas.height - 40);
            ctx.fillText(`N(blue)=${nBlue}, outliers=${outliersBlue}`, canvas.width / 2, canvas.height - 20);
        }
        
        // ============================================
        // MAIN ANALYSIS FUNCTION
        // ============================================
        
        async function analyzeData(inputFiles) {
            try {
                processingCancelled = false;
                processingStats.startTime = Date.now();
                processingStats.processedCount = 0;
                processingStats.speedHistory = [];
                processingStats.maxSpeed = 0;
                processingStats.validatedCount = 0;
                processingStats.outliersFiltered = 0;
                
                document.getElementById('analyze-btn').classList.add('hidden');
                document.getElementById('cancel-btn').classList.remove('hidden');
                document.getElementById('progress-container').classList.remove('hidden');
                
                updateProgress(0, 'Initializing...');
                
                document.getElementById('data-summary').classList.add('hidden');
                document.getElementById('visualization-container').classList.add('hidden');
                document.getElementById('statistics-container').classList.add('hidden');
                document.getElementById('validation-summary').classList.add('hidden');
                
                console.log('[Main] Starting analysis with', inputFiles.length, 'files');
                
                let allImages = [];
                
                updateProgress(5, 'Extracting files from ZIPs...');
                
                for (const file of inputFiles) {
                    if (processingCancelled) throw new Error('Processing cancelled');
                    
                    try {
                        if (file.name.toLowerCase().endsWith('.zip')) {
                            console.log(`[Main] Processing ZIP: ${file.name}`);
                            const images = await loadImagesFromZip(file);
                            console.log(`[Main] Got ${images.length} images from ${file.name}`);
                            allImages.push(...images);
                            console.log(`[Main] Total images so far: ${allImages.length}`);
                        } else if (file.name.toLowerCase().endsWith('.png')) {
                            allImages.push({
                                name: file.name,
                                blob: file,
                                fullPath: file.name,
                                sourceZip: null,
                                zipOrderNumber: null,
                                zipParticipant: null
                            });
                        }
                    } catch (extractError) {
                        console.error(`[Main] Error processing ${file.name}:`, extractError);
                        throw extractError;
                    }
                }
                
                console.log(`[Main] ========================================`);
                console.log(`[Main] Extraction complete!`);
                console.log(`[Main] Total images in allImages array: ${allImages.length}`);
                console.log(`[Main] ========================================`);
                
                if (allImages.length === 0) {
                    throw new Error('No valid PNG images found in any ZIP files');
                }
                
                console.log(`[Main] âœ“ Total PNGs extracted: ${allImages.length}`);
                console.log(`[Main] Sample file:`, allImages[0]);
                
                processingStats.totalCount = allImages.length;
                updateProgress(10, `Found ${allImages.length} images...`);
                
                const metricsInterval = setInterval(updateAllMetrics, 500);
                
                const processedData = await processImagesParallel(allImages);
                
                clearInterval(metricsInterval);
                
                console.log(`[Main] âœ“ Processed ${processedData.length} images with workers`);
                
                // Diagnostic: Check how many have colors detected
                const hasRedCount = processedData.filter(d => d.hasRed).length;
                const hasBlueCount = processedData.filter(d => d.hasBlue).length;
                const hasBothCount = processedData.filter(d => d.hasRed && d.hasBlue).length;
                const hasNeitherCount = processedData.filter(d => !d.hasRed && !d.hasBlue).length;
                console.log(`[Workers] Color detection results:`);
                console.log(`[Workers]   Files with RED detected: ${hasRedCount}`);
                console.log(`[Workers]   Files with BLUE detected: ${hasBlueCount}`);
                console.log(`[Workers]   Files with BOTH colors: ${hasBothCount}`);
                console.log(`[Workers]   Files with NO colors: ${hasNeitherCount}`);
                
                if (hasNeitherCount > 0) {
                    console.warn(`[Workers] âš  ${hasNeitherCount} files have no colors detected!`);
                    console.warn(`[Workers] This could mean:`);
                    console.warn(`[Workers]   - Color thresholds too strict (r>240, g<20, b<20)`);
                    console.warn(`[Workers]   - Images are grayscale or wrong format`);
                    console.warn(`[Workers]   - Images need different color detection`);
                }
                
                if (processedData.length === 0) {
                    throw new Error('No valid data extracted');
                }
                
                updateProgress(50, 'Extracting contours and analyzing shapes...');
                
                // Parse filenames and normalize trial numbers
                const parsedData = [];
                let parseFailures = 0;
                
                for (const data of processedData) {
                    const parsed = parseFilename(data.filename);
                    if (!parsed) {
                        parseFailures++;
                        console.warn(`[Parse] âš  Failed to parse filename: ${data.filename}`);
                        continue;
                    }
                    
                    // CRITICAL: Explicitly preserve color detection flags from workers
                    parsedData.push({
                        filename: data.filename,
                        imageData: data.imageData,
                        sourceZip: data.sourceZip,
                        zipOrderNumber: data.zipOrderNumber,
                        zipParticipant: data.zipParticipant,
                        hasRed: data.hasRed,           // â† Explicitly preserve
                        hasBlue: data.hasBlue,         // â† Explicitly preserve
                        redPixels: data.redPixels,     // â† Explicitly preserve
                        bluePixels: data.bluePixels,   // â† Explicitly preserve
                        participant: parsed.participant,
                        frequency: parsed.frequency,
                        frequencyNumber: parsed.frequencyNumber,
                        trialNumber: parsed.trialNumber
                    });
                }
                
                console.log(`[Parse] âœ“ Successfully parsed ${parsedData.length} filenames`);
                if (parseFailures > 0) {
                    console.warn(`[Parse] âš  Failed to parse ${parseFailures} filenames`);
                }
                
                // DIAGNOSTIC: Check if hasRed/hasBlue are preserved
                console.log(`[Parse] Checking color flags after merge...`);
                const sampleParsed = parsedData[0];
                console.log(`[Parse] Sample parsed data:`, {
                    filename: sampleParsed.filename,
                    participant: sampleParsed.participant,
                    frequency: sampleParsed.frequency,
                    hasRed: sampleParsed.hasRed,
                    hasBlue: sampleParsed.hasBlue,
                    normalizedTrial: sampleParsed.normalizedTrial
                });
                const hasRedInParsed = parsedData.filter(d => d.hasRed === true).length;
                const hasBlueInParsed = parsedData.filter(d => d.hasBlue === true).length;
                console.log(`[Parse] Files with hasRed=true: ${hasRedInParsed}`);
                console.log(`[Parse] Files with hasBlue=true: ${hasBlueInParsed}`);
                
                // Normalize trial numbers
                console.log('[Trial] Starting trial number normalization...');
                normalizeTrialNumbers(parsedData);
                console.log('[Trial] âœ“ Trial normalization complete');
                
                // Group by participant, frequency, and extract contours
                const participantShapes = {};
                
                FREQUENCIES.forEach(freq => {
                    participantShapes[freq] = { red: [], blue: [] };
                });
                
                console.log(`[Shapes] Starting contour extraction for ${parsedData.length} files...`);
                let skippedExtraTrials = 0;
                let processedFiles = 0;
                let redContoursFound = 0;
                let blueContoursFound = 0;
                let redContoursEmpty = 0;
                let blueContoursEmpty = 0;
                let filesWithHasRedTrue = 0;
                let filesWithHasBlueTrue = 0;
                
                for (const data of parsedData) {
                    if (processingCancelled) throw new Error('Processing cancelled');
                    
                    // Skip files marked as extra trials (>3)
                    if (data.normalizedTrial === null) {
                        skippedExtraTrials++;
                        continue;
                    }
                    
                    processedFiles++;
                    
                    // Count how many have hasRed/hasBlue flags
                    if (data.hasRed === true) filesWithHasRedTrue++;
                    if (data.hasBlue === true) filesWithHasBlueTrue++;
                    
                    // Extract red shape
                    if (data.hasRed) {
                        const redContour = extractCompleteShapeContour(data.imageData, '255,0,0');
                        if (redContour.length > 0) {
                            redContoursFound++;
                            const radialData = contourToRadialData(redContour);
                            const centroid = calculateCentroid(redContour);
                            const area = calculateAreaFromContour(redContour);
                            
                            // Validate against Google Sheets
                            const validation = validateShapeAgainstSheets(
                                data.participant,
                                data.frequencyNumber,
                                'red',
                                data.normalizedTrial || data.trialNumber,
                                centroid,
                                area
                            );
                            
                            participantShapes[data.frequency].red.push({
                                participant: data.participant,
                                trial: data.normalizedTrial || data.trialNumber,
                                radialData,
                                centroid,
                                area,
                                validation,
                                contour: redContour
                            });
                        } else {
                            redContoursEmpty++;
                        }
                    }
                    
                    // Extract blue shape
                    if (data.hasBlue) {
                        const blueContour = extractCompleteShapeContour(data.imageData, '0,0,255');
                        if (blueContour.length > 0) {
                            blueContoursFound++;
                            const radialData = contourToRadialData(blueContour);
                            const centroid = calculateCentroid(blueContour);
                            const area = calculateAreaFromContour(blueContour);
                            
                            const validation = validateShapeAgainstSheets(
                                data.participant,
                                data.frequencyNumber,
                                'blue',
                                data.normalizedTrial || data.trialNumber,
                                centroid,
                                area
                            );
                            
                            participantShapes[data.frequency].blue.push({
                                participant: data.participant,
                                trial: data.normalizedTrial || data.trialNumber,
                                radialData,
                                centroid,
                                area,
                                validation,
                                contour: blueContour
                            });
                        } else {
                            blueContoursEmpty++;
                        }
                    }
                }
                
                console.log(`[Shapes] Contour extraction diagnostics:`);
                console.log(`[Shapes]   Files with shapes to process: ${processedFiles}`);
                console.log(`[Shapes]   Skipped (extra trials): ${skippedExtraTrials}`);
                console.log(`[Shapes]   Files where hasRed === true: ${filesWithHasRedTrue}`);
                console.log(`[Shapes]   Files where hasBlue === true: ${filesWithHasBlueTrue}`);
                console.log(`[Shapes]   Red contours found: ${redContoursFound}`);
                console.log(`[Shapes]   Red contours empty: ${redContoursEmpty}`);
                console.log(`[Shapes]   Blue contours found: ${blueContoursFound}`);
                console.log(`[Shapes]   Blue contours empty: ${blueContoursEmpty}`);
                
                // Log shape extraction results
                console.log('[Shapes] Extraction complete. Summary by frequency:');
                let totalShapesExtracted = 0;
                FREQUENCIES.forEach(freq => {
                    const redCount = participantShapes[freq].red.length;
                    const blueCount = participantShapes[freq].blue.length;
                    totalShapesExtracted += redCount + blueCount;
                    console.log(`[Shapes]   ${freq}: ${redCount} red, ${blueCount} blue`);
                });
                console.log(`[Shapes] âœ“ Total shapes extracted: ${totalShapesExtracted}`);
                
                if (totalShapesExtracted === 0) {
                    console.error('[Shapes] âœ–âœ–âœ– NO SHAPES EXTRACTED! This is a problem.');
                    console.error('[Shapes] Possible causes:');
                    console.error('[Shapes]   1. Contour extraction failing');
                    console.error('[Shapes]   2. Color detection thresholds too strict');
                    console.error('[Shapes]   3. Images not in expected format');
                    throw new Error('No shapes were extracted from any images. Check console for details.');
                }
                
                updateProgress(70, 'Calculating averaged shapes...');
                
                // Calculate averages
                const canvasGrid = document.getElementById('canvas-grid');
                canvasGrid.innerHTML = '';
                
                const statsBody = document.getElementById('statistics-body');
                statsBody.innerHTML = '';
                
                FREQUENCIES.forEach(freq => {
                    if (processingCancelled) return;
                    
                    const redShapes = participantShapes[freq].red;
                    const blueShapes = participantShapes[freq].blue;
                    
                    if (redShapes.length === 0 && blueShapes.length === 0) return;
                    
                    const redAvg = calculateAverageShape(redShapes);
                    const blueAvg = calculateAverageShape(blueShapes);
                    
                    // Create visualization
                    const container = document.createElement('div');
                    container.className = 'canvas-container p-4 cursor-pointer hover:shadow-xl transition-shadow';
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = 1000;
                    canvas.height = 1000;
                    canvas.className = 'w-full border border-gray-200 rounded';
                    
                    drawCompositeVisualization(canvas, freq, redShapes, blueShapes, redAvg, blueAvg);
                    
                    container.appendChild(canvas);
                    
                    canvas.addEventListener('click', () => {
                        const link = document.createElement('a');
                        link.download = `sound_object_composite_${freq}.png`;
                        link.href = canvas.toDataURL('image/png');
                        link.click();
                    });
                    
                    canvasGrid.appendChild(container);
                    
                    // Add to statistics table
                    if (redShapes.length > 0) {
                        const validationStatus = getValidationStatus(redShapes);
                        const row = createStatRow(freq, 'Red', redAvg, validationStatus);
                        statsBody.appendChild(row);
                    }
                    
                    if (blueShapes.length > 0) {
                        const validationStatus = getValidationStatus(blueShapes);
                        const row = createStatRow(freq, 'Blue', blueAvg, validationStatus);
                        statsBody.appendChild(row);
                    }
                });
                
                updateProgress(90, 'Finalizing...');
                
                // Show results
                const processingTime = ((Date.now() - processingStats.startTime) / 1000).toFixed(1);
                
                document.getElementById('data-summary').classList.remove('hidden');
                document.getElementById('visualization-container').classList.remove('hidden');
                document.getElementById('statistics-container').classList.remove('hidden');
                
                if (sheetsValidationEnabled) {
                    document.getElementById('validation-summary').classList.remove('hidden');
                    showValidationSummary();
                }
                
                updateProgress(100, `Complete! Processed ${processingStats.processedCount} images in ${processingTime}s`);
                
                setTimeout(() => {
                    document.getElementById('progress-container').classList.add('hidden');
                }, 3000);
                
            } catch (err) {
                console.error('!!! ANALYSIS ERROR !!!');
                console.error('Error type:', err.name);
                console.error('Error message:', err.message);
                console.error('Error stack:', err.stack);
                console.error('!!!!!!!!!!!!!!!!!!!!!');
                
                if (err.message === 'Processing cancelled') {
                    updateProgress(0, 'âŒ Processing cancelled');
                } else {
                    showError(err.message);
                    console.error('Analysis error:', err);
                }
            } finally {
                activeWorkers.forEach(worker => worker.terminate());
                activeWorkers.clear();
                
                document.getElementById('cancel-btn').classList.add('hidden');
                document.getElementById('analyze-btn').classList.remove('hidden');
                
                const files = document.getElementById('image-upload').files;
                if (files && files.length > 0) {
                    document.getElementById('analyze-btn').disabled = false;
                }
            }
        }
        
        function getValidationStatus(shapes) {
            const validated = shapes.filter(s => s.validation && s.validation.valid).length;
            const total = shapes.length;
            const percentage = total > 0 ? (validated / total) * 100 : 0;
            
            return { validated, total, percentage };
        }
        
        function createStatRow(freq, color, avgData, validationStatus) {
            const row = document.createElement('tr');
            row.className = 'hover:bg-gray-50';
            
            const colorDot = color === 'Red' ? 'bg-red-500' : 'bg-blue-500';
            const validationBadge = getValidationBadge(validationStatus);
            
            row.innerHTML = `
                <td class="px-4 py-3 text-sm font-semibold text-gray-800">${freq}</td>
                <td class="px-4 py-3"><span class="inline-block w-4 h-4 rounded-full ${colorDot}"></span> ${color}</td>
                <td class="px-4 py-3 text-sm font-semibold">${avgData.nShapes}</td>
                <td class="px-4 py-3 text-sm font-mono text-amber-600">${avgData.outliersRemoved}</td>
                <td class="px-4 py-3 text-sm font-mono">${avgData.meanRadius.toFixed(3)}</td>
                <td class="px-4 py-3 text-sm font-mono">${avgData.sdRadius.toFixed(3)}</td>
                <td class="px-4 py-3 text-sm font-mono">${avgData.meanArea.toFixed(3)}</td>
                <td class="px-4 py-3">${validationBadge}</td>
            `;
            
            return row;
        }
        
        function getValidationBadge(validationStatus) {
            if (!sheetsValidationEnabled) {
                return '<span class="validation-badge bg-gray-100 text-gray-600">N/A</span>';
            }
            
            const { validated, total, percentage } = validationStatus;
            
            if (percentage >= 90) {
                return `<span class="validation-badge validation-pass">âœ“ ${validated}/${total}</span>`;
            } else if (percentage >= 70) {
                return `<span class="validation-badge validation-warn">âš  ${validated}/${total}</span>`;
            } else {
                return `<span class="validation-badge validation-fail">âœ— ${validated}/${total}</span>`;
            }
        }
        
        function showValidationSummary() {
            const content = document.getElementById('validation-content');
            content.innerHTML = `
                <div class="bg-green-50 p-4 rounded-lg border-2 border-green-200">
                    <div class="text-3xl font-bold text-green-700">${processingStats.validatedCount}</div>
                    <div class="text-sm text-gray-600 font-semibold">Shapes Validated</div>
                </div>
                <div class="bg-amber-50 p-4 rounded-lg border-2 border-amber-200">
                    <div class="text-3xl font-bold text-amber-700">${processingStats.outliersFiltered}</div>
                    <div class="text-sm text-gray-600 font-semibold">Outliers Filtered (MAD)</div>
                </div>
                <div class="bg-blue-50 p-4 rounded-lg border-2 border-blue-200">
                    <div class="text-3xl font-bold text-blue-700">${sheetsValidationEnabled ? 'Enabled' : 'Disabled'}</div>
                    <div class="text-sm text-gray-600 font-semibold">Google Sheets Validation</div>
                </div>
            `;
        }
        
        // ============================================
        // EVENT LISTENERS
        // ============================================
        
        document.getElementById('image-upload').addEventListener('change', function(e) {
            const files = Array.from(e.target.files);
            const fileList = document.getElementById('file-list');
            const analyzeBtn = document.getElementById('analyze-btn');
            
            if (files.length > 0) {
                const pngCount = files.filter(f => f.name.toLowerCase().endsWith('.png')).length;
                const zipCount = files.filter(f => f.name.toLowerCase().endsWith('.zip')).length;
                
                fileList.innerHTML = `
                    <div class="p-4 bg-blue-50 rounded-lg border-2 border-blue-200">
                        <p class="font-semibold text-blue-800">
                            âœ… ${files.length} file(s) selected
                            ${pngCount > 0 ? `(${pngCount} PNG${pngCount > 1 ? 's' : ''})` : ''}
                            ${zipCount > 0 ? `(${zipCount} ZIP${zipCount > 1 ? 's' : ''})` : ''}
                        </p>
                        <p class="text-sm text-blue-600 mt-1">Click "Analyze & Generate Visualizations" to process!</p>
                    </div>
                `;
                
                analyzeBtn.disabled = false;
            } else {
                fileList.innerHTML = '';
                analyzeBtn.disabled = true;
            }
        });
        
        document.getElementById('analyze-btn').addEventListener('click', async function() {
            const files = Array.from(document.getElementById('image-upload').files);
            
            if (files.length === 0) {
                showError('Please select at least one file');
                return;
            }
            
            await analyzeData(files);
        });
        
        document.getElementById('cancel-btn').addEventListener('click', function() {
            processingCancelled = true;
            activeWorkers.forEach(worker => worker.terminate());
            activeWorkers.clear();
            this.disabled = true;
            this.innerHTML = 'â³ Cancelling...';
        });
        
        document.getElementById('validate-sheets-btn').addEventListener('click', async function() {
            await connectToGoogleSheets();
        });
        
        document.getElementById('test-sheets-btn').addEventListener('click', async function() {
            const sheetsUrl = document.getElementById('sheets-url').value.trim();
            const apiKey = document.getElementById('api-key').value.trim();
            
            if (!sheetsUrl || !apiKey) {
                showSheetsStatus('error', 'Please enter both URL and API key');
                return;
            }
            
            showSheetsStatus('loading', 'Testing connection...');
            
            const success = await connectToGoogleSheets();
            
            if (success) {
                showSheetsStatus('success', `âœ“ Test successful! Found ${googleSheetsData.length} records`);
                console.log('[Test] Sample records:', googleSheetsData.slice(0, 3));
            }
        });
        
        document.getElementById('toggle-metrics').addEventListener('click', function() {
            const dropdown = document.getElementById('metrics-dropdown');
            const arrow = document.getElementById('metrics-arrow');
            
            if (dropdown.classList.contains('open')) {
                dropdown.classList.remove('open');
                arrow.style.transform = 'rotate(0deg)';
            } else {
                dropdown.classList.add('open');
                arrow.style.transform = 'rotate(180deg)';
            }
        });
        
        window.addEventListener('beforeunload', () => {
            activeWorkers.forEach(worker => worker.terminate());
            URL.revokeObjectURL(workerBlobUrl);
        });
        
        // Generate timestamp automatically
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const timestamp = `${year}-${month}-${day} ${hours}:${minutes} PST`;
        
        console.log('%cðŸŽµ Sound Object Analyzer v5.0 Complete', 'color: #8B5CF6; font-size: 16px; font-weight: bold');
        console.log(`%cðŸ“… Last Updated: ${timestamp}`, 'color: #6B7280; font-size: 12px; font-style: italic');
        console.log(`%câš ï¸ CRITICAL FIX: Color flags explicitly preserved`, 'color: #F59E0B; font-size: 11px; font-weight: bold');
        console.log(`%câœ“ ${CPU_CORES} cores, ${MAX_PARALLEL_WORKERS} workers`, 'color: #10B981');
        console.log('%câœ“ Advanced contour detection', 'color: #10B981');
        console.log('%câœ“ MAD outlier filtering', 'color: #10B981');
        console.log('%câœ“ Google Sheets validation ready', 'color: #10B981');
        console.log('%câœ“ Trial number normalization', 'color: #10B981');
    </script>
</body>
</html>
