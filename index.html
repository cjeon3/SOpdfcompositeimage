<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sound Object Analyzer v9.6 - Early Marker Removal</title>
    <meta name="version" content="9.6.0">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            font-family: ui-sans-serif, system-ui, sans-serif;
            background-color: #f3f4f6;
        }
        
        .canvas-container {
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }
        
        .canvas-container:hover {
            transform: scale(1.02);
            transition: transform 0.2s;
        }
        
        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5rem;
        }
    </style>
</head>
<body>
    <div class="max-w-7xl mx-auto p-6">
        <!-- Header -->
        <div class="bg-gradient-to-r from-blue-600 to-purple-700 text-white p-6 rounded-xl shadow-xl mb-6">
            <h1 class="text-4xl font-bold mb-2">Sound Object Analyzer v9.6</h1>
            <p class="text-blue-100 text-lg">Early Centroid Marker Removal - Clean Processing Pipeline</p>
            <div class="mt-4 flex flex-wrap gap-2">
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">‚úì Removes + First</span>
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">‚úì Then Traces Boundaries</span>
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">‚úì Clean Shapes</span>
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">‚úì Accurate Processing</span>
            </div>
        </div>
        
        <!-- Instructions -->
        <div class="bg-blue-50 p-6 rounded-xl mb-6 border-2 border-blue-200">
            <h2 class="text-xl font-bold text-blue-900 mb-3">Smart Processing Order in v9.6</h2>
            <ul class="space-y-2 text-gray-700">
                <li><strong>1Ô∏è‚É£ First:</strong> Detect and remove perfect vertical/horizontal + markers</li>
                <li><strong>2Ô∏è‚É£ Then:</strong> Process cleaned pixels for boundary extraction</li>
                <li><strong>3Ô∏è‚É£ Finally:</strong> Apply gap filling and smoothing to clean shapes</li>
                <li><strong>‚ú® Result:</strong> No contamination from centroid markers in final shapes</li>
            </ul>
        </div>
        
        <!-- File Upload -->
        <div class="bg-white p-6 rounded-xl shadow-lg mb-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Upload Participant Images</h2>
            <input 
                type="file" 
                id="image-upload" 
                accept="image/png,.zip,application/zip" 
                multiple
                class="block w-full text-sm text-gray-700 mb-4
                    file:mr-4 file:py-3 file:px-6
                    file:rounded-xl file:border-0
                    file:text-sm file:font-bold
                    file:bg-gradient-to-r file:from-blue-500 file:to-blue-600
                    file:text-white
                    hover:file:from-blue-600 hover:file:to-blue-700
                    cursor-pointer"
            />
            
            <div id="file-status" class="text-sm text-gray-600 mb-4"></div>
            
            <button 
                id="analyze-btn" 
                class="bg-gradient-to-r from-green-500 to-emerald-600 text-white font-bold py-3 px-6 rounded-xl hover:from-green-600 hover:to-emerald-700 transition-all shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
                disabled>
                üî¨ Analyze & Generate Visualizations
            </button>
        </div>
        
        <!-- Progress -->
        <div id="progress-container" class="hidden bg-white p-6 rounded-xl shadow-lg mb-6">
            <div class="flex justify-between text-sm text-gray-600 mb-2">
                <span id="progress-text">Processing...</span>
                <span id="progress-percentage">0%</span>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-3 overflow-hidden">
                <div id="progress-bar" class="bg-gradient-to-r from-blue-500 to-green-500 h-full rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
        </div>
        
        <!-- Results -->
        <div id="visualization-container" class="hidden">
            <div class="bg-white p-6 rounded-xl shadow-lg mb-6">
                <h2 class="text-2xl font-bold text-gray-800 mb-4">üìä Composite Visualizations</h2>
                <p class="text-gray-600 mb-4">Click any image to download as PNG</p>
                <div id="visualizations" class="analysis-grid"></div>
            </div>
            
            <div class="bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-bold text-gray-800 mb-4">üìà Summary Statistics</h2>
                <div id="summary" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>
            </div>
        </div>
    </div>
    
    <script>
        // ============================================
        // CONFIGURATION & CONSTANTS
        // ============================================
        const CANVAS_SIZE = 1000;
        const SCALE = 50;
        const GRID_RANGE = 10;
        const CENTER_X = 500;
        const CENTER_Y = 500;
        const HEAD_RADIUS = 3;
        
        let allProcessedData = new Map();
        
        // ============================================
        // FILE HANDLING - NESTED ZIP EXTRACTION
        // ============================================
        
        document.getElementById('image-upload').addEventListener('change', (event) => {
            const files = Array.from(event.target.files);
            const fileStatus = document.getElementById('file-status');
            const analyzeBtn = document.getElementById('analyze-btn');
            
            const zipCount = files.filter(f => f.name.toLowerCase().endsWith('.zip')).length;
            const pngCount = files.filter(f => f.name.toLowerCase().endsWith('.png')).length;
            
            let statusText = `Selected: ${pngCount} PNG files, ${zipCount} ZIP archives`;
            if (zipCount > 0) {
                statusText += ' (will search for nested ZIPs and PNGs)';
            }
            
            fileStatus.textContent = statusText;
            analyzeBtn.disabled = files.length === 0;
        });
        
        document.getElementById('analyze-btn').addEventListener('click', analyzeImages);
        
        async function analyzeImages() {
            const fileInput = document.getElementById('image-upload');
            const files = Array.from(fileInput.files);
            
            if (files.length === 0) {
                alert('Please select images to analyze');
                return;
            }
            
            // Reset and show progress
            allProcessedData.clear();
            document.getElementById('progress-container').classList.remove('hidden');
            updateProgress('Extracting files from archives...', 0);
            
            try {
                // Extract all PNG files (including from nested ZIPs)
                const pngFiles = await extractAllPNGs(files);
                
                if (pngFiles.length === 0) {
                    alert('No PNG files found. Please ensure your ZIP files contain PNG images.');
                    document.getElementById('progress-container').classList.add('hidden');
                    return;
                }
                
                updateProgress(`Found ${pngFiles.length} PNG files. Starting analysis...`, 5);
                
                // Process images
                await processImages(pngFiles);
                
                // Generate visualizations
                updateProgress('Generating visualizations...', 90);
                generateVisualizations();
                
                // Show results
                updateProgress('Complete!', 100);
                document.getElementById('visualization-container').classList.remove('hidden');
                
                // Hide progress after delay
                setTimeout(() => {
                    document.getElementById('progress-container').classList.add('hidden');
                }, 2000);
                
            } catch (error) {
                console.error('Analysis error:', error);
                alert(`An error occurred: ${error.message}`);
                document.getElementById('progress-container').classList.add('hidden');
            }
        }
        
        async function extractAllPNGs(files) {
            const pngFiles = [];
            const processedZips = new Set();
            
            async function extractFromZip(zipFile, zipName = '') {
                const zipId = zipName + ':' + zipFile.name;
                if (processedZips.has(zipId)) return;
                processedZips.add(zipId);
                
                try {
                    const zip = new JSZip();
                    const zipContent = await zip.loadAsync(zipFile);
                    
                    console.log(`Extracting from ${zipName || zipFile.name}, found ${Object.keys(zipContent.files).length} entries`);
                    
                    for (const [filename, fileData] of Object.entries(zipContent.files)) {
                        if (fileData.dir) continue;
                        
                        const lowerName = filename.toLowerCase();
                        
                        if (lowerName.endsWith('.png')) {
                            const blob = await fileData.async('blob');
                            const fullPath = zipName ? `${zipName}/${filename}` : filename;
                            pngFiles.push(new File([blob], fullPath, { type: 'image/png' }));
                            console.log(`  Found PNG: ${fullPath}`);
                        } else if (lowerName.endsWith('.zip')) {
                            console.log(`  Found nested ZIP: ${filename}`);
                            const nestedBlob = await fileData.async('blob');
                            const nestedFile = new File([nestedBlob], filename, { type: 'application/zip' });
                            const nestedPath = zipName ? `${zipName}/${filename}` : filename;
                            await extractFromZip(nestedFile, nestedPath);
                        }
                    }
                } catch (error) {
                    console.error(`Error extracting ZIP ${zipName || zipFile.name}:`, error);
                }
            }
            
            for (const file of files) {
                const lowerName = file.name.toLowerCase();
                
                if (lowerName.endsWith('.png')) {
                    pngFiles.push(file);
                    console.log(`Found direct PNG: ${file.name}`);
                } else if (lowerName.endsWith('.zip')) {
                    console.log(`Processing ZIP: ${file.name}`);
                    await extractFromZip(file);
                }
            }
            
            console.log(`Total PNGs found: ${pngFiles.length}`);
            return pngFiles;
        }
        
        // ============================================
        // IMAGE PROCESSING WITH EARLY MARKER REMOVAL
        // ============================================
        
        async function processImages(pngFiles) {
            allProcessedData.clear();
            
            let processed = 0;
            const total = pngFiles.length;
            
            for (const file of pngFiles) {
                updateProgress(`Processing ${file.name}...`, 5 + (processed / total) * 85);
                
                try {
                    const shapes = await extractShapesFromImage(file);
                    
                    // Parse frequency from filename
                    let frequency = null;
                    const match = file.name.match(/(\d+\.?\d*)\s*hz/i);
                    if (match) {
                        frequency = parseFloat(match[1]);
                    } else {
                        // Try to find any number in filename
                        const numMatch = file.name.match(/\d+\.?\d*/);
                        if (numMatch) {
                            const num = parseFloat(numMatch[0]);
                            if (num >= 31 && num <= 16000) {
                                frequency = num;
                            }
                        }
                    }
                    
                    if (frequency && shapes) {
                        if (!allProcessedData.has(frequency)) {
                            allProcessedData.set(frequency, {
                                redShapes: [],
                                blueShapes: []
                            });
                        }
                        
                        const data = allProcessedData.get(frequency);
                        shapes.forEach(shape => {
                            if (shape.phase === 'red') {
                                data.redShapes.push(shape);
                            } else if (shape.phase === 'blue') {
                                data.blueShapes.push(shape);
                            }
                        });
                    }
                } catch (error) {
                    console.warn(`Failed to process ${file.name}:`, error);
                }
                
                processed++;
            }
        }
        
        async function extractShapesFromImage(file) {
            return new Promise((resolve) => {
                const img = new Image();
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    img.onload = () => {
                        const shapes = processImageData(img);
                        resolve(shapes);
                    };
                    img.src = e.target.result;
                };
                
                reader.readAsDataURL(file);
            });
        }
        
        function processImageData(img) {
            const canvas = document.createElement('canvas');
            canvas.width = CANVAS_SIZE;
            canvas.height = CANVAS_SIZE;
            const ctx = canvas.getContext('2d');
            
            ctx.drawImage(img, 0, 0, CANVAS_SIZE, CANVAS_SIZE);
            const imageData = ctx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            const data = imageData.data;
            
            // Extract colored pixels
            const redPixels = [];
            const bluePixels = [];
            
            for (let y = 0; y < CANVAS_SIZE; y++) {
                for (let x = 0; x < CANVAS_SIZE; x++) {
                    const idx = (y * CANVAS_SIZE + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    const a = data[idx + 3];
                    
                    if (a < 128) continue; // Skip transparent
                    
                    // Enhanced color detection
                    const redDominance = r - Math.max(g, b);
                    const blueDominance = b - Math.max(r, g);
                    
                    if (redDominance > 30) {
                        redPixels.push({ x, y });
                    } else if (blueDominance > 30) {
                        bluePixels.push({ x, y });
                    }
                }
            }
            
            const shapes = [];
            
            // Process red shape - REMOVE MARKERS FIRST
            if (redPixels.length > 100) {
                const cleanedRed = removeCentroidMarkers(redPixels);
                if (cleanedRed.length > 100) {
                    const centroid = calculateCentroid(cleanedRed);
                    const hull = convexHull(cleanedRed);
                    const radialContour = extractRadialContour(cleanedRed, centroid);
                    
                    shapes.push({
                        phase: 'red',
                        contour: radialContour,  // For averaging
                        hull: hull,               // For display
                        centroid: centroid,
                        area: calculateHullArea(hull),
                        pixelCount: cleanedRed.length
                    });
                }
            }
            
            // Process blue shape - REMOVE MARKERS FIRST
            if (bluePixels.length > 100) {
                const cleanedBlue = removeCentroidMarkers(bluePixels);
                if (cleanedBlue.length > 100) {
                    const centroid = calculateCentroid(cleanedBlue);
                    const hull = convexHull(cleanedBlue);
                    const radialContour = extractRadialContour(cleanedBlue, centroid);
                    
                    shapes.push({
                        phase: 'blue',
                        contour: radialContour,  // For averaging
                        hull: hull,               // For display
                        centroid: centroid,
                        area: calculateHullArea(hull),
                        pixelCount: cleanedBlue.length
                    });
                }
            }
            
            return shapes;
        }
        
        // ============================================
        // IMPROVED CENTROID MARKER REMOVAL
        // ============================================
        
        function removeCentroidMarkers(pixels) {
            if (pixels.length === 0) return pixels;
            
            // First, detect perfectly vertical and horizontal lines
            const verticalLines = detectVerticalLines(pixels);
            const horizontalLines = detectHorizontalLines(pixels);
            
            // Find where they cross to locate centroid markers
            const crossPoints = findCrossingPoints(verticalLines, horizontalLines);
            
            // Remove pixels that are part of centroid markers
            // Centroid markers are typically 10-20 pixels in each direction
            const markerHalfLength = 10; // Adjust based on actual marker size
            const markerThickness = 2; // Line thickness
            
            const markerPixels = new Set();
            
            crossPoints.forEach(cross => {
                // Mark vertical line pixels for removal
                for (let y = cross.y - markerHalfLength; y <= cross.y + markerHalfLength; y++) {
                    for (let x = cross.x - markerThickness; x <= cross.x + markerThickness; x++) {
                        markerPixels.add(`${x},${y}`);
                    }
                }
                
                // Mark horizontal line pixels for removal
                for (let x = cross.x - markerHalfLength; x <= cross.x + markerHalfLength; x++) {
                    for (let y = cross.y - markerThickness; y <= cross.y + markerThickness; y++) {
                        markerPixels.add(`${x},${y}`);
                    }
                }
            });
            
            // Return pixels without the marker pixels
            return pixels.filter(p => !markerPixels.has(`${p.x},${p.y}`));
        }
        
        function detectVerticalLines(pixels) {
            // Group pixels by X coordinate
            const xGroups = new Map();
            pixels.forEach(p => {
                if (!xGroups.has(p.x)) {
                    xGroups.set(p.x, []);
                }
                xGroups.get(p.x).push(p.y);
            });
            
            // Find X coordinates with many vertically aligned pixels
            const verticalLines = [];
            xGroups.forEach((yValues, x) => {
                yValues.sort((a, b) => a - b);
                
                // Check for continuous vertical segments
                let segments = [];
                let currentSegment = [yValues[0]];
                
                for (let i = 1; i < yValues.length; i++) {
                    if (yValues[i] - yValues[i-1] <= 2) { // Allow small gaps
                        currentSegment.push(yValues[i]);
                    } else {
                        if (currentSegment.length > 10) { // Minimum length for a line
                            segments.push({
                                x: x,
                                yMin: Math.min(...currentSegment),
                                yMax: Math.max(...currentSegment),
                                length: currentSegment.length
                            });
                        }
                        currentSegment = [yValues[i]];
                    }
                }
                
                if (currentSegment.length > 10) {
                    segments.push({
                        x: x,
                        yMin: Math.min(...currentSegment),
                        yMax: Math.max(...currentSegment),
                        length: currentSegment.length
                    });
                }
                
                verticalLines.push(...segments);
            });
            
            return verticalLines;
        }
        
        function detectHorizontalLines(pixels) {
            // Group pixels by Y coordinate
            const yGroups = new Map();
            pixels.forEach(p => {
                if (!yGroups.has(p.y)) {
                    yGroups.set(p.y, []);
                }
                yGroups.get(p.y).push(p.x);
            });
            
            // Find Y coordinates with many horizontally aligned pixels
            const horizontalLines = [];
            yGroups.forEach((xValues, y) => {
                xValues.sort((a, b) => a - b);
                
                // Check for continuous horizontal segments
                let segments = [];
                let currentSegment = [xValues[0]];
                
                for (let i = 1; i < xValues.length; i++) {
                    if (xValues[i] - xValues[i-1] <= 2) { // Allow small gaps
                        currentSegment.push(xValues[i]);
                    } else {
                        if (currentSegment.length > 10) { // Minimum length for a line
                            segments.push({
                                y: y,
                                xMin: Math.min(...currentSegment),
                                xMax: Math.max(...currentSegment),
                                length: currentSegment.length
                            });
                        }
                        currentSegment = [xValues[i]];
                    }
                }
                
                if (currentSegment.length > 10) {
                    segments.push({
                        y: y,
                        xMin: Math.min(...currentSegment),
                        xMax: Math.max(...currentSegment),
                        length: currentSegment.length
                    });
                }
                
                horizontalLines.push(...segments);
            });
            
            return horizontalLines;
        }
        
        function findCrossingPoints(verticalLines, horizontalLines) {
            const crossings = [];
            
            verticalLines.forEach(vLine => {
                horizontalLines.forEach(hLine => {
                    // Check if lines actually cross
                    if (vLine.x >= hLine.xMin && vLine.x <= hLine.xMax &&
                        hLine.y >= vLine.yMin && hLine.y <= vLine.yMax) {
                        
                        // Check if both lines are of similar length (typical for centroid markers)
                        const vLength = vLine.yMax - vLine.yMin;
                        const hLength = hLine.xMax - hLine.xMin;
                        
                        if (Math.abs(vLength - hLength) < 10) { // Similar length
                            crossings.push({
                                x: vLine.x,
                                y: hLine.y,
                                vLength: vLength,
                                hLength: hLength
                            });
                        }
                    }
                });
            });
            
            return crossings;
        }
        
        // ============================================
        // CONVEX HULL FOR CLEAN SHAPES
        // ============================================
        
        function convexHull(points) {
            if (points.length < 3) return points;
            
            // Sort points lexicographically
            points = points.slice().sort((a, b) => a.x === b.x ? a.y - b.y : a.x - b.x);
            
            // Cross product of vectors OA and OB
            function cross(O, A, B) {
                return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);
            }
            
            // Build lower hull
            const lower = [];
            for (let i = 0; i < points.length; i++) {
                while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {
                    lower.pop();
                }
                lower.push(points[i]);
            }
            
            // Build upper hull
            const upper = [];
            for (let i = points.length - 1; i >= 0; i--) {
                while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {
                    upper.pop();
                }
                upper.push(points[i]);
            }
            
            // Remove last point of each half because it's repeated
            lower.pop();
            upper.pop();
            
            // Concatenate lower and upper hull
            return lower.concat(upper);
        }
        
        function calculateHullArea(hull) {
            if (hull.length < 3) return 0;
            
            // Shoelace formula
            let area = 0;
            for (let i = 0; i < hull.length; i++) {
                const j = (i + 1) % hull.length;
                area += hull[i].x * hull[j].y;
                area -= hull[j].x * hull[i].y;
            }
            
            return Math.abs(area / 2) / (SCALE * SCALE);
        }
        
        // ============================================
        // RADIAL CONTOUR FOR AVERAGING
        // ============================================
        
        function extractRadialContour(pixels, centroid) {
            const numAngles = 360;
            const contour = [];
            
            // Create pixel map for fast lookup
            const pixelMap = new Set(pixels.map(p => p.x + ',' + p.y));
            
            // Sample radially and find furthest pixel in each direction
            for (let i = 0; i < numAngles; i++) {
                const angle = (i / numAngles) * 2 * Math.PI;
                const dx = Math.cos(angle);
                const dy = Math.sin(angle);
                
                let maxDist = 0;
                let furthestPoint = null;
                
                // Search along ray
                for (let dist = 0; dist < 1000; dist += 1) {
                    const x = Math.round(centroid.x + dx * dist);
                    const y = Math.round(centroid.y + dy * dist);
                    
                    if (pixelMap.has(x + ',' + y)) {
                        maxDist = dist;
                        furthestPoint = { x, y };
                    }
                }
                
                if (furthestPoint) {
                    contour.push({
                        x: furthestPoint.x - centroid.x,
                        y: furthestPoint.y - centroid.y
                    });
                }
            }
            
            // Fill gaps and smooth
            return fillAndSmoothContour(contour);
        }
        
        function fillAndSmoothContour(contour) {
            if (contour.length < 3) return contour;
            
            // Fill gaps by interpolation
            const filled = [];
            for (let i = 0; i < contour.length; i++) {
                if (contour[i]) {
                    filled.push(contour[i]);
                } else {
                    // Find nearest non-null points
                    let prev = null, next = null;
                    for (let j = 1; j < contour.length / 2; j++) {
                        if (!prev && contour[(i - j + contour.length) % contour.length]) {
                            prev = contour[(i - j + contour.length) % contour.length];
                        }
                        if (!next && contour[(i + j) % contour.length]) {
                            next = contour[(i + j) % contour.length];
                        }
                        if (prev && next) break;
                    }
                    
                    if (prev && next) {
                        filled.push({
                            x: (prev.x + next.x) / 2,
                            y: (prev.y + next.y) / 2
                        });
                    }
                }
            }
            
            // Smooth
            return smoothContour(filled, 5);
        }
        
        function smoothContour(contour, windowSize = 3) {
            if (contour.length < 3) return contour;
            
            const smoothed = [];
            const halfWindow = Math.floor(windowSize / 2);
            
            for (let i = 0; i < contour.length; i++) {
                let sumX = 0, sumY = 0, count = 0;
                
                for (let j = -halfWindow; j <= halfWindow; j++) {
                    const idx = (i + j + contour.length) % contour.length;
                    sumX += contour[idx].x;
                    sumY += contour[idx].y;
                    count++;
                }
                
                smoothed.push({
                    x: sumX / count,
                    y: sumY / count
                });
            }
            
            return smoothed;
        }
        
        function calculateCentroid(points) {
            if (points.length === 0) return { x: CENTER_X, y: CENTER_Y };
            
            const sum = points.reduce((acc, p) => ({
                x: acc.x + p.x,
                y: acc.y + p.y
            }), { x: 0, y: 0 });
            
            return {
                x: sum.x / points.length,
                y: sum.y / points.length
            };
        }
        
        // ============================================
        // OUTLIER FILTERING WITH MAD
        // ============================================
        
        function filterOutliers(shapes) {
            if (shapes.length < 3) return shapes;
            
            console.log(`Starting outlier filtering with ${shapes.length} shapes`);
            
            // Filter by area
            const areas = shapes.map(s => s.area);
            const medianArea = median(areas);
            const areaMAD = medianAbsoluteDeviation(areas);
            
            let filtered = shapes.filter(shape => {
                const areaDiff = Math.abs(shape.area - medianArea);
                return areaDiff < 3 * areaMAD;
            });
            
            console.log(`After area filtering: ${filtered.length} shapes`);
            
            // Filter by centroid distance
            if (filtered.length > 0) {
                const centroidXs = filtered.map(s => s.centroid.x);
                const centroidYs = filtered.map(s => s.centroid.y);
                const medianX = median(centroidXs);
                const medianY = median(centroidYs);
                
                const distances = filtered.map(s => {
                    const dx = s.centroid.x - medianX;
                    const dy = s.centroid.y - medianY;
                    return Math.sqrt(dx * dx + dy * dy);
                });
                
                const medianDist = median(distances);
                const distMAD = medianAbsoluteDeviation(distances);
                
                filtered = filtered.filter((shape, idx) => {
                    return distances[idx] < medianDist + 3 * distMAD;
                });
                
                console.log(`After centroid filtering: ${filtered.length} shapes`);
            }
            
            return filtered;
        }
        
        function median(values) {
            if (values.length === 0) return 0;
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                (sorted[mid - 1] + sorted[mid]) / 2 :
                sorted[mid];
        }
        
        function medianAbsoluteDeviation(values) {
            if (values.length === 0) return 0;
            const med = median(values);
            const deviations = values.map(v => Math.abs(v - med));
            return median(deviations) * 1.4826;
        }
        
        // ============================================
        // AVERAGING WITH GAUSSIAN SMOOTHING
        // ============================================
        
        function calculateAverageShape(shapes) {
            if (shapes.length === 0) return null;
            
            // Calculate average centroid
            const avgCentroid = {
                x: shapes.reduce((sum, s) => sum + s.centroid.x, 0) / shapes.length,
                y: shapes.reduce((sum, s) => sum + s.centroid.y, 0) / shapes.length
            };
            
            // Bin by angle using the radial contours
            const numBins = 360;
            const bins = new Array(numBins).fill(null).map(() => []);
            
            shapes.forEach(shape => {
                // Use relative contour points for averaging
                shape.contour.forEach(point => {
                    const angle = Math.atan2(point.y, point.x);
                    const radius = Math.sqrt(point.x * point.x + point.y * point.y);
                    
                    let binIndex = Math.floor(((angle + Math.PI) / (2 * Math.PI)) * numBins);
                    binIndex = (binIndex + numBins) % numBins;
                    bins[binIndex].push(radius);
                });
            });
            
            // Create averaged contour using median
            const avgContour = [];
            for (let i = 0; i < numBins; i++) {
                const angle = (i / numBins) * 2 * Math.PI - Math.PI;
                
                if (bins[i].length > 0) {
                    const radius = median(bins[i]);
                    avgContour.push({
                        x: avgCentroid.x + radius * Math.cos(angle),
                        y: avgCentroid.y + radius * Math.sin(angle)
                    });
                }
            }
            
            // Apply Gaussian smoothing
            const smoothedContour = gaussianSmooth(avgContour, 2.0);
            
            // Calculate mean radius
            const radii = smoothedContour.map(p => {
                const dx = p.x - avgCentroid.x;
                const dy = p.y - avgCentroid.y;
                return Math.sqrt(dx * dx + dy * dy) / SCALE;
            });
            
            const meanRadius = radii.length > 0 ? 
                radii.reduce((sum, r) => sum + r, 0) / radii.length : 0;
            
            return {
                contour: smoothedContour,
                centroid: avgCentroid,
                meanRadius: meanRadius,
                n: shapes.length
            };
        }
        
        function gaussianSmooth(contour, sigma) {
            if (contour.length < 3) return contour;
            
            const smoothed = [];
            const kernelSize = Math.ceil(sigma * 3);
            
            // Create Gaussian kernel
            const kernel = [];
            let kernelSum = 0;
            for (let i = -kernelSize; i <= kernelSize; i++) {
                const weight = Math.exp(-(i * i) / (2 * sigma * sigma));
                kernel.push(weight);
                kernelSum += weight;
            }
            
            // Normalize kernel
            for (let i = 0; i < kernel.length; i++) {
                kernel[i] /= kernelSum;
            }
            
            // Apply convolution
            for (let i = 0; i < contour.length; i++) {
                let sumX = 0, sumY = 0;
                
                for (let j = -kernelSize; j <= kernelSize; j++) {
                    const idx = (i + j + contour.length) % contour.length;
                    const weight = kernel[j + kernelSize];
                    sumX += contour[idx].x * weight;
                    sumY += contour[idx].y * weight;
                }
                
                smoothed.push({ x: sumX, y: sumY });
            }
            
            return smoothed;
        }
        
        // ============================================
        // VISUALIZATION GENERATION
        // ============================================
        
        function generateVisualizations() {
            const container = document.getElementById('visualizations');
            container.innerHTML = '';
            
            const summaryData = {
                totalFrequencies: 0,
                totalRed: 0,
                totalBlue: 0,
                filteredRed: 0,
                filteredBlue: 0
            };
            
            // Sort frequencies
            const frequencies = Array.from(allProcessedData.keys()).sort((a, b) => a - b);
            
            frequencies.forEach(freq => {
                const data = allProcessedData.get(freq);
                if (!data) return;
                
                // Apply filtering
                const filteredRed = filterOutliers(data.redShapes);
                const filteredBlue = filterOutliers(data.blueShapes);
                
                if (filteredRed.length === 0 && filteredBlue.length === 0) return;
                
                summaryData.totalFrequencies++;
                summaryData.totalRed += data.redShapes.length;
                summaryData.totalBlue += data.blueShapes.length;
                summaryData.filteredRed += filteredRed.length;
                summaryData.filteredBlue += filteredBlue.length;
                
                // Calculate averages
                const redAvg = calculateAverageShape(filteredRed);
                const blueAvg = calculateAverageShape(filteredBlue);
                
                // Create visualization
                const canvas = createCompositeVisualization(freq, filteredRed, filteredBlue, redAvg, blueAvg);
                
                const wrapper = document.createElement('div');
                wrapper.className = 'text-center';
                
                const label = document.createElement('p');
                label.className = 'text-lg font-semibold text-gray-700 mb-2';
                label.textContent = `${freq} Hz`;
                
                const stats = document.createElement('p');
                stats.className = 'text-sm text-gray-600';
                stats.innerHTML = `
                    <span class="text-red-600">Red: ${filteredRed.length}/${data.redShapes.length}</span> | 
                    <span class="text-blue-600">Blue: ${filteredBlue.length}/${data.blueShapes.length}</span>
                `;
                
                wrapper.appendChild(label);
                wrapper.appendChild(canvas);
                wrapper.appendChild(stats);
                
                canvas.addEventListener('click', () => {
                    const link = document.createElement('a');
                    link.download = `composite_${freq}Hz.png`;
                    link.href = canvas.toDataURL();
                    link.click();
                });
                
                container.appendChild(wrapper);
            });
            
            // Update summary
            updateSummary(summaryData);
        }
        
        function createCompositeVisualization(frequency, redShapes, blueShapes, redAvg, blueAvg) {
            const canvas = document.createElement('canvas');
            canvas.width = CANVAS_SIZE;
            canvas.height = CANVAS_SIZE;
            canvas.className = 'canvas-container';
            const ctx = canvas.getContext('2d');
            
            // White background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            
            // Draw grid
            drawGrid(ctx);
            
            // Draw head circle
            drawHeadCircle(ctx);
            
            // Draw individual shapes in gray using CONVEX HULL
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.3;
            
            // Draw red individual shapes using convex hull
            redShapes.forEach(shape => {
                if (shape.hull && shape.hull.length > 2) {
                    ctx.beginPath();
                    ctx.moveTo(shape.hull[0].x, shape.hull[0].y);
                    
                    for (let i = 1; i < shape.hull.length; i++) {
                        ctx.lineTo(shape.hull[i].x, shape.hull[i].y);
                    }
                    
                    ctx.closePath();
                    ctx.stroke();
                }
            });
            
            // Draw blue individual shapes using convex hull
            blueShapes.forEach(shape => {
                if (shape.hull && shape.hull.length > 2) {
                    ctx.beginPath();
                    ctx.moveTo(shape.hull[0].x, shape.hull[0].y);
                    
                    for (let i = 1; i < shape.hull.length; i++) {
                        ctx.lineTo(shape.hull[i].x, shape.hull[i].y);
                    }
                    
                    ctx.closePath();
                    ctx.stroke();
                }
            });
            
            ctx.globalAlpha = 1.0;
            
            // Draw averaged red shape
            if (redAvg && redAvg.contour && redAvg.contour.length > 0) {
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                
                ctx.beginPath();
                ctx.moveTo(redAvg.contour[0].x, redAvg.contour[0].y);
                
                for (let i = 1; i < redAvg.contour.length; i++) {
                    ctx.lineTo(redAvg.contour[i].x, redAvg.contour[i].y);
                }
                
                ctx.closePath();
                ctx.stroke();
            }
            
            // Draw averaged blue shape
            if (blueAvg && blueAvg.contour && blueAvg.contour.length > 0) {
                ctx.strokeStyle = '#0000FF';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                
                ctx.beginPath();
                ctx.moveTo(blueAvg.contour[0].x, blueAvg.contour[0].y);
                
                for (let i = 1; i < blueAvg.contour.length; i++) {
                    ctx.lineTo(blueAvg.contour[i].x, blueAvg.contour[i].y);
                }
                
                ctx.closePath();
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
            
            // Add labels
            ctx.fillStyle = '#333333';
            ctx.font = 'bold 24px sans-serif';
            ctx.fillText(`${frequency} Hz`, 50, 50);
            
            ctx.font = '16px sans-serif';
            let statsY = 80;
            
            if (redAvg) {
                ctx.fillStyle = '#FF0000';
                ctx.fillText(
                    `In-phase: N=${redAvg.n}, Mean R=${redAvg.meanRadius.toFixed(2)} units`,
                    50,
                    statsY
                );
                statsY += 25;
            }
            
            if (blueAvg) {
                ctx.fillStyle = '#0000FF';
                ctx.fillText(
                    `Out-of-phase: N=${blueAvg.n}, Mean R=${blueAvg.meanRadius.toFixed(2)} units`,
                    50,
                    statsY
                );
            }
            
            return canvas;
        }
        
        function drawGrid(ctx) {
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            
            // Vertical lines
            for (let i = 0; i <= 20; i++) {
                const x = i * SCALE;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, CANVAS_SIZE);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let i = 0; i <= 20; i++) {
                const y = i * SCALE;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(CANVAS_SIZE, y);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(0, CENTER_Y);
            ctx.lineTo(CANVAS_SIZE, CENTER_Y);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(CENTER_X, 0);
            ctx.lineTo(CENTER_X, CANVAS_SIZE);
            ctx.stroke();
        }
        
        function drawHeadCircle(ctx) {
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            
            ctx.beginPath();
            ctx.arc(CENTER_X, CENTER_Y, HEAD_RADIUS * SCALE, 0, 2 * Math.PI);
            ctx.stroke();
        }
        
        // ============================================
        // UI UPDATES
        // ============================================
        
        function updateProgress(text, percentage) {
            document.getElementById('progress-text').textContent = text;
            document.getElementById('progress-percentage').textContent = `${Math.round(percentage)}%`;
            document.getElementById('progress-bar').style.width = `${percentage}%`;
        }
        
        function updateSummary(data) {
            const summary = document.getElementById('summary');
            summary.innerHTML = `
                <div class="bg-blue-50 p-4 rounded-lg">
                    <div class="text-2xl font-bold text-blue-700">${data.totalFrequencies}</div>
                    <div class="text-sm text-gray-600">Frequencies Analyzed</div>
                </div>
                <div class="bg-red-50 p-4 rounded-lg">
                    <div class="text-2xl font-bold text-red-700">${data.filteredRed}/${data.totalRed}</div>
                    <div class="text-sm text-gray-600">Red Shapes (${Math.round(data.filteredRed/data.totalRed*100)}% retained)</div>
                </div>
                <div class="bg-blue-50 p-4 rounded-lg">
                    <div class="text-2xl font-bold text-blue-700">${data.filteredBlue}/${data.totalBlue}</div>
                    <div class="text-sm text-gray-600">Blue Shapes (${Math.round(data.filteredBlue/data.totalBlue*100)}% retained)</div>
                </div>
                <div class="bg-purple-50 p-4 rounded-lg">
                    <div class="text-2xl font-bold text-purple-700">MAD-based</div>
                    <div class="text-sm text-gray-600">Outlier Filtering (3œÉ)</div>
                </div>
            `;
        }
        
        // Initialize
        console.log('Sound Object Analyzer v9.6 loaded');
        console.log('Processing pipeline:');
        console.log('  1. Detect perfect vertical/horizontal lines');
        console.log('  2. Find crossing points (centroid markers)');
        console.log('  3. Remove marker pixels FIRST');
        console.log('  4. Process clean shapes with convex hull');
        console.log('  5. Generate smooth averages');
    </script>
</body>
</html>
